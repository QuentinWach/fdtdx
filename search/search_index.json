{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FDTDX Documentation","text":"<p>FDTDX is a high-performance framework for electromagnetic simulations and inverse design of photonic devices. Built on JAX, it provides GPU-accelerated FDTD (Finite-Difference Time-Domain) simulations with automatic differentiation capabilities.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install FDTDX using pip:</p> <pre><code>pip install fdtdx\n</code></pre> <p>For development installation, clone the repository and install in editable mode:</p> <pre><code>git clone https://github.com/ymahlau/fdtdx\ncd fdtdx\npip install -e .\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#high-performance-computing","title":"High Performance Computing","text":"<ul> <li>Native GPU acceleration through JAX</li> <li>Multi-GPU scaling for large simulations </li> <li>Memory-efficient time-reversal implementation</li> <li>Optimized for large-scale inverse design</li> <li>Flexible boundary conditions with PML support</li> </ul>"},{"location":"#guides","title":"Guides","text":"<ul> <li>Object Placement Guide - Learn how to position and configure simulation objects</li> <li>Materials Guide - Learn how to use materials in FDTDX</li> <li>Fabrication Constraints - Learn how to use the parameter mapping API to include fabrication constraints</li> <li>Interface Compression - Learn how to use The compresion API to compute gradients with reversible autodiff</li> <li>See the examples folder for complete scripts for inverse design in FDTDX</li> <li>More guides will follow shortly</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you find this repository helpful for your work, please consider citing:</p> <pre><code>@article{schubert2024quantized,\n  title={Quantized Inverse Design for Photonic Integrated Circuits},\n  author={Schubert, Frederik and Mahlau, Yannik and Bethmann, Konrad and Hartmann, Fabian and Caspary, Reinhard and Munderloh, Marco and Ostermann, J{\\\"o}rn and Rosenhahn, Bodo},\n  journal={arXiv preprint arXiv:2407.10273},\n  year={2024}\n}\n</code></pre>"},{"location":"api/","title":"API Documentation","text":"<p>The FDTDX API is organized into several main components:</p>"},{"location":"api/#objects","title":"Objects","text":"<p>The Objects package defines simulation components: - Sources and detectors - Boundary conditions - Object positioning - Devices with a variable shape that can be optimized</p>"},{"location":"api/#fdtd","title":"FDTD","text":"<p>The FDTD package provides simulation algorithms: - FDTD implementations - Memory efficient simulations for automatic differentiation</p>"},{"location":"api/#config","title":"Config","text":"<p>The Config package provides configuration files for specifying simulation parameters</p>"},{"location":"api/#constants","title":"Constants","text":"<p>The Constants package provides a small list of commonly used material constants</p>"},{"location":"api/#interfaces","title":"Interfaces","text":"<p>The Interfaces package contains functions for interface compression, enabling memory efficient autodiff.</p>"},{"location":"api/#materials","title":"Materials","text":"<p>The Materials package contains the basic structure for defining a material in FDTDX.</p>"},{"location":"api/#typing","title":"Typing","text":"<p>The Typing package contains a number of type hints used throughout the FDTDX package</p>"},{"location":"api/#utils","title":"Utils","text":"<p>The Utility package contains utility functions for logging and plotting simulations</p>"},{"location":"api/#core-package","title":"Core Package","text":"<p>The Core package provides fundamental data structures and utilities used mostly internally by FDTDX</p>"},{"location":"api/config/","title":"Configuration","text":""},{"location":"api/config/#fdtdx.config.SimulationConfig","title":"<code>fdtdx.config.SimulationConfig</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Configuration settings for FDTD simulations.</p> <p>This class contains all the parameters needed to configure and run an FDTD simulation, including spatial and temporal discretization, hardware backend, and gradient computation settings.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>float</code> <p>Total simulation time in seconds.</p> <code>resolution</code> <code>float</code> <p>Spatial resolution of the simulation grid in meters.</p> <code>backend</code> <code>Literal['gpu', 'tpu', 'METAL', 'cpu']</code> <p>Computation backend ('gpu', 'tpu', 'cpu' or 'METAL').</p> <code>dtype</code> <code>dtype</code> <p>Data type for numerical computations.</p> <code>courant_factor</code> <code>float</code> <p>Safety factor for the Courant condition (default: 0.99).</p> <code>gradient_config</code> <code>GradientConfig | None</code> <p>Optional configuration for gradient computation.</p> Source code in <code>src/fdtdx/config.py</code> <pre><code>@extended_autoinit\nclass SimulationConfig(ExtendedTreeClass):\n    \"\"\"Configuration settings for FDTD simulations.\n\n    This class contains all the parameters needed to configure and run an FDTD\n    simulation, including spatial and temporal discretization, hardware backend,\n    and gradient computation settings.\n\n    Attributes:\n        time: Total simulation time in seconds.\n        resolution: Spatial resolution of the simulation grid in meters.\n        backend: Computation backend ('gpu', 'tpu', 'cpu' or 'METAL').\n        dtype: Data type for numerical computations.\n        courant_factor: Safety factor for the Courant condition (default: 0.99).\n        gradient_config: Optional configuration for gradient computation.\n    \"\"\"\n\n    time: float\n    resolution: float\n    backend: Literal[\"gpu\", \"tpu\", \"METAL\", \"cpu\"] = frozen_field(default=\"gpu\")\n    dtype: jnp.dtype = frozen_field(default=jnp.float32)\n    courant_factor: float = 0.99\n    gradient_config: GradientConfig | None = None\n\n    def __post_init__(self):\n        from jax import extend\n\n        current_platform = extend.backend.get_backend().platform\n\n        if current_platform == \"METAL\" and self.backend == \"gpu\":\n            self.backend = \"METAL\"\n\n        if self.backend == \"METAL\":\n            try:\n                jax.devices()\n                logger.info(\"METAL device found and will be used for computations\")\n                jax.config.update(\"jax_platform_name\", \"metal\")\n            except RuntimeError:\n                logger.warning(\"METAL initialization failed, falling back to CPU!\")\n                self.backend = \"cpu\"\n        elif self.backend in [\"gpu\", \"tpu\"]:\n            try:\n                jax.devices(self.backend)\n                logger.info(f\"{str.upper(self.backend)} found and will be used for computations\")\n                jax.config.update(\"jax_platform_name\", self.backend)\n            except RuntimeError:\n                logger.warning(f\"{str.upper(self.backend)} not found, falling back to CPU!\")\n                self.backend = \"cpu\"\n\n        if self.backend == \"cpu\":\n            jax.config.update(\"jax_platform_name\", \"cpu\")\n\n    @property\n    def courant_number(self) -&gt; float:\n        \"\"\"Calculate the Courant number for the simulation.\n\n        The Courant number is a dimensionless quantity that determines stability\n        of the FDTD simulation. It represents the ratio of the physical propagation\n        speed to the numerical propagation speed.\n\n        Returns:\n            float: The Courant number, scaled by the courant_factor and normalized\n                for 3D simulations.\n        \"\"\"\n        return self.courant_factor / math.sqrt(3)\n\n    @property\n    def time_step_duration(self) -&gt; float:\n        \"\"\"Calculate the duration of a single time step.\n\n        The time step duration is determined by the Courant condition to ensure\n        numerical stability. It depends on the spatial resolution and the speed\n        of light.\n\n        Returns:\n            float: Time step duration in seconds, calculated using the Courant\n                condition and spatial resolution.\n        \"\"\"\n        return self.courant_number * self.resolution / constants.c\n\n    @property\n    def time_steps_total(self) -&gt; int:\n        \"\"\"Calculate the total number of time steps for the simulation.\n\n        Determines how many discrete time steps are needed to simulate the\n        specified total simulation time, based on the time step duration.\n\n        Returns:\n            int: Total number of time steps needed to reach the specified\n                simulation time.\n        \"\"\"\n        return round(self.time / self.time_step_duration)\n\n    @property\n    def max_travel_distance(self) -&gt; float:\n        \"\"\"Calculate the maximum distance light can travel during the simulation.\n\n        This represents the theoretical maximum distance that light could travel\n        through the simulation volume, useful for determining if the simulation\n        time is sufficient for light to traverse the entire domain.\n\n        Returns:\n            float: Maximum travel distance in meters, based on the speed of light\n                and total simulation time.\n        \"\"\"\n        return constants.c * self.time\n\n    @property\n    def only_forward(self) -&gt; bool:\n        \"\"\"Check if the simulation is forward-only (no gradient computation).\n\n        Forward-only simulations don't compute gradients and are used when only\n        the forward propagation of electromagnetic fields is needed, without\n        optimization.\n\n        Returns:\n            bool: True if no gradient configuration is specified, False otherwise.\n        \"\"\"\n        return self.gradient_config is None\n\n    @property\n    def invertible_optimization(self) -&gt; bool:\n        \"\"\"Check if invertible optimization is enabled.\n\n        Invertible optimization uses time-reversibility of Maxwell's equations\n        to compute gradients with reduced memory requirements compared to\n        checkpointing-based methods.\n\n        Returns:\n            bool: True if gradient computation uses invertible differentiation\n                (recorder is specified), False otherwise.\n        \"\"\"\n        if self.gradient_config is None:\n            return False\n        return self.gradient_config.recorder is not None\n</code></pre>"},{"location":"api/config/#fdtdx.config.SimulationConfig.courant_number","title":"<code>courant_number: float</code>  <code>property</code>","text":"<p>Calculate the Courant number for the simulation.</p> <p>The Courant number is a dimensionless quantity that determines stability of the FDTD simulation. It represents the ratio of the physical propagation speed to the numerical propagation speed.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Courant number, scaled by the courant_factor and normalized for 3D simulations.</p>"},{"location":"api/config/#fdtdx.config.SimulationConfig.invertible_optimization","title":"<code>invertible_optimization: bool</code>  <code>property</code>","text":"<p>Check if invertible optimization is enabled.</p> <p>Invertible optimization uses time-reversibility of Maxwell's equations to compute gradients with reduced memory requirements compared to checkpointing-based methods.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if gradient computation uses invertible differentiation (recorder is specified), False otherwise.</p>"},{"location":"api/config/#fdtdx.config.SimulationConfig.max_travel_distance","title":"<code>max_travel_distance: float</code>  <code>property</code>","text":"<p>Calculate the maximum distance light can travel during the simulation.</p> <p>This represents the theoretical maximum distance that light could travel through the simulation volume, useful for determining if the simulation time is sufficient for light to traverse the entire domain.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum travel distance in meters, based on the speed of light and total simulation time.</p>"},{"location":"api/config/#fdtdx.config.SimulationConfig.only_forward","title":"<code>only_forward: bool</code>  <code>property</code>","text":"<p>Check if the simulation is forward-only (no gradient computation).</p> <p>Forward-only simulations don't compute gradients and are used when only the forward propagation of electromagnetic fields is needed, without optimization.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if no gradient configuration is specified, False otherwise.</p>"},{"location":"api/config/#fdtdx.config.SimulationConfig.time_step_duration","title":"<code>time_step_duration: float</code>  <code>property</code>","text":"<p>Calculate the duration of a single time step.</p> <p>The time step duration is determined by the Courant condition to ensure numerical stability. It depends on the spatial resolution and the speed of light.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Time step duration in seconds, calculated using the Courant condition and spatial resolution.</p>"},{"location":"api/config/#fdtdx.config.SimulationConfig.time_steps_total","title":"<code>time_steps_total: int</code>  <code>property</code>","text":"<p>Calculate the total number of time steps for the simulation.</p> <p>Determines how many discrete time steps are needed to simulate the specified total simulation time, based on the time step duration.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Total number of time steps needed to reach the specified simulation time.</p>"},{"location":"api/config/#fdtdx.config.GradientConfig","title":"<code>fdtdx.config.GradientConfig</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Configuration for gradient computation in simulations.</p> <p>This class handles settings for automatic differentiation, supporting either invertible differentiation with a recorder or checkpointing-based differentiation.</p> <p>Parameters:</p> Name Type Description Default <code>recorder</code> <p>Optional recorder for invertible differentiation. If provided, invertible differentiation will be used.</p> required <code>num_checkpoints</code> <p>Optional number of checkpoints for checkpointing-based differentiation. If provided, checkpointing will be used.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If both recorder and num_checkpoints are provided, or if neither is provided.</p> Source code in <code>src/fdtdx/config.py</code> <pre><code>@extended_autoinit\nclass GradientConfig(ExtendedTreeClass):\n    \"\"\"Configuration for gradient computation in simulations.\n\n    This class handles settings for automatic differentiation, supporting either\n    invertible differentiation with a recorder or checkpointing-based differentiation.\n\n    Args:\n        recorder: Optional recorder for invertible differentiation. If provided,\n            invertible differentiation will be used.\n        num_checkpoints: Optional number of checkpoints for checkpointing-based\n            differentiation. If provided, checkpointing will be used.\n\n    Raises:\n        Exception: If both recorder and num_checkpoints are provided, or if neither\n            is provided.\n    \"\"\"\n\n    method: Literal[\"reversible\", \"checkpointed\"] = frozen_field(default=\"reversible\")\n    recorder: Recorder | None = None\n    num_checkpoints: int | None = None\n\n    def __post_init__(self):\n        if self.method == \"reversible\" and self.recorder is None:\n            raise Exception(\"Need Recorder in gradient config to compute reversible gradients\")\n        if self.method == \"checkpointed\" and self.num_checkpoints is None:\n            raise Exception(\"Need Checkpoint Number in gradient config to compute checkpointed gradients\")\n</code></pre>"},{"location":"api/constants/","title":"Constants","text":""},{"location":"api/constants/#_1","title":"Constants","text":""},{"location":"api/constants/#physical-constants","title":"Physical Constants","text":""},{"location":"api/constants/#fdtdx.constants.c","title":"<code>fdtdx.constants.c: float = 299792458.0</code>  <code>module-attribute</code>","text":"<p>Speed of light in vacuum (m/s).</p>"},{"location":"api/constants/#fdtdx.constants.mu0","title":"<code>fdtdx.constants.mu0: float = 4e-07 * math.pi</code>  <code>module-attribute</code>","text":"<p>Vacuum permeability (H/m).</p>"},{"location":"api/constants/#fdtdx.constants.eps0","title":"<code>fdtdx.constants.eps0: float = 1.0 / mu0 * c ** 2</code>  <code>module-attribute</code>","text":"<p>Vacuum permittivity (F/m).</p>"},{"location":"api/constants/#fdtdx.constants.eta0","title":"<code>fdtdx.constants.eta0: float = mu0 * c</code>  <code>module-attribute</code>","text":"<p>Free space impedance (\u03a9).</p>"},{"location":"api/constants/#fdtdx.constants.wavelength_to_period","title":"<code>fdtdx.constants.wavelength_to_period(wavelength)</code>","text":"<p>Convert wavelength to time period using speed of light.</p> <p>Uses the speed of light constant to calculate the corresponding time period for a given wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float</code> <p>The wavelength in meters.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The corresponding time period in seconds.</p> Source code in <code>src/fdtdx/constants.py</code> <pre><code>def wavelength_to_period(wavelength: float) -&gt; float:\n    \"\"\"Convert wavelength to time period using speed of light.\n\n    Uses the speed of light constant to calculate the corresponding time period\n    for a given wavelength.\n\n    Args:\n        wavelength: The wavelength in meters.\n\n    Returns:\n        float: The corresponding time period in seconds.\n    \"\"\"\n    return wavelength / c\n</code></pre>"},{"location":"api/constants/#material-properties","title":"Material Properties","text":""},{"location":"api/constants/#fdtdx.constants.relative_permittivity_air","title":"<code>fdtdx.constants.relative_permittivity_air: float = 1.0</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of air.</p>"},{"location":"api/constants/#fdtdx.constants.relative_permittivity_substrate","title":"<code>fdtdx.constants.relative_permittivity_substrate: float = 2.1025</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of standard substrate material.</p>"},{"location":"api/constants/#fdtdx.constants.relative_permittivity_polymer","title":"<code>fdtdx.constants.relative_permittivity_polymer: float = 2.368521</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of standard polymer material.</p>"},{"location":"api/constants/#fdtdx.constants.relative_permittivity_silicon","title":"<code>fdtdx.constants.relative_permittivity_silicon: float = 12.25</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of silicon.</p>"},{"location":"api/constants/#fdtdx.constants.relative_permittivity_silica","title":"<code>fdtdx.constants.relative_permittivity_silica: float = 2.25</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of silica.</p>"},{"location":"api/constants/#fdtdx.constants.relative_permittivity_SZ_2080","title":"<code>fdtdx.constants.relative_permittivity_SZ_2080: float = 2.1786</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of SZ2080 photoresist.</p>"},{"location":"api/constants/#fdtdx.constants.relative_permittivity_ma_N_1400_series","title":"<code>fdtdx.constants.relative_permittivity_ma_N_1400_series: float = 2.6326</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of ma-N 1400 series photoresist.</p>"},{"location":"api/constants/#fdtdx.constants.relative_permittivity_bacteria","title":"<code>fdtdx.constants.relative_permittivity_bacteria: float = 1.96</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of bacteria.</p>"},{"location":"api/constants/#fdtdx.constants.relative_permittivity_water","title":"<code>fdtdx.constants.relative_permittivity_water: float = 1.737</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of water.</p>"},{"location":"api/constants/#fdtdx.constants.relative_permittivity_fused_silica","title":"<code>fdtdx.constants.relative_permittivity_fused_silica: float = 2.13685924</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of fused silica.</p>"},{"location":"api/constants/#fdtdx.constants.relative_permittivity_coated_silica","title":"<code>fdtdx.constants.relative_permittivity_coated_silica: float = 1.69</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of coated silica.</p>"},{"location":"api/constants/#fdtdx.constants.relative_permittivity_resin","title":"<code>fdtdx.constants.relative_permittivity_resin: float = 2.202256</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of standard resin.</p>"},{"location":"api/constants/#fdtdx.constants.relative_permittivity_ormo_prime","title":"<code>fdtdx.constants.relative_permittivity_ormo_prime: float = 1.817104</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of Ormocer primer.</p>"},{"location":"api/core/","title":"Core","text":""},{"location":"api/core/#_1","title":"Core","text":""},{"location":"api/core/#core-functions","title":"Core Functions","text":"<p>These core functions are used by many different parts of the FDTDX package</p> <p>A container for specifying the character of a wave by either frequency, period or wavelength. Additionally, a phase offset can be set.</p>"},{"location":"api/core/#fdtdx.core.WaveCharacter","title":"<code>fdtdx.core.WaveCharacter</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Class describing a wavelength/period/frequency in free space. Importantly, the wave characteristic conversion is based on a free space wave when using the wavelength (For conversion, a refractive index of 1 is used).</p> <p>Attributes:</p> Name Type Description <code>_period</code> <code>float | None</code> <p>Optional period in seconds. Mutually exclusive with _wavelength and _frequency.</p> <code>_wavelength</code> <code>float | None</code> <p>Optional wavelength in meters. Mutually exclusive with _period and _frequency.</p> <code>_frequency</code> <code>float | None</code> <p>Optional frequency in Hz. Mutually exclusive with _period and _wavelength.</p> Source code in <code>src/fdtdx/core/wavelength.py</code> <pre><code>@extended_autoinit\nclass WaveCharacter(ExtendedTreeClass):\n    \"\"\"Class describing a wavelength/period/frequency in free space. Importantly, the wave characteristic conversion is\n    based on a free space wave when using the wavelength (For conversion, a refractive index of 1 is used).\n\n\n\n    Attributes:\n        _period: Optional period in seconds. Mutually exclusive with _wavelength and _frequency.\n        _wavelength: Optional wavelength in meters. Mutually exclusive with _period and _frequency.\n        _frequency: Optional frequency in Hz. Mutually exclusive with _period and _wavelength.\n    \"\"\"\n\n    phase_shift: float = 0.0\n    _period: float | None = field(default=None, alias=\"period\")\n    _wavelength: float | None = field(default=None, alias=\"wavelength\")\n    _frequency: float | None = field(default=None, alias=\"frequency\")\n\n    def __post_init__(\n        self,\n    ):\n        self._check_input()\n\n    def _check_input(self):\n        if sum([self._period is not None, self._frequency is not None, self._wavelength is not None]) != 1:\n            raise Exception(\"Need to set exactly one of Period, Frequency or Wavelength in WaveCharacter\")\n\n    @property\n    def period(self) -&gt; float:\n        \"\"\"Gets the period in seconds.\n\n        Returns:\n            float: The period in seconds.\n\n        Raises:\n            Exception: If neither period nor wavelength is set, or if both are set.\n        \"\"\"\n        self._check_input()\n        if self._period is not None:\n            return self._period\n        if self._wavelength is not None:\n            return self._wavelength / constants.c\n        if self._frequency is not None:\n            return 1.0 / self._frequency\n        raise Exception(\"This should never happen\")\n\n    @property\n    def wavelength(self) -&gt; float:\n        \"\"\"Gets the wavelength in meters.\n\n        Returns:\n            float: The wavelength in meters.\n\n        Raises:\n            Exception: If neither period nor wavelength is set, or if both are set.\n        \"\"\"\n        self._check_input()\n        if self._wavelength is not None:\n            return self._wavelength\n        if self._period is not None:\n            return self._period * constants.c\n        if self._frequency is not None:\n            return constants.c / self._frequency\n        raise Exception(\"This should never happen\")\n\n    @property\n    def frequency(self) -&gt; float:\n        \"\"\"Gets the frequency in Hz.\n\n        Returns:\n            float: The frequency in Hz.\n        \"\"\"\n        self._check_input()\n        if self._period is not None:\n            return 1.0 / self._period\n        if self._wavelength is not None:\n            return constants.c / self._wavelength\n        if self._frequency is not None:\n            return self._frequency\n        raise Exception(\"This should never happen\")\n</code></pre>"},{"location":"api/core/#fdtdx.core.WaveCharacter.frequency","title":"<code>frequency: float</code>  <code>property</code>","text":"<p>Gets the frequency in Hz.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The frequency in Hz.</p>"},{"location":"api/core/#fdtdx.core.WaveCharacter.period","title":"<code>period: float</code>  <code>property</code>","text":"<p>Gets the period in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The period in seconds.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If neither period nor wavelength is set, or if both are set.</p>"},{"location":"api/core/#fdtdx.core.WaveCharacter.wavelength","title":"<code>wavelength: float</code>  <code>property</code>","text":"<p>Gets the wavelength in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The wavelength in meters.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If neither period nor wavelength is set, or if both are set.</p>"},{"location":"api/core/#physical-metrics","title":"Physical metrics","text":"<p>Convenience function that computes the ratio between a physical metrics measured at different places in the simulation.</p> <p>Computes the physical energy in the simualation grid.</p> <p>Computes the poynting flux.</p>"},{"location":"api/core/#fdtdx.core.metric_efficiency","title":"<code>fdtdx.core.metric_efficiency(detector_states, in_names, out_names, metric_name)</code>","text":"<p>Calculate efficiency metrics between input and output detectors.</p> <p>Computes efficiency ratios between input and output detectors by comparing their metric values (e.g. energy, power). For each input-output detector pair, calculates the ratio of output/input metric values.</p> <p>Parameters:</p> Name Type Description Default <code>detector_states</code> <code>dict[str, dict[str, Array]]</code> <p>Dictionary mapping detector names to their state dictionaries, which contain metric values as JAX arrays</p> required <code>in_names</code> <code>Sequence[str]</code> <p>Names of input detectors to use as reference</p> required <code>out_names</code> <code>Sequence[str]</code> <p>Names of output detectors to compare against inputs</p> required <code>metric_name</code> <code>str</code> <p>Name of the metric to compare between detectors (e.g. \"energy\")</p> required <p>Returns:</p> Type Description <code>tuple[Array, dict[str, Any]]</code> <p>tuple containing: - jax.Array: Mean efficiency across all input-output pairs - dict: Additional info including individual metric values and efficiencies   with keys like:     \"{detector}{metric}\" for raw metric values     \"{out}{by}_{in}_efficiency\" for individual efficiency ratios</p> Source code in <code>src/fdtdx/core/physics/losses.py</code> <pre><code>def metric_efficiency(\n    detector_states: dict[str, dict[str, jax.Array]],\n    in_names: Sequence[str],\n    out_names: Sequence[str],\n    metric_name: str,\n) -&gt; tuple[jax.Array, dict[str, Any]]:\n    \"\"\"Calculate efficiency metrics between input and output detectors.\n\n    Computes efficiency ratios between input and output detectors by comparing their\n    metric values (e.g. energy, power). For each input-output detector pair, calculates\n    the ratio of output/input metric values.\n\n    Args:\n        detector_states: Dictionary mapping detector names to their state dictionaries,\n            which contain metric values as JAX arrays\n        in_names: Names of input detectors to use as reference\n        out_names: Names of output detectors to compare against inputs\n        metric_name: Name of the metric to compare between detectors (e.g. \"energy\")\n\n    Returns:\n        tuple containing:\n            - jax.Array: Mean efficiency across all input-output pairs\n            - dict: Additional info including individual metric values and efficiencies\n              with keys like:\n                \"{detector}_{metric}\" for raw metric values\n                \"{out}_{by}_{in}_efficiency\" for individual efficiency ratios\n    \"\"\"\n    efficiencies, info = [], {}\n    for in_name in in_names:\n        in_value = jax.lax.stop_gradient(detector_states[in_name][metric_name].mean())\n        info[f\"{in_name}_{metric_name}\"] = in_value\n        for out_name in out_names:\n            out_value = detector_states[out_name][metric_name].mean()\n            eff = jnp.where(in_value == 0, 0, out_value / in_value)\n            efficiencies.append(eff)\n            info[f\"{out_name}_{metric_name}\"] = out_value\n            info[f\"{out_name}_by_{in_name}_efficiency\"] = eff\n    objective = jnp.mean(jnp.asarray(efficiencies))\n    return objective, info\n</code></pre>"},{"location":"api/core/#fdtdx.core.compute_energy","title":"<code>fdtdx.core.compute_energy(E, H, inv_permittivity, inv_permeability, axis=0)</code>","text":"<p>Computes the total electromagnetic energy density of the field.</p> <p>Parameters:</p> Name Type Description Default <code>E</code> <code>Array</code> <p>Electric field array with shape (3, nx, ny, nz)</p> required <code>H</code> <code>Array</code> <p>Magnetic field array with shape (3, nx, ny, nz)</p> required <code>inv_permittivity</code> <code>Array</code> <p>Inverse of the electric permittivity array</p> required <code>inv_permeability</code> <code>Array | float</code> <p>Inverse of the magnetic permeability array</p> required <code>axis</code> <code>int</code> <p>Axis index of the X,Y,Z component for the E and H field</p> <code>0</code> <p>Returns:     Total energy density array with shape (nx, ny, nz)</p> Source code in <code>src/fdtdx/core/physics/metrics.py</code> <pre><code>def compute_energy(\n    E: jax.Array,\n    H: jax.Array,\n    inv_permittivity: jax.Array,\n    inv_permeability: jax.Array | float,\n    axis: int = 0,\n) -&gt; jax.Array:\n    \"\"\"Computes the total electromagnetic energy density of the field.\n\n    Args:\n        E: Electric field array with shape (3, nx, ny, nz)\n        H: Magnetic field array with shape (3, nx, ny, nz)\n        inv_permittivity: Inverse of the electric permittivity array\n        inv_permeability: Inverse of the magnetic permeability array\n        axis: Axis index of the X,Y,Z component for the E and H field\n    Returns:\n        Total energy density array with shape (nx, ny, nz)\n    \"\"\"\n    abs_E = jnp.sum(jnp.square(jnp.abs(E)), axis=axis)\n    energy_E = 0.5 * (1 / inv_permittivity) * abs_E\n\n    abs_H = jnp.sum(jnp.square(jnp.abs(H)), axis=axis)\n    energy_H = 0.5 * (1 / inv_permeability) * abs_H\n\n    total_energy = energy_E + energy_H\n    return total_energy\n</code></pre>"},{"location":"api/core/#fdtdx.core.poynting_flux","title":"<code>fdtdx.core.poynting_flux(E, H, axis=0)</code>","text":"<p>Calculates the Poynting vector (energy flux) from E and H fields.</p> <p>Parameters:</p> Name Type Description Default <code>E</code> <code>Array</code> <p>Electric field array with shape (3, nx, ny, nz)</p> required <code>H</code> <code>Array</code> <p>Magnetic field array with shape (3, nx, ny, nz)</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Poynting vector array with shape (3, nx, ny, nz) representing</p> <code>Array</code> <p>energy flux in each direction</p> Source code in <code>src/fdtdx/core/physics/metrics.py</code> <pre><code>def poynting_flux(E: jax.Array, H: jax.Array, axis: int = 0) -&gt; jax.Array:\n    \"\"\"Calculates the Poynting vector (energy flux) from E and H fields.\n\n    Args:\n        E: Electric field array with shape (3, nx, ny, nz)\n        H: Magnetic field array with shape (3, nx, ny, nz)\n\n    Returns:\n        Poynting vector array with shape (3, nx, ny, nz) representing\n        energy flux in each direction\n    \"\"\"\n    return jnp.cross(\n        E,\n        jnp.conj(H),\n        axisa=axis,\n        axisb=axis,\n        axisc=axis,\n    )\n</code></pre>"},{"location":"api/fdtd/","title":"FDTD","text":""},{"location":"api/fdtd/#_1","title":"FDTD","text":""},{"location":"api/fdtd/#object-placement-and-parameters","title":"Object Placement and Parameters","text":"<p>Main entry point for placing and initializing simulation objects.</p> <p>Applies parameters to devices and updates source states to be ready for simulation.</p>"},{"location":"api/fdtd/#fdtdx.fdtd.place_objects","title":"<code>fdtdx.fdtd.place_objects(volume, config, constraints, key)</code>","text":"<p>Places simulation objects according to specified constraints and initializes containers.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>SimulationObject</code> <p>The volume object defining the simulation boundaries</p> required <code>config</code> <code>SimulationConfig</code> <p>The simulation configuration</p> required <code>constraints</code> <code>Sequence[PositionConstraint | SizeConstraint | SizeExtensionConstraint | GridCoordinateConstraint | RealCoordinateConstraint]</code> <p>Sequence of positioning and sizing constraints for objects</p> required <code>key</code> <code>Array</code> <p>JAX random key for initialization</p> required <p>Returns:</p> Type Description <code>tuple[ObjectContainer, ArrayContainer, ParameterContainer, SimulationConfig, dict[str, Any]]</code> <p>A tuple containing: - ObjectContainer with placed simulation objects - ArrayContainer with initialized field arrays - ParameterContainer with device parameters - Updated SimulationConfig - Dictionary with additional initialization info</p> Source code in <code>src/fdtdx/fdtd/initialization.py</code> <pre><code>def place_objects(\n    volume: SimulationObject,\n    config: SimulationConfig,\n    constraints: Sequence[\n        (\n            PositionConstraint\n            | SizeConstraint\n            | SizeExtensionConstraint\n            | GridCoordinateConstraint\n            | RealCoordinateConstraint\n        )\n    ],\n    key: jax.Array,\n) -&gt; tuple[\n    ObjectContainer,\n    ArrayContainer,\n    ParameterContainer,\n    SimulationConfig,\n    dict[str, Any],\n]:\n    \"\"\"Places simulation objects according to specified constraints and initializes containers.\n\n    Args:\n        volume: The volume object defining the simulation boundaries\n        config: The simulation configuration\n        constraints: Sequence of positioning and sizing constraints for objects\n        key: JAX random key for initialization\n\n    Returns:\n        A tuple containing:\n            - ObjectContainer with placed simulation objects\n            - ArrayContainer with initialized field arrays\n            - ParameterContainer with device parameters\n            - Updated SimulationConfig\n            - Dictionary with additional initialization info\n    \"\"\"\n    slice_tuple_dict = _resolve_object_constraints(\n        volume=volume,\n        constraints=constraints,\n        config=config,\n    )\n    obj_list = list(slice_tuple_dict.keys())\n\n    # place objects on computed grid positions\n    placed_objects = []\n    for o in obj_list:\n        if o == volume:\n            continue\n        key, subkey = jax.random.split(key)\n        placed_objects.append(\n            o.place_on_grid(\n                grid_slice_tuple=slice_tuple_dict[o],\n                config=config,\n                key=subkey,\n            )\n        )\n    key, subkey = jax.random.split(key)\n    placed_objects.insert(\n        0,\n        volume.place_on_grid(\n            grid_slice_tuple=slice_tuple_dict[volume],\n            config=config,\n            key=subkey,\n        ),\n    )\n\n    # create container\n    objects = ObjectContainer(\n        object_list=placed_objects,\n        volume_idx=0,\n    )\n    params = _init_params(\n        objects=objects,\n        key=key,\n    )\n    arrays, config, info = _init_arrays(\n        objects=objects,\n        config=config,\n    )\n\n    # replace config in objects with compiled config\n    new_object_list = []\n    for o in objects.objects:\n        o = o.aset(\"_config\", config)\n        new_object_list.append(o)\n    objects = ObjectContainer(\n        object_list=new_object_list,\n        volume_idx=0,\n    )\n\n    return objects, arrays, params, config, info\n</code></pre>"},{"location":"api/fdtd/#fdtdx.fdtd.apply_params","title":"<code>fdtdx.fdtd.apply_params(arrays, objects, params, key)</code>","text":"<p>Applies parameters to devices and updates source states.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>ArrayContainer</code> <p>Container with field arrays</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with simulation objects</p> required <code>params</code> <code>ParameterContainer</code> <p>Container with device parameters</p> required <code>key</code> <code>Array</code> <p>JAX random key for source updates</p> required <p>Returns:</p> Type Description <code>tuple[ArrayContainer, ObjectContainer, dict[str, Any]]</code> <p>A tuple containing: - Updated ArrayContainer with applied device parameters - Updated ObjectContainer with new source states - Dictionary with parameter application info</p> Source code in <code>src/fdtdx/fdtd/initialization.py</code> <pre><code>def apply_params(\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    params: ParameterContainer,\n    key: jax.Array,\n) -&gt; tuple[ArrayContainer, ObjectContainer, dict[str, Any]]:\n    \"\"\"Applies parameters to devices and updates source states.\n\n    Args:\n        arrays: Container with field arrays\n        objects: Container with simulation objects\n        params: Container with device parameters\n        key: JAX random key for source updates\n\n    Returns:\n        A tuple containing:\n            - Updated ArrayContainer with applied device parameters\n            - Updated ObjectContainer with new source states\n            - Dictionary with parameter application info\n    \"\"\"\n    info = {}\n    # apply parameter to devices\n    for device in objects.discrete_devices:\n        cur_material_indices = device.get_expanded_material_mapping(params[device.name])\n        allowed_perm_list = compute_allowed_permittivities(device.material)\n        new_perm_slice = (1.0 / jnp.asarray(allowed_perm_list))[cur_material_indices.astype(jnp.int32)]\n        new_perm_slice = straight_through_estimator(cur_material_indices, new_perm_slice)\n        new_perm = arrays.inv_permittivities.at[*device.grid_slice].set(new_perm_slice)\n        arrays = arrays.at[\"inv_permittivities\"].set(new_perm)\n\n    # apply parameters to continous devices\n    if not objects.all_objects_non_magnetic:\n        for device in objects.continous_devices:\n            cur_material_indices = device.get_expanded_material_mapping(params[device.name])\n            new_perm_slice = (1 - cur_material_indices) * (\n                1 / device.material.start_material.permittivity\n            ) + cur_material_indices * (1 / device.material.end_material.permittivity)\n            new_perm = arrays.inv_permittivities.at[*device.grid_slice].set(new_perm_slice)\n            arrays = arrays.at[\"inv_permittivities\"].set(new_perm)\n\n    # apply random key to sources\n    new_sources = []\n    for source in objects.sources:\n        key, subkey = jax.random.split(key)\n        new_source = source.apply(\n            key=subkey,\n            inv_permittivities=jax.lax.stop_gradient(arrays.inv_permittivities),\n            inv_permeabilities=jax.lax.stop_gradient(arrays.inv_permeabilities),\n        )\n        new_sources.append(new_source)\n    objects = objects.replace_sources(new_sources)\n\n    return arrays, objects, info\n</code></pre>"},{"location":"api/fdtd/#core-fdtd-algorithms","title":"Core FDTD Algorithms","text":"<p>Time-reversal symmetric FDTD implementation with memory-efficient autodiff.</p> <p>Gradient checkpointing FDTD implementation for memory-performance tradeoff when using autodiff. In most use-cases this performs worse than the reversible FDTD.</p> <p>Complete backward FDTD propagation from current state to start time. This can be used to check if the compression of boundary interfaces still lead to a physically accurate backward pass.</p>"},{"location":"api/fdtd/#fdtdx.fdtd.reversible_fdtd","title":"<code>fdtdx.fdtd.reversible_fdtd(arrays, objects, config, key)</code>","text":"<p>Run a memory-efficient differentiable FDTD simulation leveraging time-reversal symmetry.</p> <p>This implementation exploits the time-reversal symmetry of Maxwell's equations to perform backpropagation without storing the electromagnetic fields at each time step. During the backward pass, the fields are reconstructed by running the simulation in reverse, only requiring O(1) memory storage instead of O(T) where T is the number of time steps.</p> <p>The only exception is boundary conditions which break time-reversal symmetry - these are recorded during the forward pass and replayed during backpropagation.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>ArrayContainer</code> <p>Initial state of the simulation containing: - E, H: Electric and magnetic field arrays - inv_permittivities, inv_permeabilities: Material properties - boundary_states: Dictionary of boundary conditions - detector_states: Dictionary of field detectors - recording_state: Optional state for recording field evolution</p> required <code>objects</code> <code>ObjectContainer</code> <p>Collection of physical objects in the simulation (sources, detectors, boundaries, etc.)</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation parameters including: - time_steps_total: Total number of steps to simulate - invertible_optimization: Whether to record boundaries for backprop</p> required <code>key</code> <code>Array</code> <p>JAX PRNGKey for any stochastic operations</p> required <p>Returns:</p> Name Type Description <code>SimulationState</code> <code>SimulationState</code> <p>Tuple containing: - Final time step (int) - ArrayContainer with the final state of all fields and components</p> Notes <p>The implementation uses custom vector-Jacobian products (VJPs) to enable efficient backpropagation through the entire simulation while maintaining numerical stability. This makes it suitable for gradient-based optimization of electromagnetic designs.</p> Source code in <code>src/fdtdx/fdtd/fdtd.py</code> <pre><code>def reversible_fdtd(\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    config: SimulationConfig,\n    key: jax.Array,\n) -&gt; SimulationState:\n    \"\"\"Run a memory-efficient differentiable FDTD simulation leveraging time-reversal symmetry.\n\n    This implementation exploits the time-reversal symmetry of Maxwell's equations to perform\n    backpropagation without storing the electromagnetic fields at each time step. During the\n    backward pass, the fields are reconstructed by running the simulation in reverse, only\n    requiring O(1) memory storage instead of O(T) where T is the number of time steps.\n\n    The only exception is boundary conditions which break time-reversal symmetry - these are\n    recorded during the forward pass and replayed during backpropagation.\n\n    Args:\n        arrays (ArrayContainer): Initial state of the simulation containing:\n            - E, H: Electric and magnetic field arrays\n            - inv_permittivities, inv_permeabilities: Material properties\n            - boundary_states: Dictionary of boundary conditions\n            - detector_states: Dictionary of field detectors\n            - recording_state: Optional state for recording field evolution\n        objects (ObjectContainer): Collection of physical objects in the simulation\n            (sources, detectors, boundaries, etc.)\n        config (SimulationConfig): Simulation parameters including:\n            - time_steps_total: Total number of steps to simulate\n            - invertible_optimization: Whether to record boundaries for backprop\n        key (jax.Array): JAX PRNGKey for any stochastic operations\n\n    Returns:\n        SimulationState: Tuple containing:\n            - Final time step (int)\n            - ArrayContainer with the final state of all fields and components\n\n    Notes:\n        The implementation uses custom vector-Jacobian products (VJPs) to enable\n        efficient backpropagation through the entire simulation while maintaining\n        numerical stability. This makes it suitable for gradient-based optimization\n        of electromagnetic designs.\n    \"\"\"\n    # if arrays.magnetic_conductivity is not None or arrays.electric_conductivity is not None:\n    #     raise Exception(f\"Reversible FDTD does not work with Conductive Materials\")\n    arrays = reset_array_container(\n        arrays,\n        objects,\n    )\n\n    def reversible_fdtd_base(\n        arr: ArrayContainer,\n    ) -&gt; SimulationState:\n        \"\"\"Core implementation of reversible FDTD simulation.\n\n        Performs the main FDTD time-stepping loop using a while loop that respects\n        JAX's functional programming model.\n\n        Args:\n            arr: ArrayContainer with initial field state and material properties\n\n        Returns:\n            SimulationState tuple containing:\n                - Final time step\n                - ArrayContainer with final simulation state\n        \"\"\"\n        state = (jnp.asarray(0, dtype=jnp.int32), arr)\n        state = eqxi.while_loop(\n            max_steps=config.time_steps_total,\n            cond_fun=lambda s: config.time_steps_total &gt; s[0],\n            body_fun=partial(\n                forward,\n                config=config,\n                objects=objects,\n                key=key,\n                record_detectors=True,\n                record_boundaries=config.invertible_optimization,\n                simulate_boundaries=True,\n            ),\n            init_val=state,\n            kind=\"lax\",\n        )\n        return (state[0], state[1])\n\n    @jax.custom_vjp\n    def reversible_fdtd_primal(\n        E: jax.Array,\n        H: jax.Array,\n        inv_permittivities: jax.Array,\n        inv_permeabilities: jax.Array,\n        boundary_states: dict[str, BaseBoundaryState],\n        detector_states: dict[str, DetectorState],\n        recording_state: RecordingState | None,\n    ):\n        arr = ArrayContainer(\n            E=E,\n            H=H,\n            inv_permittivities=inv_permittivities,\n            inv_permeabilities=inv_permeabilities,\n            boundary_states=boundary_states,\n            detector_states=detector_states,\n            recording_state=recording_state,\n            electric_conductivity=arrays.electric_conductivity,\n            magnetic_conductivity=arrays.magnetic_conductivity,\n        )\n        state = reversible_fdtd_base(arr)\n        return (\n            state[0],\n            state[1].E,\n            state[1].H,\n            state[1].inv_permittivities,\n            state[1].inv_permeabilities,\n            state[1].boundary_states,\n            state[1].detector_states,\n            state[1].recording_state,\n        )\n\n    def body_fn(\n        sr_tuple,\n    ):\n        state, cot = sr_tuple\n        state = backward(\n            state=state,\n            config=config,\n            objects=objects,\n            key=key,\n            record_detectors=False,\n            reset_fields=False,\n        )\n        _, update_vjp = jax.vjp(\n            partial(\n                forward_single_args_wrapper,\n                config=config,\n                objects=objects,\n                key=key,\n                record_detectors=True,\n                record_boundaries=False,\n                simulate_boundaries=True,\n            ),\n            state[0],\n            state[1].E,\n            state[1].H,\n            state[1].inv_permittivities,\n            state[1].inv_permeabilities,\n            state[1].boundary_states,\n            state[1].detector_states,\n            state[1].recording_state,\n        )\n\n        cot = update_vjp(cot)\n        return state, cot\n\n    def cond_fun(\n        sr_tuple,\n        start_time_step: int,\n    ):\n        s_k, r_k = sr_tuple\n        del r_k\n        time_step = s_k[0]\n        return time_step &gt;= start_time_step\n\n    def fdtd_bwd(\n        residual,\n        cot,\n    ):\n        \"\"\"Backward pass for reversible FDTD simulation.\n\n        Implements the custom vector-Jacobian product for backpropagation through\n        the FDTD simulation by leveraging time-reversibility.\n\n        Args:\n            residual: Tuple containing the final simulation state including:\n                - Time step\n                - E, H field arrays\n                - Material properties\n                - Boundary and detector states\n                - Recording state\n            cot: Cotangent values for gradient computation\n\n        Returns:\n            Tuple of cotangent values for each input parameter\n        \"\"\"\n        (\n            res_time_step,\n            res_E,\n            res_H,\n            res_inv_permittivities,\n            res_inv_permeabilities,\n            res_boundary_states,\n            res_detector_states,\n            res_recording_state,\n        ) = residual\n\n        s_k = ArrayContainer(\n            E=res_E,\n            H=res_H,\n            inv_permittivities=res_inv_permittivities,\n            inv_permeabilities=res_inv_permeabilities,\n            boundary_states=res_boundary_states,\n            detector_states=res_detector_states,\n            recording_state=res_recording_state,\n            electric_conductivity=arrays.electric_conductivity,\n            magnetic_conductivity=arrays.magnetic_conductivity,\n        )\n\n        _, cot = eqxi.while_loop(\n            cond_fun=partial(cond_fun, start_time_step=0),\n            body_fun=body_fn,\n            init_val=((res_time_step, s_k), cot),\n            kind=\"lax\",\n        )\n        return (\n            None,  # cot[1],\n            None,  # cot[2],\n            cot[3],\n            cot[4],\n            None,  # cot[5]\n            None,  # cot[6],\n            None,  # cot[7],\n        )\n\n    def fdtd_fwd(\n        E: jax.Array,\n        H: jax.Array,\n        inv_permittivities: jax.Array,\n        inv_permeabilities: jax.Array,\n        boundary_states: dict[str, BaseBoundaryState],\n        detector_states: dict[str, DetectorState],\n        recording_state: RecordingState | None,\n    ):\n        \"\"\"Forward pass for reversible FDTD simulation.\n\n        Performs the forward FDTD simulation and prepares residuals for the backward pass.\n\n        Args:\n            E: Electric field array\n            H: Magnetic field array\n            inv_permittivities: Inverse permittivity values\n            inv_permeabilities: Inverse permeability values\n            boundary_states: Dictionary mapping boundary names to their states\n            detector_states: Dictionary mapping detector names to their states\n            recording_state: Optional state for recording field evolution\n\n        Returns:\n            Tuple containing:\n                - Primal outputs (final simulation state)\n                - Residuals for backward pass\n        \"\"\"\n        arr = ArrayContainer(\n            E=E,\n            H=H,\n            inv_permittivities=inv_permittivities,\n            inv_permeabilities=inv_permeabilities,\n            boundary_states=boundary_states,\n            detector_states=detector_states,\n            recording_state=recording_state,\n            electric_conductivity=arrays.electric_conductivity,\n            magnetic_conductivity=arrays.magnetic_conductivity,\n        )\n        s_k = reversible_fdtd_base(arr)\n\n        primal_out = (\n            s_k[0],\n            s_k[1].E,\n            s_k[1].H,\n            s_k[1].inv_permittivities,\n            s_k[1].inv_permeabilities,\n            s_k[1].boundary_states,\n            s_k[1].detector_states,\n            s_k[1].recording_state,  # None\n        )\n        residual = (\n            s_k[0],\n            s_k[1].E,\n            s_k[1].H,\n            s_k[1].inv_permittivities,\n            s_k[1].inv_permeabilities,\n            s_k[1].boundary_states,\n            s_k[1].detector_states,\n            s_k[1].recording_state,\n        )\n        return primal_out, residual\n\n    reversible_fdtd_primal.defvjp(fdtd_fwd, fdtd_bwd)\n\n    (\n        time_step,\n        E,\n        H,\n        inv_permittivities,\n        inv_permeabilities,\n        boundary_states,\n        detector_states,\n        recording_state,\n    ) = reversible_fdtd_primal(\n        E=arrays.E,\n        H=arrays.H,\n        inv_permittivities=arrays.inv_permittivities,\n        inv_permeabilities=arrays.inv_permeabilities,\n        boundary_states=arrays.boundary_states,\n        detector_states=arrays.detector_states,\n        recording_state=arrays.recording_state,\n    )\n    out_arrs = ArrayContainer(\n        E=E,\n        H=H,\n        inv_permittivities=inv_permittivities,\n        inv_permeabilities=inv_permeabilities,\n        boundary_states=boundary_states,\n        detector_states=detector_states,\n        recording_state=recording_state,\n        electric_conductivity=arrays.electric_conductivity,\n        magnetic_conductivity=arrays.magnetic_conductivity,\n    )\n    return time_step, out_arrs\n</code></pre>"},{"location":"api/fdtd/#fdtdx.fdtd.checkpointed_fdtd","title":"<code>fdtdx.fdtd.checkpointed_fdtd(arrays, objects, config, key)</code>","text":"<p>Run an FDTD simulation with gradient checkpointing for memory efficiency.</p> <p>This implementation uses checkpointing to reduce memory usage during backpropagation by only storing the field state at certain intervals and recomputing intermediate states as needed.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>ArrayContainer</code> <p>Initial state of the simulation containing fields and materials</p> required <code>objects</code> <code>ObjectContainer</code> <p>Collection of physical objects in the simulation</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation parameters including checkpointing settings</p> required <code>key</code> <code>Array</code> <p>JAX PRNGKey for any stochastic operations</p> required <p>Returns:</p> Name Type Description <code>SimulationState</code> <code>SimulationState</code> <p>Tuple containing final time step and ArrayContainer with final state</p> Notes <p>The number of checkpoints can be configured through config.gradient_config.num_checkpoints. More checkpoints reduce recomputation but increase memory usage.</p> Source code in <code>src/fdtdx/fdtd/fdtd.py</code> <pre><code>def checkpointed_fdtd(\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    config: SimulationConfig,\n    key: jax.Array,\n) -&gt; SimulationState:\n    \"\"\"Run an FDTD simulation with gradient checkpointing for memory efficiency.\n\n    This implementation uses checkpointing to reduce memory usage during backpropagation\n    by only storing the field state at certain intervals and recomputing intermediate\n    states as needed.\n\n    Args:\n        arrays (ArrayContainer): Initial state of the simulation containing fields and materials\n        objects (ObjectContainer): Collection of physical objects in the simulation\n        config (SimulationConfig): Simulation parameters including checkpointing settings\n        key (jax.Array): JAX PRNGKey for any stochastic operations\n\n    Returns:\n        SimulationState: Tuple containing final time step and ArrayContainer with final state\n\n    Notes:\n        The number of checkpoints can be configured through config.gradient_config.num_checkpoints.\n        More checkpoints reduce recomputation but increase memory usage.\n    \"\"\"\n    arrays = reset_array_container(arrays, objects)\n    state = (jnp.asarray(0, dtype=jnp.int32), arrays)\n    state = eqxi.while_loop(\n        max_steps=config.time_steps_total,\n        cond_fun=lambda s: config.time_steps_total &gt; s[0],\n        body_fun=partial(\n            forward,\n            config=config,\n            objects=objects,\n            key=key,\n            record_detectors=True,\n            record_boundaries=config.invertible_optimization,\n            simulate_boundaries=True,\n        ),\n        init_val=state,\n        kind=\"lax\" if config.only_forward is None else \"checkpointed\",\n        checkpoints=(None if config.gradient_config is None else config.gradient_config.num_checkpoints),\n    )\n\n    return state\n</code></pre>"},{"location":"api/fdtd/#fdtdx.fdtd.full_backward","title":"<code>fdtdx.fdtd.full_backward(state, objects, config, key, record_detectors, reset_fields, start_time_step=0)</code>","text":"<p>Perform full backward FDTD propagation from current state to start time.</p> <p>Uses a while loop to repeatedly call backward() until reaching start_time_step. Leverages time-reversibility of Maxwell's equations.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>SimulationState</code> <p>Current simulation state tuple (time_step, arrays)</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with simulation objects (sources, detectors, etc)</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration parameters</p> required <code>key</code> <code>Array</code> <p>JAX PRNG key for random operations</p> required <code>record_detectors</code> <code>bool</code> <p>Whether to record detector states</p> required <code>reset_fields</code> <code>bool</code> <p>Whether to reset fields after each step</p> required <code>start_time_step</code> <code>int</code> <p>Time step to propagate back to (default: 0)</p> <code>0</code> <p>Returns:</p> Name Type Description <code>SimulationState</code> <code>SimulationState</code> <p>Final state after backward propagation</p> Source code in <code>src/fdtdx/fdtd/backward.py</code> <pre><code>def full_backward(\n    state: SimulationState,\n    objects: ObjectContainer,\n    config: SimulationConfig,\n    key: jax.Array,\n    record_detectors: bool,\n    reset_fields: bool,\n    start_time_step: int = 0,\n) -&gt; SimulationState:\n    \"\"\"Perform full backward FDTD propagation from current state to start time.\n\n    Uses a while loop to repeatedly call backward() until reaching start_time_step.\n    Leverages time-reversibility of Maxwell's equations.\n\n    Args:\n        state: Current simulation state tuple (time_step, arrays)\n        objects: Container with simulation objects (sources, detectors, etc)\n        config: Simulation configuration parameters\n        key: JAX PRNG key for random operations\n        record_detectors: Whether to record detector states\n        reset_fields: Whether to reset fields after each step\n        start_time_step: Time step to propagate back to (default: 0)\n\n    Returns:\n        SimulationState: Final state after backward propagation\n    \"\"\"\n    s0 = eqxi.while_loop(\n        cond_fun=partial(cond_fn, start_time_step=start_time_step),\n        body_fun=partial(\n            backward,\n            config=config,\n            objects=objects,\n            key=key,\n            record_detectors=record_detectors,\n            reset_fields=reset_fields,\n        ),\n        init_val=state,\n        kind=\"lax\",\n    )\n    return s0\n</code></pre>"},{"location":"api/fdtd/#custom-time-evolution","title":"Custom Time Evolution","text":"<p>Customizable FDTD implementation for partial time evolution and analysis. If used smartly, this can make simulation a bit faster, but in most use-cases this is not necessary.</p>"},{"location":"api/fdtd/#fdtdx.fdtd.custom_fdtd_forward","title":"<code>fdtdx.fdtd.custom_fdtd_forward(arrays, objects, config, key, reset_container, record_detectors, start_time, end_time)</code>","text":"<p>Run a customizable forward FDTD simulation between specified time steps.</p> <p>This function provides fine-grained control over the simulation execution, allowing partial time evolution and customization of recording behavior.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>ArrayContainer</code> <p>Initial state of the simulation</p> required <code>objects</code> <code>ObjectContainer</code> <p>Collection of physical objects</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation parameters</p> required <code>key</code> <code>Array</code> <p>JAX PRNGKey for stochastic operations</p> required <code>reset_container</code> <code>bool</code> <p>Whether to reset the array container before starting</p> required <code>record_detectors</code> <code>bool</code> <p>Whether to record detector readings</p> required <code>start_time</code> <code>int | Array</code> <p>Time step to start from</p> required <code>end_time</code> <code>int | Array</code> <p>Time step to end at</p> required <p>Returns:</p> Name Type Description <code>SimulationState</code> <code>SimulationState</code> <p>Tuple containing final time step and ArrayContainer with final state</p> Notes <p>This function is useful for implementing custom simulation strategies or running partial simulations for analysis purposes.</p> Source code in <code>src/fdtdx/fdtd/fdtd.py</code> <pre><code>def custom_fdtd_forward(\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    config: SimulationConfig,\n    key: jax.Array,\n    reset_container: bool,\n    record_detectors: bool,\n    start_time: int | jax.Array,\n    end_time: int | jax.Array,\n) -&gt; SimulationState:\n    \"\"\"Run a customizable forward FDTD simulation between specified time steps.\n\n    This function provides fine-grained control over the simulation execution,\n    allowing partial time evolution and customization of recording behavior.\n\n    Args:\n        arrays (ArrayContainer): Initial state of the simulation\n        objects (ObjectContainer): Collection of physical objects\n        config (SimulationConfig): Simulation parameters\n        key (jax.Array): JAX PRNGKey for stochastic operations\n        reset_container (bool): Whether to reset the array container before starting\n        record_detectors (bool): Whether to record detector readings\n        start_time (int | jax.Array): Time step to start from\n        end_time (int | jax.Array): Time step to end at\n\n    Returns:\n        SimulationState: Tuple containing final time step and ArrayContainer with final state\n\n    Notes:\n        This function is useful for implementing custom simulation strategies or\n        running partial simulations for analysis purposes.\n    \"\"\"\n    if reset_container:\n        arrays = reset_array_container(arrays, objects)\n    state = (jnp.asarray(start_time, dtype=jnp.int32), arrays)\n    state = eqxi.while_loop(\n        max_steps=config.time_steps_total,\n        cond_fun=lambda s: end_time &gt; s[0],\n        body_fun=partial(\n            forward,\n            config=config,\n            objects=objects,\n            key=key,\n            record_detectors=record_detectors,\n            record_boundaries=False,\n            simulate_boundaries=True,\n        ),\n        init_val=state,\n        kind=\"lax\",\n        checkpoints=None,\n    )\n\n    return state\n</code></pre>"},{"location":"api/fdtd/#python-objects-used-for-fdtd-simulation","title":"Python Objects used for FDTD simulation","text":"<p>Container holding the electric/magnetic fields as well as permittivity/permeability arrays for simulation</p> <p>Container holding all the objects in a simulation scene</p> <p>Dictionary holding the parameters for every device in the simulation</p> <p>Simulation state returned by the FDTD simulations. This is a tuple of the simulation time step and an array container.</p>"},{"location":"api/fdtd/#fdtdx.fdtd.ArrayContainer","title":"<code>fdtdx.fdtd.ArrayContainer</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Container for simulation field arrays and states.</p> <p>This class holds the electromagnetic field arrays and various state information needed during FDTD simulation. It includes the E and H fields, material properties, and states for boundaries, detectors and recordings.</p> <p>Attributes:</p> Name Type Description <code>E</code> <code>Array</code> <p>Electric field array.</p> <code>H</code> <code>Array</code> <p>Magnetic field array.</p> <code>inv_permittivities</code> <code>Array</code> <p>Inverse permittivity values array.</p> <code>inv_permeabilities</code> <code>Array | float</code> <p>Inverse permeability values array.</p> <code>boundary_states</code> <code>dict[str, BaseBoundaryState]</code> <p>Dictionary mapping boundary names to their states.</p> <code>detector_states</code> <code>dict[str, DetectorState]</code> <p>Dictionary mapping detector names to their states.</p> <code>recording_state</code> <code>RecordingState | None</code> <p>Optional state for recording simulation data.</p> Source code in <code>src/fdtdx/fdtd/container.py</code> <pre><code>@extended_autoinit\nclass ArrayContainer(ExtendedTreeClass):\n    \"\"\"Container for simulation field arrays and states.\n\n    This class holds the electromagnetic field arrays and various state information\n    needed during FDTD simulation. It includes the E and H fields, material properties,\n    and states for boundaries, detectors and recordings.\n\n    Attributes:\n        E: Electric field array.\n        H: Magnetic field array.\n        inv_permittivities: Inverse permittivity values array.\n        inv_permeabilities: Inverse permeability values array.\n        boundary_states: Dictionary mapping boundary names to their states.\n        detector_states: Dictionary mapping detector names to their states.\n        recording_state: Optional state for recording simulation data.\n    \"\"\"\n\n    E: jax.Array\n    H: jax.Array\n    inv_permittivities: jax.Array\n    inv_permeabilities: jax.Array | float\n    boundary_states: dict[str, BaseBoundaryState]\n    detector_states: dict[str, DetectorState]\n    recording_state: RecordingState | None\n    electric_conductivity: jax.Array | None = None\n    magnetic_conductivity: jax.Array | None = None\n</code></pre>"},{"location":"api/fdtd/#fdtdx.fdtd.ObjectContainer","title":"<code>fdtdx.fdtd.ObjectContainer</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Container for managing simulation objects and their relationships.</p> <p>This class provides a structured way to organize and access different types of simulation objects like sources, detectors, PML/periodic boundaries and devices. It maintains object lists and provides filtered access to specific object types.</p> <p>Attributes:</p> Name Type Description <code>object_list</code> <code>list[SimulationObject]</code> <p>List of all simulation objects in the container.</p> <code>volume_idx</code> <code>int</code> <p>Index of the volume object in the object list.</p> Source code in <code>src/fdtdx/fdtd/container.py</code> <pre><code>@extended_autoinit\nclass ObjectContainer(ExtendedTreeClass):\n    \"\"\"Container for managing simulation objects and their relationships.\n\n    This class provides a structured way to organize and access different types of simulation\n    objects like sources, detectors, PML/periodic boundaries and devices. It maintains object lists\n    and provides filtered access to specific object types.\n\n    Attributes:\n        object_list: List of all simulation objects in the container.\n        volume_idx: Index of the volume object in the object list.\n    \"\"\"\n\n    object_list: list[SimulationObject]\n    volume_idx: int\n\n    @property\n    def volume(self) -&gt; SimulationObject:\n        return self.object_list[self.volume_idx]\n\n    @property\n    def objects(self) -&gt; list[SimulationObject]:\n        return self.object_list\n\n    @property\n    def static_material_objects(self) -&gt; list[StaticMaterialObject]:\n        return [o for o in self.objects if isinstance(o, StaticMaterialObject)]\n\n    @property\n    def sources(self) -&gt; list[Source]:\n        return [o for o in self.objects if isinstance(o, Source)]\n\n    @property\n    def devices(self) -&gt; list[BaseDevice]:\n        return [o for o in self.objects if isinstance(o, BaseDevice)]\n\n    @property\n    def discrete_devices(self) -&gt; list[DiscreteDevice]:\n        return [o for o in self.objects if isinstance(o, DiscreteDevice)]\n\n    @property\n    def continous_devices(self) -&gt; list[ContinuousDevice]:\n        return [o for o in self.objects if isinstance(o, ContinuousDevice)]\n\n    @property\n    def detectors(self) -&gt; list[Detector]:\n        return [o for o in self.objects if isinstance(o, Detector)]\n\n    @property\n    def forward_detectors(self) -&gt; list[Detector]:\n        return [o for o in self.detectors if not o.inverse]\n\n    @property\n    def backward_detectors(self) -&gt; list[Detector]:\n        return [o for o in self.detectors if o.inverse]\n\n    @property\n    def pml_objects(self) -&gt; list[PerfectlyMatchedLayer]:\n        return [o for o in self.objects if isinstance(o, PerfectlyMatchedLayer)]\n\n    @property\n    def periodic_objects(self) -&gt; list[PeriodicBoundary]:\n        return [o for o in self.objects if isinstance(o, PeriodicBoundary)]\n\n    @property\n    def boundary_objects(self) -&gt; list[BaseBoundary]:\n        return [o for o in self.objects if isinstance(o, (PerfectlyMatchedLayer, PeriodicBoundary))]\n\n    @property\n    def all_objects_non_magnetic(self) -&gt; bool:\n        def _fn(m: Material):\n            return not m.is_magnetic\n\n        return self._is_material_fn_true_for_all(_fn)\n\n    @property\n    def all_objects_non_electrically_conductive(self) -&gt; bool:\n        def _fn(m: Material):\n            return not m.is_electrically_conductive\n\n        return self._is_material_fn_true_for_all(_fn)\n\n    @property\n    def all_objects_non_magnetically_conductive(self) -&gt; bool:\n        def _fn(m: Material):\n            return not m.is_magnetically_conductive\n\n        return self._is_material_fn_true_for_all(_fn)\n\n    def _is_material_fn_true_for_all(\n        self,\n        fn: Callable[[Material], bool],\n    ) -&gt; bool:\n        for o in self.objects:\n            if not isinstance(o, StaticMaterialObject) and not isinstance(o, BaseDevice):\n                continue\n            if isinstance(o.material, Material):\n                if not fn(o.material):\n                    return False\n            elif isinstance(o.material, dict):\n                for v in o.material.values():\n                    if not fn(v):\n                        return False\n            else:\n                if fn(o.material.start_material):\n                    return False\n                if fn(o.material.end_material):\n                    return False\n        return True\n\n    def __iter__(self):\n        return iter(self.object_list)\n\n    def __getitem__(\n        self,\n        key: str,\n    ) -&gt; SimulationObject:\n        for o in self.objects:\n            if o.name == key:\n                return o\n        raise ValueError(f\"Key {key} does not exist in object list: {[o.name for o in self.objects]}\")\n\n    def replace_sources(\n        self,\n        sources: list[Source],\n    ) -&gt; Self:\n        new_objects = [o for o in self.objects if o not in self.sources] + sources\n        self = self.aset(\"object_list\", new_objects)\n        return self\n</code></pre>"},{"location":"api/fdtd/#fdtdx.fdtd.ParameterContainer","title":"<code>fdtdx.fdtd.ParameterContainer = dict[str, dict[str, jax.Array] | jax.Array]</code>  <code>module-attribute</code>","text":""},{"location":"api/fdtd/#fdtdx.fdtd.SimulationState","title":"<code>fdtdx.fdtd.SimulationState = tuple[jax.Array, ArrayContainer]</code>  <code>module-attribute</code>","text":""},{"location":"api/interfaces/","title":"Interfaces","text":""},{"location":"api/interfaces/#_1","title":"Interfaces","text":""},{"location":"api/interfaces/#interface-compression","title":"Interface Compression","text":"<p>This API can be used for automatic differentiation (autodiff) with time-reversibility, which is more memory efficient than other approaches.  Additionally, some basic compression modules are implemented to reduce the memory footprint even further. However, they should be used with care since too much compression can reduce the gradient accuracy.</p> <p>A recorder object for recording the interfaces between simulation volume and PML boundary during the forward simulation</p>"},{"location":"api/interfaces/#fdtdx.interfaces.Recorder","title":"<code>fdtdx.interfaces.Recorder</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Records and compresses simulation data over time using a sequence of processing modules.</p> <p>The Recorder manages a pipeline of modules that process simulation data at each timestep. It supports both compression modules that reduce data size and time filters that control when data is recorded. The recorder handles initialization, compression and decompression of simulation data through its module pipeline.</p> <p>Attributes:</p> Name Type Description <code>modules</code> <code>Sequence[CompressionModule | TimeStepFilter]</code> <p>Sequence of processing modules to apply to the simulation data. Can be either CompressionModule for data reduction or TimeStepFilter for controlling recording frequency.</p> Source code in <code>src/fdtdx/interfaces/recorder.py</code> <pre><code>@extended_autoinit\nclass Recorder(ExtendedTreeClass):\n    \"\"\"Records and compresses simulation data over time using a sequence of processing modules.\n\n    The Recorder manages a pipeline of modules that process simulation data at each timestep.\n    It supports both compression modules that reduce data size and time filters that control\n    when data is recorded. The recorder handles initialization, compression and decompression\n    of simulation data through its module pipeline.\n\n    Attributes:\n        modules: Sequence of processing modules to apply to the simulation data.\n            Can be either CompressionModule for data reduction or TimeStepFilter\n            for controlling recording frequency.\n    \"\"\"\n\n    modules: Sequence[CompressionModule | TimeStepFilter]\n    _input_shape_dtypes: dict[str, jax.ShapeDtypeStruct] = frozen_private_field(default=None)  # type:ignore\n    _output_shape_dtypes: dict[str, jax.ShapeDtypeStruct] = frozen_private_field(default=None)  # type:ignore\n    _max_time_steps: int = frozen_private_field(default=-1)\n    _latent_array_size: int = frozen_private_field(default=-1, init=False)\n\n    def init_state(\n        self: Self,\n        input_shape_dtypes: dict[str, jax.ShapeDtypeStruct],\n        max_time_steps: int,\n        backend: BackendOption,\n    ) -&gt; tuple[Self, RecordingState]:\n        self = self.aset(\"_max_time_steps\", max_time_steps)\n        self = self.aset(\"_input_shape_dtypes\", input_shape_dtypes)\n\n        latent_arr_size, out_shapes = max_time_steps, input_shape_dtypes\n        state_sizes: dict[str, jax.ShapeDtypeStruct] = {}\n        new_modules = []\n        for m in self.modules:\n            if isinstance(m, CompressionModule):\n                m, out_shapes, state_shapes = m.init_shapes(out_shapes)\n            else:\n                m, latent_arr_size, out_shapes, state_shapes = m.init_shapes(out_shapes, latent_arr_size)\n            state_sizes.update(state_shapes)\n            new_modules.append(m)\n\n        self = self.aset(\"modules\", new_modules)\n        self = self.aset(\"_output_shape_dtypes\", out_shapes)\n        self = self.aset(\"_latent_array_size\", latent_arr_size)\n\n        expanded_out_shapes = {\n            k: jax.ShapeDtypeStruct(\n                shape=(self._latent_array_size, *v.shape),\n                dtype=v.dtype,\n            )\n            for k, v in self._output_shape_dtypes.items()\n        }\n        state = init_recording_state(\n            data_shape_dtypes=expanded_out_shapes,\n            state_shape_dtypes=state_sizes,\n            backend=backend,\n        )\n        return self, state\n\n    def compress(\n        self,\n        values: dict[str, jax.Array],\n        state: RecordingState,\n        time_step: jax.Array,\n        key: jax.Array,\n    ) -&gt; RecordingState:\n        check_shape_dtype(values, self._input_shape_dtypes)\n        latent_idx = time_step\n\n        def helper_fn(m, values, state, latent_idx, key):\n            if isinstance(m, CompressionModule):\n                values, state = m.compress(values, state, key=key)\n            elif isinstance(m, TimeStepFilter):\n                values, state = m.compress(values, state, latent_idx, key=key)\n                latent_idx = m.time_to_array_index(latent_idx)\n            else:\n                raise Exception(f\"Invalid module: {m}\")\n            check_shape_dtype(values, m._output_shape_dtypes)\n            return values, state, latent_idx\n\n        def dummy_fn(m, values, state, latent_idx, key):\n            del key\n            # Only create zero arrays for keys that exist in the input values\n            # This ensures structure matching with helper_fn for periodic boundaries\n            values = {k: jnp.zeros(v.shape, v.dtype) for k, v in m._output_shape_dtypes.items() if k in values}\n            check_shape_dtype(values, m._output_shape_dtypes)\n            return values, state, latent_idx\n\n        for m in self.modules:\n            key, subkey = jax.random.split(key)\n            values, state, latent_idx = jax.lax.cond(\n                latent_idx == -1, dummy_fn, helper_fn, m, values, state, latent_idx, subkey\n            )\n            check_shape_dtype(values, m._output_shape_dtypes)\n\n        def update_state_fn(state, values, latent_idx):\n            # Only update state data for keys that exist in values\n            for k in state.data.keys():\n                if k in values:\n                    state.data[k] = state.data[k].at[latent_idx].set(values[k])\n            return state\n\n        def update_dummy_fn(state, values, latent_idx):\n            del values, latent_idx\n            return state\n\n        state = jax.lax.cond(latent_idx == -1, update_dummy_fn, update_state_fn, state, values, latent_idx)\n\n        return state\n\n    def decompress(\n        self,\n        state: RecordingState,\n        time_step: jax.Array,\n        key: jax.Array,\n    ) -&gt; tuple[\n        dict[str, jax.Array],\n        RecordingState,\n    ]:\n        # gather indices necessary to reconstruct\n        time_filters = [m for m in self.modules if isinstance(m, TimeStepFilter)]\n        indices: list[jax.Array] = [jnp.asarray([time_step])]\n        time_indices: list[jax.Array] = []\n\n        for tf in time_filters:\n            cur_time_indices = indices[-1].flatten()\n            cur_indices = jnp.asarray([tf.indices_to_decompress(idx) for idx in cur_time_indices])\n            time_indices.append(cur_time_indices)\n            indices.append(cur_indices)\n\n        def reconstruction_iteration(\n            m: CompressionModule | TimeStepFilter,\n            state: RecordingState,\n            key: jax.Array,\n            latent: list[dict[str, jax.Array]],\n            cur_tf_idx: int,\n        ) -&gt; tuple[\n            int,\n            list[dict[str, jax.Array]],\n            RecordingState,\n        ]:\n            if isinstance(m, CompressionModule):\n                latent = [m.decompress(v, state, key=key) for v in latent]\n            else:\n                num_time_idx = indices[cur_tf_idx].shape[0]\n                num_arr_idx = indices[cur_tf_idx].shape[1]\n                next_latent = []\n                for cur_idx in range(0, num_time_idx):\n                    # for idx in range(start_idx, start_idx + num_idx):\n                    start_idx = cur_idx * num_arr_idx\n                    cur_v = [latent[i] for i in range(start_idx, start_idx + num_arr_idx)]\n                    arr_indices = indices[cur_tf_idx][cur_idx]\n                    time_idx = time_indices[cur_tf_idx - 1][cur_idx]\n                    next_v = m.decompress(\n                        values=cur_v,\n                        state=state,\n                        arr_indices=arr_indices,\n                        time_idx=time_idx,\n                        key=key,\n                    )\n                    next_latent.append(next_v)\n                latent = next_latent\n                cur_tf_idx = cur_tf_idx - 1\n            for v in latent:\n                check_shape_dtype(v, m._input_shape_dtypes)\n            return cur_tf_idx, latent, state\n\n        def bottom_up_reconstruction(state: RecordingState, key):\n            cur_tf_idx = len(time_filters)\n            latent: list[dict[str, jax.Array]] = [\n                {k: jnp.take(v, indices=idx.reshape(1), axis=0).squeeze(axis=0) for k, v in state.data.items()}\n                for idx in indices[cur_tf_idx].flatten()\n            ]\n            for m in self.modules[::-1]:\n                key, subkey = jax.random.split(key)\n                cur_tf_idx, latent, state = reconstruction_iteration(\n                    m=m,\n                    state=state,\n                    key=subkey,\n                    latent=latent,\n                    cur_tf_idx=cur_tf_idx,\n                )\n            return latent, state\n\n        values, state = bottom_up_reconstruction(state, key)\n\n        if len(values) != 1:\n            raise Exception(\"This should never happen\")\n        return values[0], state\n</code></pre>"},{"location":"api/interfaces/#compression-modules","title":"Compression Modules","text":"<p>Compression module which only records every k time steps during the forward simulation. For reconstruction a linear interpolation between the recorded time steps is performed.</p> <p>Compression module to save the interfaces at a lower datatype resolution. From experience, in most applications saving the interfaces in jnp.float16 or jnp.float8_e4m3fnuz is sufficient.</p>"},{"location":"api/interfaces/#fdtdx.interfaces.LinearReconstructEveryK","title":"<code>fdtdx.interfaces.LinearReconstructEveryK</code>","text":"<p>               Bases: <code>TimeStepFilter</code></p> <p>Time step filter that performs linear reconstruction between sampled steps.</p> <p>This filter saves field values every k time steps and uses linear interpolation to reconstruct values at intermediate time steps.</p> <p>Attributes:</p> Name Type Description <code>k</code> <code>int</code> <p>Number of time steps between saved values.</p> <code>start_recording_after</code> <code>int</code> <p>Time step to start recording from.</p> <code>_save_time_steps</code> <code>Array</code> <p>Array of time steps that are saved.</p> <code>_time_to_arr_idx</code> <code>Array</code> <p>Mapping from time steps to array indices.</p> Source code in <code>src/fdtdx/interfaces/time_filter.py</code> <pre><code>@extended_autoinit\nclass LinearReconstructEveryK(TimeStepFilter):\n    \"\"\"Time step filter that performs linear reconstruction between sampled steps.\n\n    This filter saves field values every k time steps and uses linear interpolation\n    to reconstruct values at intermediate time steps.\n\n    Attributes:\n        k: Number of time steps between saved values.\n        start_recording_after: Time step to start recording from.\n        _save_time_steps: Array of time steps that are saved.\n        _time_to_arr_idx: Mapping from time steps to array indices.\n    \"\"\"\n\n    k: int = frozen_field()\n    start_recording_after: int = 0\n    _save_time_steps: jax.Array = frozen_private_field(default=None)  # type: ignore\n    _time_to_arr_idx: jax.Array = frozen_private_field(default=None)  # type: ignore\n\n    def init_shapes(\n        self,\n        input_shape_dtypes: dict[str, jax.ShapeDtypeStruct],\n        time_steps_max: int,  # maximum number of time steps\n    ) -&gt; tuple[\n        Self,\n        int,\n        dict[str, jax.ShapeDtypeStruct],  # data\n        dict[str, jax.ShapeDtypeStruct],  # state shapes\n    ]:\n        self = self.aset(\"_time_steps_max\", time_steps_max)\n        self = self.aset(\"_input_shape_dtypes\", input_shape_dtypes)\n        self = self.aset(\"_output_shape_dtypes\", input_shape_dtypes)\n\n        # init list of all time steps to save\n        all_time_steps = jnp.arange(self.start_recording_after, self._time_steps_max, self.k).tolist()\n        if all_time_steps[-1] != self._time_steps_max - 1:\n            all_time_steps.append(self._time_steps_max - 1)\n\n        self = self.aset(\"_save_time_steps\", jnp.asarray(all_time_steps, dtype=jnp.int32))\n        self = self.aset(\"_array_size\", len(all_time_steps))\n\n        # mapping between time steps and array indices\n        index_tmp = jnp.arange(0, self._array_size, dtype=jnp.int32)\n        time_indices = jnp.zeros(shape=(self._time_steps_max,), dtype=jnp.int32)\n        time_indices = time_indices.at[self._save_time_steps].set(index_tmp)\n        for _ in range(self.k - 1):\n            rolled = jnp.roll(time_indices, 1)\n            time_indices = jnp.where(\n                time_indices == 0,\n                rolled,\n                time_indices,\n            )\n            time_indices = time_indices.at[: self.k].set(0)\n        self = self.aset(\"_time_to_arr_idx\", time_indices)\n        return self, self._array_size, input_shape_dtypes, {}\n\n    def time_to_array_index(\n        self,\n        time_idx: int,  # scalar\n    ) -&gt; int:  # scalar, array index if not filtered, else -1\n        result = jax.lax.cond(\n            jnp.any(time_idx == self._save_time_steps),\n            lambda: self._time_to_arr_idx[time_idx],\n            lambda: jnp.asarray(-1, dtype=jnp.int32),\n        )\n        return result\n\n    def indices_to_decompress(\n        self,\n        time_idx: jax.Array,  # scalar\n    ) -&gt; jax.Array:  # 1d-list of array indices necessary to reconstruct\n        arr_idx = self._time_to_arr_idx[time_idx]\n        result = jnp.asarray([arr_idx, arr_idx + 1], dtype=jnp.int32)\n        return result\n\n    def compress(\n        self,\n        values: dict[str, jax.Array],\n        state: RecordingState,\n        time_idx: jax.Array,  # scalar\n        key: jax.Array,\n    ) -&gt; tuple[\n        dict[str, jax.Array],\n        RecordingState,  # updated recording state\n    ]:\n        del time_idx, key\n        return values, state\n\n    def decompress(\n        self,\n        values: list[dict[str, jax.Array]],  # array values requested above\n        state: RecordingState,\n        arr_indices: jax.Array,\n        time_idx: jax.Array,  # scalar\n        key: jax.Array,\n    ) -&gt; dict[str, jax.Array]:  # reconstructed value\n        del key, state\n\n        def value_was_saved():\n            return values[0]\n\n        def linear_reconstruct():\n            arr_idx = arr_indices[0]\n\n            prev_save_time = index_1d_array(self._time_to_arr_idx, arr_idx)\n            next_save_time = index_1d_array(self._time_to_arr_idx, arr_idx + 1)\n            interp_factor = (time_idx - prev_save_time) / (next_save_time - prev_save_time)\n\n            prev_vals, next_vals = values[0], values[1]\n            res = {}\n            for k, prev in prev_vals.items():\n                next = next_vals[k]\n                interp = prev + interp_factor.astype(next.dtype) * (next - prev)\n                res[k] = interp\n            return res\n\n        result = jax.lax.cond(\n            jnp.any(time_idx == self._save_time_steps),\n            value_was_saved,\n            linear_reconstruct,\n        )\n        return result\n</code></pre>"},{"location":"api/interfaces/#fdtdx.interfaces.DtypeConversion","title":"<code>fdtdx.interfaces.DtypeConversion</code>","text":"<p>               Bases: <code>CompressionModule</code></p> <p>Compression module that converts data types of field values.</p> <p>This module changes the data type of field values while preserving their shape, useful for reducing memory usage or meeting precision requirements.</p> <p>Attributes:</p> Name Type Description <code>dtype</code> <code>dtype</code> <p>Target data type for conversion.</p> <code>exclude_filter</code> <code>Sequence[str]</code> <p>List of field names to exclude from conversion.</p> Source code in <code>src/fdtdx/interfaces/modules.py</code> <pre><code>@extended_autoinit\nclass DtypeConversion(CompressionModule):\n    \"\"\"Compression module that converts data types of field values.\n\n    This module changes the data type of field values while preserving their shape,\n    useful for reducing memory usage or meeting precision requirements.\n\n    Attributes:\n        dtype: Target data type for conversion.\n        exclude_filter: List of field names to exclude from conversion.\n    \"\"\"\n\n    dtype: jnp.dtype = frozen_field(kind=\"KW_ONLY\")  # type: ignore\n    exclude_filter: Sequence[str] = frozen_field(default=tuple([]), kind=\"KW_ONLY\")\n\n    def init_shapes(\n        self,\n        input_shape_dtypes: dict[str, jax.ShapeDtypeStruct],\n    ) -&gt; tuple[\n        Self,\n        dict[str, jax.ShapeDtypeStruct],  # data\n        dict[str, jax.ShapeDtypeStruct],  # state shapes/dtypes\n    ]:\n        self = self.aset(\"_input_shape_dtypes\", input_shape_dtypes)\n        exclude = [] if self.exclude_filter is None else self.exclude_filter\n        out_shape_dtypes = {\n            k: (jax.ShapeDtypeStruct(v.shape, self.dtype) if not any(e in k for e in exclude) else v)\n            for k, v in input_shape_dtypes.items()\n        }\n        self = self.aset(\"_output_shape_dtypes\", out_shape_dtypes)\n        return self, self._output_shape_dtypes, {}\n\n    def compress(\n        self,\n        values: dict[str, jax.Array],\n        state: RecordingState,\n        key: jax.Array,\n    ) -&gt; tuple[\n        dict[str, jax.Array],\n        RecordingState,\n    ]:\n        del key\n        out_vals = {\n            k: (v.astype(self.dtype) if not any(e in k for e in self.exclude_filter) else v) for k, v in values.items()\n        }\n        return out_vals, state\n\n    def decompress(\n        self,\n        values: dict[str, jax.Array],\n        state: RecordingState,\n        key: jax.Array,\n    ) -&gt; dict[str, jax.Array]:\n        del key, state\n        out_vals = {k: v.astype(self._input_shape_dtypes[k].dtype) for k, v in values.items()}\n        return out_vals\n</code></pre>"},{"location":"api/materials/","title":"Material","text":""},{"location":"api/materials/#fdtdx.materials.Material","title":"<code>fdtdx.materials.Material</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Represents an electromagnetic material with specific electrical and magnetic properties.</p> <p>This class stores the fundamental electromagnetic properties of a material for use in electromagnetic simulations.</p> <p>Parameters:</p> Name Type Description Default <code>permittivity</code> <code>float</code> <p>The relative permittivity (dielectric constant) of the material, which describes how the electric field is affected by the material. Higher values indicate greater electric polarization in response to an applied electric field.</p> required <code>permeability</code> <code>float</code> <p>The relative permeability of the material, which describes how the magnetic field is affected by the material. Higher values indicate greater magnetic response to an applied magnetic field. Defaults to 1.0 (non-magnetic material).</p> required <code>electric_conductivity</code> <code>float</code> <p>The electrical conductivity of the material in siemens per meter (S/m), which describes how easily electric current can flow through it. Higher values indicate materials that conduct electricity more easily. Defaults to 0.0 (perfect insulator).</p> required <code>magnetic_conductivity</code> <code>float</code> <p>The magnetic conductivity, or magnetic loss of the material. This is an artificial parameter for numerical applications and does not represent an actual physical unit, even though often described in Ohm/m. The naming can be misleading, because it does not actually describe a conductivity, but rather an \"equivalent magnetic loss parameter\". Defaults to 0.0.</p> required Source code in <code>src/fdtdx/materials.py</code> <pre><code>@extended_autoinit\nclass Material(ExtendedTreeClass):\n    \"\"\"\n    Represents an electromagnetic material with specific electrical and magnetic properties.\n\n    This class stores the fundamental electromagnetic properties of a material for use\n    in electromagnetic simulations.\n\n    Args:\n        permittivity (float): The relative permittivity (dielectric constant) of the material,\n            which describes how the electric field is affected by the material. Higher values\n            indicate greater electric polarization in response to an applied electric field.\n\n        permeability (float, optional): The relative permeability of the material, which\n            describes how the magnetic field is affected by the material. Higher values\n            indicate greater magnetic response to an applied magnetic field.\n            Defaults to 1.0 (non-magnetic material).\n\n        electric_conductivity (float, optional): The electrical conductivity of the material in siemens\n            per meter (S/m), which describes how easily electric current can flow through it.\n            Higher values indicate materials that conduct electricity more easily.\n            Defaults to 0.0 (perfect insulator).\n\n        magnetic_conductivity (float, optional): The magnetic conductivity, or magnetic loss of the material.\n            This is an artificial parameter for numerical applications and does not represent an actual physical unit,\n            even though often described in Ohm/m. The naming can be misleading, because it does not actually describe\n            a conductivity, but rather an \"equivalent magnetic loss parameter\".\n            Defaults to 0.0.\n    \"\"\"\n\n    permittivity: float\n    permeability: float = 1.0\n    electric_conductivity: float = 0.0\n    magnetic_conductivity: float = 0.0\n\n    @property\n    def is_magnetic(self) -&gt; bool:\n        if isinstance(self.permeability, complex):\n            return True\n        return not math.isclose(self.permeability, 1.0)\n\n    @property\n    def is_electrically_conductive(self) -&gt; bool:\n        return not math.isclose(self.electric_conductivity, 0.0)\n\n    @property\n    def is_magnetically_conductive(self) -&gt; bool:\n        return not math.isclose(self.magnetic_conductivity, 0.0)\n</code></pre>"},{"location":"api/typing/","title":"Typing","text":""},{"location":"api/typing/#_1","title":"Typing","text":""},{"location":"api/typing/#shape-types","title":"Shape Types","text":""},{"location":"api/typing/#fdtdx.typing.RealShape3D","title":"<code>fdtdx.typing.RealShape3D = tuple[float, float, float]</code>  <code>module-attribute</code>","text":"<p>3D shape with real-valued (physical) dimensions in meters.</p>"},{"location":"api/typing/#fdtdx.typing.PartialRealShape3D","title":"<code>fdtdx.typing.PartialRealShape3D = tuple[OptionalAxisSize, OptionalAxisSize, OptionalAxisSize]</code>  <code>module-attribute</code>","text":"<p>Partial 3D shape where some physical dimensions may be undefined (None).</p>"},{"location":"api/typing/#fdtdx.typing.GridShape3D","title":"<code>fdtdx.typing.GridShape3D = tuple[int, int, int]</code>  <code>module-attribute</code>","text":"<p>3D shape with integer dimensions in grid points.</p>"},{"location":"api/typing/#fdtdx.typing.PartialGridShape3D","title":"<code>fdtdx.typing.PartialGridShape3D = tuple[OptionalGridAxisSize, OptionalGridAxisSize, OptionalGridAxisSize]</code>  <code>module-attribute</code>","text":"<p>Partial 3D grid shape where some dimensions may be undefined (None).</p>"},{"location":"api/typing/#backed","title":"Backed","text":""},{"location":"api/typing/#fdtdx.typing.BackendOption","title":"<code>fdtdx.typing.BackendOption = Literal['gpu', 'tpu', 'cpu', 'METAL']</code>  <code>module-attribute</code>","text":"<p>Backend options for JAX. Can be either gpu, tpu, cpu or METAL</p>"},{"location":"api/utils/","title":"Utility Functions","text":"<p>A logger which can automatically record important metrics during optimization. For a detailed guide on the usage, see the example scripts in the github repository.</p> <p>Plots an image of the simulation scene using matplotlib. This is very helpful for veryfying the correct positions of all objects in the simulation scene.</p>"},{"location":"api/utils/#fdtdx.utils.Logger","title":"<code>fdtdx.utils.Logger</code>","text":"<p>Logger for managing experiment outputs and visualization.</p> <p>Handles experiment logging, metrics tracking, and visualization of simulation results. Creates a working directory structure, initializes logging, and provides methods for saving figures, metrics, and device parameters.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_name</code> <code>str</code> <p>Name of the experiment</p> required <code>name</code> <code>str | None</code> <p>Optional specific name for the working directory. If None, uses timestamp.</p> <code>None</code> Source code in <code>src/fdtdx/utils/logger.py</code> <pre><code>class Logger:\n    \"\"\"Logger for managing experiment outputs and visualization.\n\n    Handles experiment logging, metrics tracking, and visualization of simulation results.\n    Creates a working directory structure, initializes logging, and provides methods for\n    saving figures, metrics, and device parameters.\n\n    Args:\n        experiment_name: Name of the experiment\n        name: Optional specific name for the working directory. If None, uses timestamp.\n    \"\"\"\n\n    def __init__(self, experiment_name: str, name: str | None = None):\n        sns.set_theme(context=\"paper\", style=\"white\", palette=\"colorblind\")\n        self.cwd = init_working_directory(experiment_name, wd_name=name)\n        self.console = Console()\n        self.progress = Progress(\n            SpinnerColumn(),\n            *Progress.get_default_columns(),\n            TimeElapsedColumn(),\n            console=self.console,\n        ).__enter__()\n        atexit.register(self.progress.stop)\n        logger.remove()\n        logger.add(\n            self.console.print,\n            level=\"TRACE\",\n            format=_log_formatter,\n            colorize=True,\n        )\n        logger.add(\n            self.cwd / \"logs.log\",\n            level=\"TRACE\",\n            format=\"{time:DD.MM.YYYY HH:mm:ss:ssss} | {level} - {message}\",\n        )\n        logger.info(f\"Starting experiment {experiment_name} in {self.cwd}\")\n        snapshot_python_files(self.cwd / \"code\")\n        self.fieldnames = None\n        self.writer = None\n        self.csvfile = open(self.cwd / \"metrics.csv\", \"w\", newline=\"\")\n        self.last_indices: dict[str, jax.Array | None] = defaultdict(lambda: None)\n        atexit.register(self.csvfile.close)\n\n    @property\n    def stl_dir(self) -&gt; Path:\n        \"\"\"Directory for storing STL files.\n\n        Returns:\n            Path: Directory for STL file outputs\n        \"\"\"\n        directory = self.cwd / \"device\" / \"stl\"\n        directory.mkdir(parents=True, exist_ok=True)\n        return directory\n\n    @property\n    def params_dir(self) -&gt; Path:\n        \"\"\"Directory for storing parameter files.\n\n        Returns:\n            Path: Directory for parameter file outputs\n        \"\"\"\n        directory = self.cwd / \"device\" / \"params\"\n        directory.mkdir(parents=True, exist_ok=True)\n        return directory\n\n    def savefig(self, directory: Path, filename: str, fig: Figure, dpi: int = 300):\n        \"\"\"Save a matplotlib figure to file.\n\n        Creates a figures subdirectory if needed and saves the figure with specified settings.\n\n        Args:\n            directory: Base directory to save in\n            filename: Name for the figure file\n            fig: Matplotlib figure to save\n            dpi: Resolution in dots per inch\n        \"\"\"\n        figure_directory = directory / \"figures\"\n        figure_directory.mkdir(parents=True, exist_ok=True)\n        fig.savefig(directory / \"figures\" / filename, dpi=dpi, bbox_inches=\"tight\")\n        plt.close(fig)\n\n    def write(self, stats: dict, do_print: bool = True):\n        \"\"\"Write statistics to CSV file and optionally print them.\n\n        Records metrics in a CSV file and optionally displays them in a formatted table.\n        Automatically initializes CSV headers on first write.\n\n        Args:\n            stats: Dictionary of statistics to record\n            do_print: Whether to print stats to console\n        \"\"\"\n        stats = {\n            k: v.item() if isinstance(v, jax.Array) else v\n            for k, v in stats.items()\n            if isinstance(v, (int, float)) or (isinstance(v, jax.Array) and v.size == 1)\n        }\n        if self.fieldnames is None:\n            self.fieldnames = list(stats.keys())\n            self.writer = csv.DictWriter(self.csvfile, fieldnames=self.fieldnames)\n            self.writer.writeheader()\n        assert self.writer is not None\n        self.writer.writerow(stats)\n        self.csvfile.flush()\n        if do_print:\n            table = Table(box=None)\n            for k, v in stats.items():\n                table.add_column(k)\n                table.add_column(str(v))\n            self.console.print(table)\n\n    def log_detectors(\n        self,\n        iter_idx: int,\n        objects: ObjectContainer,\n        detector_states: dict[str, DetectorState],\n        exclude: list[str] = [],\n    ):\n        \"\"\"Log detector states and generate visualization plots.\n\n        Creates plots for each detector's state and saves them to the detector's output directory.\n        Handles both figure outputs and other detector-specific file formats.\n\n        Args:\n            iter_idx: Current iteration index\n            objects: Container with simulation objects\n            detector_states: Dictionary mapping detector names to their states\n            exclude: List of detector names to exclude from logging\n        \"\"\"\n        for detector in [d for d in objects.detectors if d.name not in exclude]:\n            cur_state = jax.device_get(detector_states[detector.name])\n            cur_state = cast_floating_to_numpy(cur_state, float)\n\n            if not detector.plot:\n                continue\n            figure_dict = detector.draw_plot(\n                state=cur_state,\n                progress=self.progress,\n            )\n\n            detector_dir = self.cwd / \"detectors\" / detector.name\n            detector_dir.mkdir(parents=True, exist_ok=True)\n\n            for k, v in figure_dict.items():\n                if isinstance(v, Figure):\n                    self.savefig(\n                        detector_dir,\n                        f\"{detector.name}_{k}_{iter_idx}.png\",\n                        v,\n                        dpi=detector.plot_dpi,  # type: ignore\n                    )\n                elif isinstance(v, str):\n                    shutil.copy(\n                        v,\n                        detector_dir / f\"{detector.name}_{k}_{iter_idx}{Path(v).suffix}\",\n                    )\n                else:\n                    raise Exception(f\"invalid detector output for plotting: {k}, {v}\")\n\n    def log_params(\n        self,\n        iter_idx: int,\n        params: ParameterContainer,\n        objects: ObjectContainer,\n        export_figure: bool = False,\n        export_stl: bool = False,\n        export_air_stl: bool = False,\n    ) -&gt; int:\n        \"\"\"Log parameter states and export device visualizations.\n\n        Saves device parameters and optionally exports visualizations as figures or STL files.\n        Tracks changes in device voxels between iterations.\n\n        Args:\n            iter_idx: Current iteration index\n            params: Container with device parameters\n            objects: Container with simulation objects\n            export_figure: Whether to export index matrix figures\n            export_stl: Whether to export device geometry as STL\n            export_air_stl: Whether to export air regions as STL\n\n        Returns:\n            int: Number of voxels that changed since last iteration\n        \"\"\"\n        changed_voxels = 0\n        for device in objects.devices:\n            device_params = params[device.name]\n            indices = device.get_material_mapping(device_params)\n\n            # raw parameters and indices\n            if isinstance(device_params, dict):\n                for k, v in device_params.items():\n                    jnp.save(self.params_dir / f\"params_{iter_idx}_{device.name}_{k}.npy\", v)\n            else:\n                jnp.save(self.params_dir / f\"params_{iter_idx}_{device.name}.npy\", device_params)\n            jnp.save(self.params_dir / f\"matrix_{iter_idx}_{device.name}.npy\", indices)\n\n            if not isinstance(device, DiscreteDevice):\n                continue\n            has_previous = self.last_indices[device.name] is not None\n            cur_changed_voxels = 0\n            if has_previous:\n                last_device_indices = self.last_indices[device.name]\n                cur_changed_voxels = int(jnp.sum(indices != last_device_indices))\n            changed_voxels += cur_changed_voxels\n            self.last_indices[device.name] = indices\n            if cur_changed_voxels == 0 and has_previous:\n                continue\n            if export_stl:\n                air_name = get_air_name(device.material)\n                ordered_name_list = compute_ordered_names(device.material)\n                air_idx = ordered_name_list.index(air_name)\n                for idx in range(len(device.material)):\n                    if idx == air_idx and not export_air_stl:\n                        continue\n                    name = ordered_name_list[idx]\n                    export_stl_fn(\n                        matrix=np.asarray(indices) == idx,\n                        stl_filename=self.stl_dir / f\"matrix_{iter_idx}_{device.name}_{name}.stl\",\n                        voxel_grid_size=device.single_voxel_grid_shape,\n                    )\n                if len(device.material) &gt; 2:\n                    export_stl_fn(\n                        matrix=np.asarray(indices) != air_idx,\n                        stl_filename=self.stl_dir / f\"matrix_{iter_idx}_{device.name}_non_air.stl\",\n                        voxel_grid_size=device.single_voxel_grid_shape,\n                    )\n\n            # image of indices\n            if export_figure:\n                fig = device_matrix_index_figure(\n                    device_matrix_indices=indices,\n                    material=device.material,\n                )\n                self.savefig(\n                    self.cwd / \"device\",\n                    f\"matrix_indices_{iter_idx}_{device.name}.png\",\n                    fig,\n                    dpi=72,\n                )\n\n        return changed_voxels\n</code></pre>"},{"location":"api/utils/#fdtdx.utils.Logger.params_dir","title":"<code>params_dir: Path</code>  <code>property</code>","text":"<p>Directory for storing parameter files.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Directory for parameter file outputs</p>"},{"location":"api/utils/#fdtdx.utils.Logger.stl_dir","title":"<code>stl_dir: Path</code>  <code>property</code>","text":"<p>Directory for storing STL files.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Directory for STL file outputs</p>"},{"location":"api/utils/#fdtdx.utils.Logger.log_detectors","title":"<code>log_detectors(iter_idx, objects, detector_states, exclude=[])</code>","text":"<p>Log detector states and generate visualization plots.</p> <p>Creates plots for each detector's state and saves them to the detector's output directory. Handles both figure outputs and other detector-specific file formats.</p> <p>Parameters:</p> Name Type Description Default <code>iter_idx</code> <code>int</code> <p>Current iteration index</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with simulation objects</p> required <code>detector_states</code> <code>dict[str, DetectorState]</code> <p>Dictionary mapping detector names to their states</p> required <code>exclude</code> <code>list[str]</code> <p>List of detector names to exclude from logging</p> <code>[]</code> Source code in <code>src/fdtdx/utils/logger.py</code> <pre><code>def log_detectors(\n    self,\n    iter_idx: int,\n    objects: ObjectContainer,\n    detector_states: dict[str, DetectorState],\n    exclude: list[str] = [],\n):\n    \"\"\"Log detector states and generate visualization plots.\n\n    Creates plots for each detector's state and saves them to the detector's output directory.\n    Handles both figure outputs and other detector-specific file formats.\n\n    Args:\n        iter_idx: Current iteration index\n        objects: Container with simulation objects\n        detector_states: Dictionary mapping detector names to their states\n        exclude: List of detector names to exclude from logging\n    \"\"\"\n    for detector in [d for d in objects.detectors if d.name not in exclude]:\n        cur_state = jax.device_get(detector_states[detector.name])\n        cur_state = cast_floating_to_numpy(cur_state, float)\n\n        if not detector.plot:\n            continue\n        figure_dict = detector.draw_plot(\n            state=cur_state,\n            progress=self.progress,\n        )\n\n        detector_dir = self.cwd / \"detectors\" / detector.name\n        detector_dir.mkdir(parents=True, exist_ok=True)\n\n        for k, v in figure_dict.items():\n            if isinstance(v, Figure):\n                self.savefig(\n                    detector_dir,\n                    f\"{detector.name}_{k}_{iter_idx}.png\",\n                    v,\n                    dpi=detector.plot_dpi,  # type: ignore\n                )\n            elif isinstance(v, str):\n                shutil.copy(\n                    v,\n                    detector_dir / f\"{detector.name}_{k}_{iter_idx}{Path(v).suffix}\",\n                )\n            else:\n                raise Exception(f\"invalid detector output for plotting: {k}, {v}\")\n</code></pre>"},{"location":"api/utils/#fdtdx.utils.Logger.log_params","title":"<code>log_params(iter_idx, params, objects, export_figure=False, export_stl=False, export_air_stl=False)</code>","text":"<p>Log parameter states and export device visualizations.</p> <p>Saves device parameters and optionally exports visualizations as figures or STL files. Tracks changes in device voxels between iterations.</p> <p>Parameters:</p> Name Type Description Default <code>iter_idx</code> <code>int</code> <p>Current iteration index</p> required <code>params</code> <code>ParameterContainer</code> <p>Container with device parameters</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with simulation objects</p> required <code>export_figure</code> <code>bool</code> <p>Whether to export index matrix figures</p> <code>False</code> <code>export_stl</code> <code>bool</code> <p>Whether to export device geometry as STL</p> <code>False</code> <code>export_air_stl</code> <code>bool</code> <p>Whether to export air regions as STL</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of voxels that changed since last iteration</p> Source code in <code>src/fdtdx/utils/logger.py</code> <pre><code>def log_params(\n    self,\n    iter_idx: int,\n    params: ParameterContainer,\n    objects: ObjectContainer,\n    export_figure: bool = False,\n    export_stl: bool = False,\n    export_air_stl: bool = False,\n) -&gt; int:\n    \"\"\"Log parameter states and export device visualizations.\n\n    Saves device parameters and optionally exports visualizations as figures or STL files.\n    Tracks changes in device voxels between iterations.\n\n    Args:\n        iter_idx: Current iteration index\n        params: Container with device parameters\n        objects: Container with simulation objects\n        export_figure: Whether to export index matrix figures\n        export_stl: Whether to export device geometry as STL\n        export_air_stl: Whether to export air regions as STL\n\n    Returns:\n        int: Number of voxels that changed since last iteration\n    \"\"\"\n    changed_voxels = 0\n    for device in objects.devices:\n        device_params = params[device.name]\n        indices = device.get_material_mapping(device_params)\n\n        # raw parameters and indices\n        if isinstance(device_params, dict):\n            for k, v in device_params.items():\n                jnp.save(self.params_dir / f\"params_{iter_idx}_{device.name}_{k}.npy\", v)\n        else:\n            jnp.save(self.params_dir / f\"params_{iter_idx}_{device.name}.npy\", device_params)\n        jnp.save(self.params_dir / f\"matrix_{iter_idx}_{device.name}.npy\", indices)\n\n        if not isinstance(device, DiscreteDevice):\n            continue\n        has_previous = self.last_indices[device.name] is not None\n        cur_changed_voxels = 0\n        if has_previous:\n            last_device_indices = self.last_indices[device.name]\n            cur_changed_voxels = int(jnp.sum(indices != last_device_indices))\n        changed_voxels += cur_changed_voxels\n        self.last_indices[device.name] = indices\n        if cur_changed_voxels == 0 and has_previous:\n            continue\n        if export_stl:\n            air_name = get_air_name(device.material)\n            ordered_name_list = compute_ordered_names(device.material)\n            air_idx = ordered_name_list.index(air_name)\n            for idx in range(len(device.material)):\n                if idx == air_idx and not export_air_stl:\n                    continue\n                name = ordered_name_list[idx]\n                export_stl_fn(\n                    matrix=np.asarray(indices) == idx,\n                    stl_filename=self.stl_dir / f\"matrix_{iter_idx}_{device.name}_{name}.stl\",\n                    voxel_grid_size=device.single_voxel_grid_shape,\n                )\n            if len(device.material) &gt; 2:\n                export_stl_fn(\n                    matrix=np.asarray(indices) != air_idx,\n                    stl_filename=self.stl_dir / f\"matrix_{iter_idx}_{device.name}_non_air.stl\",\n                    voxel_grid_size=device.single_voxel_grid_shape,\n                )\n\n        # image of indices\n        if export_figure:\n            fig = device_matrix_index_figure(\n                device_matrix_indices=indices,\n                material=device.material,\n            )\n            self.savefig(\n                self.cwd / \"device\",\n                f\"matrix_indices_{iter_idx}_{device.name}.png\",\n                fig,\n                dpi=72,\n            )\n\n    return changed_voxels\n</code></pre>"},{"location":"api/utils/#fdtdx.utils.Logger.savefig","title":"<code>savefig(directory, filename, fig, dpi=300)</code>","text":"<p>Save a matplotlib figure to file.</p> <p>Creates a figures subdirectory if needed and saves the figure with specified settings.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Path</code> <p>Base directory to save in</p> required <code>filename</code> <code>str</code> <p>Name for the figure file</p> required <code>fig</code> <code>Figure</code> <p>Matplotlib figure to save</p> required <code>dpi</code> <code>int</code> <p>Resolution in dots per inch</p> <code>300</code> Source code in <code>src/fdtdx/utils/logger.py</code> <pre><code>def savefig(self, directory: Path, filename: str, fig: Figure, dpi: int = 300):\n    \"\"\"Save a matplotlib figure to file.\n\n    Creates a figures subdirectory if needed and saves the figure with specified settings.\n\n    Args:\n        directory: Base directory to save in\n        filename: Name for the figure file\n        fig: Matplotlib figure to save\n        dpi: Resolution in dots per inch\n    \"\"\"\n    figure_directory = directory / \"figures\"\n    figure_directory.mkdir(parents=True, exist_ok=True)\n    fig.savefig(directory / \"figures\" / filename, dpi=dpi, bbox_inches=\"tight\")\n    plt.close(fig)\n</code></pre>"},{"location":"api/utils/#fdtdx.utils.Logger.write","title":"<code>write(stats, do_print=True)</code>","text":"<p>Write statistics to CSV file and optionally print them.</p> <p>Records metrics in a CSV file and optionally displays them in a formatted table. Automatically initializes CSV headers on first write.</p> <p>Parameters:</p> Name Type Description Default <code>stats</code> <code>dict</code> <p>Dictionary of statistics to record</p> required <code>do_print</code> <code>bool</code> <p>Whether to print stats to console</p> <code>True</code> Source code in <code>src/fdtdx/utils/logger.py</code> <pre><code>def write(self, stats: dict, do_print: bool = True):\n    \"\"\"Write statistics to CSV file and optionally print them.\n\n    Records metrics in a CSV file and optionally displays them in a formatted table.\n    Automatically initializes CSV headers on first write.\n\n    Args:\n        stats: Dictionary of statistics to record\n        do_print: Whether to print stats to console\n    \"\"\"\n    stats = {\n        k: v.item() if isinstance(v, jax.Array) else v\n        for k, v in stats.items()\n        if isinstance(v, (int, float)) or (isinstance(v, jax.Array) and v.size == 1)\n    }\n    if self.fieldnames is None:\n        self.fieldnames = list(stats.keys())\n        self.writer = csv.DictWriter(self.csvfile, fieldnames=self.fieldnames)\n        self.writer.writeheader()\n    assert self.writer is not None\n    self.writer.writerow(stats)\n    self.csvfile.flush()\n    if do_print:\n        table = Table(box=None)\n        for k, v in stats.items():\n            table.add_column(k)\n            table.add_column(str(v))\n        self.console.print(table)\n</code></pre>"},{"location":"api/utils/#fdtdx.utils.plot_setup.plot_setup","title":"<code>fdtdx.utils.plot_setup.plot_setup(config, objects, exclude_object_list=[], filename=None, axs=None, plot_legend=True, exclude_xy_plane_object_list=[], exclude_yz_plane_object_list=[], exclude_xz_plane_object_list=[])</code>","text":"<p>Creates a visualization of the simulation setup showing objects in XY, XZ and YZ planes.</p> <p>Generates three subplots showing cross-sections of the simulation volume and the objects within it. Objects are drawn as colored rectangles with optional legends. The visualization helps verify the correct positioning and sizing of objects in the simulation setup.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>Configuration object containing simulation parameters like resolution</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container holding all simulation objects to be plotted</p> required <code>exclude_object_list</code> <code>list[SimulationObject]</code> <p>List of objects to exclude from all plots</p> <code>[]</code> <code>filename</code> <code>str | Path | None</code> <p>If provided, saves the plot to this file instead of displaying</p> <code>None</code> <code>axs</code> <code>Sequence[Any] | None</code> <p>Optional matplotlib axes to plot on. If None, creates new figure</p> <code>None</code> <code>plot_legend</code> <code>bool</code> <p>Whether to add a legend showing object names/types</p> <code>True</code> <code>exclude_xy_plane_object_list</code> <code>list[SimulationObject]</code> <p>Objects to exclude from XY plane plot</p> <code>[]</code> <code>exclude_yz_plane_object_list</code> <code>list[SimulationObject]</code> <p>Objects to exclude from YZ plane plot</p> <code>[]</code> <code>exclude_xz_plane_object_list</code> <code>list[SimulationObject]</code> <p>Objects to exclude from XZ plane plot</p> <code>[]</code> <p>Returns:</p> Type Description <code>Figure</code> <p>matplotlib.figure.Figure: The generated figure object</p> Note <p>The plots show object positions in micrometers, converting from simulation units. PML objects are automatically excluded from their respective boundary planes.</p> Source code in <code>src/fdtdx/utils/plot_setup.py</code> <pre><code>def plot_setup(\n    config: SimulationConfig,\n    objects: ObjectContainer,\n    exclude_object_list: list[SimulationObject] = [],\n    filename: str | Path | None = None,\n    axs: Sequence[Any] | None = None,\n    plot_legend: bool = True,\n    exclude_xy_plane_object_list: list[SimulationObject] = [],\n    exclude_yz_plane_object_list: list[SimulationObject] = [],\n    exclude_xz_plane_object_list: list[SimulationObject] = [],\n) -&gt; Figure:\n    \"\"\"Creates a visualization of the simulation setup showing objects in XY, XZ and YZ planes.\n\n    Generates three subplots showing cross-sections of the simulation volume and the objects\n    within it. Objects are drawn as colored rectangles with optional legends. The visualization\n    helps verify the correct positioning and sizing of objects in the simulation setup.\n\n    Args:\n        config: Configuration object containing simulation parameters like resolution\n        objects: Container holding all simulation objects to be plotted\n        exclude_object_list: List of objects to exclude from all plots\n        filename: If provided, saves the plot to this file instead of displaying\n        axs: Optional matplotlib axes to plot on. If None, creates new figure\n        plot_legend: Whether to add a legend showing object names/types\n        exclude_xy_plane_object_list: Objects to exclude from XY plane plot\n        exclude_yz_plane_object_list: Objects to exclude from YZ plane plot\n        exclude_xz_plane_object_list: Objects to exclude from XZ plane plot\n\n    Returns:\n        matplotlib.figure.Figure: The generated figure object\n\n    Note:\n        The plots show object positions in micrometers, converting from simulation units.\n        PML objects are automatically excluded from their respective boundary planes.\n    \"\"\"\n    # add boundaries to exclude lists\n    for o in objects.objects:\n        if not isinstance(o, (PerfectlyMatchedLayer, PeriodicBoundary)):\n            continue\n        if o.axis == 0:\n            exclude_yz_plane_object_list.append(o)\n        elif o.axis == 1:\n            exclude_xz_plane_object_list.append(o)\n        elif o.axis == 2:\n            exclude_xy_plane_object_list.append(o)\n    # add volume to exclude list\n    volume = objects.volume\n    exclude_object_list.append(volume)\n\n    object_list = [o for o in objects.objects if o not in exclude_object_list]\n    if axs is None:\n        fig, axs = plt.subplots(1, 3, figsize=(15, 5))\n    else:\n        fig = None\n    assert axs is not None\n    resolution = config.resolution / 1.0e-6  # Convert to \u00b5m\n\n    # get a color map\n    colored_objects: list[SimulationObject] = [o for o in object_list if o.color is not None]\n\n    if plot_legend:\n        handles = []\n        used_lists = []\n        for o in colored_objects:\n            print_single = False\n            for o2 in colored_objects:\n                if o.__class__ == o2.__class__:\n                    if o.color != o2.color:\n                        print_single = True\n                    if not o.name.startswith(\"Object\"):\n                        print_single = True\n            label = o.__class__.__name__ if o.name.startswith(\"Object\") else o.name\n            patch = Patch(color=o.color, label=label)\n            if print_single:\n                handles.append(patch)\n            else:\n                if o.__class__.__name__ not in used_lists:\n                    used_lists.append(o.__class__.__name__)\n                    handles.append(patch)\n\n        plt.legend(\n            handles=handles,\n            loc=\"upper right\",\n            bbox_to_anchor=(1.75, 0.75),\n            frameon=False,\n        )\n\n    # Plot each object on the corresponding subplot\n    for obj in colored_objects:\n        slices = obj.grid_slice_tuple\n        color = obj.color\n\n        # XY plane at Z center\n        if exclude_xy_plane_object_list is None or obj not in exclude_xy_plane_object_list:\n            axs[0].add_patch(\n                Rectangle(\n                    (slices[0][0] * resolution, slices[1][0] * resolution),\n                    (slices[0][1] - slices[0][0]) * resolution,\n                    (slices[1][1] - slices[1][0]) * resolution,\n                    color=color,\n                    alpha=0.5,\n                    linestyle=\"--\" if isinstance(obj, PeriodicBoundary) else \"-\",\n                )\n            )\n\n        # XZ plane at Y center\n        if exclude_xz_plane_object_list is None or obj not in exclude_xz_plane_object_list:\n            axs[1].add_patch(\n                Rectangle(\n                    (slices[0][0] * resolution, slices[2][0] * resolution),\n                    (slices[0][1] - slices[0][0]) * resolution,\n                    (slices[2][1] - slices[2][0]) * resolution,\n                    color=color,\n                    alpha=0.5,\n                    linestyle=\"--\" if isinstance(obj, PeriodicBoundary) else \"-\",\n                )\n            )\n\n        # YZ plane at X center\n        if exclude_yz_plane_object_list is None or obj not in exclude_yz_plane_object_list:\n            axs[2].add_patch(\n                Rectangle(\n                    (slices[1][0] * resolution, slices[2][0] * resolution),\n                    (slices[1][1] - slices[1][0]) * resolution,\n                    (slices[2][1] - slices[2][0]) * resolution,\n                    color=color,\n                    alpha=0.5,\n                    linestyle=\"--\" if isinstance(obj, PeriodicBoundary) else \"-\",\n                )\n            )\n\n    # Set labels and titles\n    axs[0].set_xlabel(\"x (\u00b5m)\")\n    axs[0].set_ylabel(\"y (\u00b5m)\")\n    axs[0].set_title(\"XY plane\")\n    axs[0].set_xlim([0, volume.grid_shape[0] * resolution])\n    axs[0].set_ylim([0, volume.grid_shape[1] * resolution])\n\n    axs[1].set_xlabel(\"x (\u00b5m)\")\n    axs[1].set_ylabel(\"z (\u00b5m)\")\n    axs[1].set_title(\"XZ plane\")\n    axs[1].set_xlim([0, volume.grid_shape[0] * resolution])\n    axs[1].set_ylim([0, volume.grid_shape[2] * resolution])\n\n    axs[2].set_xlabel(\"y (\u00b5m)\")\n    axs[2].set_ylabel(\"z (\u00b5m)\")\n    axs[2].set_title(\"YZ plane\")\n    axs[2].set_xlim([0, volume.grid_shape[1] * resolution])\n    axs[2].set_ylim([0, volume.grid_shape[2] * resolution])\n\n    # Adjust the plots for better visualization\n    for ax in axs:\n        ax.set_aspect(\"equal\")\n        ax.grid(True)\n\n    if filename is not None:\n        plt.savefig(filename, bbox_inches=\"tight\", dpi=300)\n        plt.close()\n    return plt.gcf() if fig is None else fig\n</code></pre>"},{"location":"api/objects/","title":"Objects Package","text":"<p>This section documents the core simulation objects and their management in the package.</p>"},{"location":"api/objects/#contents","title":"Contents","text":"<ul> <li>Base Class - Core object classes and positioning constraints</li> <li>Boundaries - Simulation Boundaries</li> <li>Detectors - Detectors for measuring physical metrics during simulation</li> <li>Devices - Devices with a variable shape that can be optimized</li> <li>Sources - Source objects for inducing light into a simulation</li> <li>Static Material - Objects with more intricate shapes than the default cuboid</li> </ul>"},{"location":"api/objects/boundaries/","title":"Boundaries","text":""},{"location":"api/objects/boundaries/#_1","title":"Boundaries","text":""},{"location":"api/objects/boundaries/#initialization-of-boundaries","title":"Initialization of Boundaries","text":"<p>Currently, the simulation boundary can either be a Perfectly Matched Layer for absorbing all incoming light, or a periodic boundary which wraps around to the other side of the simulation.</p> <p>Configuration object for specifying at which side of the simulation wich type of boundary should be used. Also allows specification of the PML thickness and other parameters if used.</p> <p>Initializes the corresponding boundary objects based on the config object.</p>"},{"location":"api/objects/boundaries/#fdtdx.objects.boundaries.BoundaryConfig","title":"<code>fdtdx.objects.boundaries.BoundaryConfig</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Configuration class for boundary conditions.</p> <p>This class stores parameters for boundary conditions in all six directions (min/max x/y/z). Supports both PML and periodic boundaries. For PML, the parameters control the absorption properties and physical size of the PML regions.</p> <p>Attributes:</p> Name Type Description <code>boundary_type_minx</code> <code>str</code> <p>Boundary type at minimum x (\"pml\" or \"periodic\"). Default \"pml\".</p> <code>boundary_type_maxx</code> <code>str</code> <p>Boundary type at maximum x (\"pml\" or \"periodic\"). Default \"pml\".</p> <code>boundary_type_miny</code> <code>str</code> <p>Boundary type at minimum y (\"pml\" or \"periodic\"). Default \"pml\".</p> <code>boundary_type_maxy</code> <code>str</code> <p>Boundary type at maximum y (\"pml\" or \"periodic\"). Default \"pml\".</p> <code>boundary_type_minz</code> <code>str</code> <p>Boundary type at minimum z (\"pml\" or \"periodic\"). Default \"pml\".</p> <code>boundary_type_maxz</code> <code>str</code> <p>Boundary type at maximum z (\"pml\" or \"periodic\"). Default \"pml\".</p> <code>thickness_grid_minx</code> <code>int</code> <p>Number of grid cells for PML at minimum x boundary. Default 10.</p> <code>thickness_grid_maxx</code> <code>int</code> <p>Number of grid cells for PML at maximum x boundary. Default 10.</p> <code>thickness_grid_miny</code> <code>int</code> <p>Number of grid cells for PML at minimum y boundary. Default 10.</p> <code>thickness_grid_maxy</code> <code>int</code> <p>Number of grid cells for PML at maximum y boundary. Default 10.</p> <code>thickness_grid_minz</code> <code>int</code> <p>Number of grid cells for PML at minimum z boundary. Default 10.</p> <code>thickness_grid_maxz</code> <code>int</code> <p>Number of grid cells for PML at maximum z boundary. Default 10.</p> <code>kappa_start_minx</code> <code>float</code> <p>Initial kappa value at min x boundary. Default 1.0.</p> <code>kappa_end_minx</code> <code>float</code> <p>Final kappa value at min x boundary. Default 1.5.</p> <code>kappa_start_maxx</code> <code>float</code> <p>Initial kappa value at max x boundary. Default 1.0.</p> <code>kappa_end_maxx</code> <code>float</code> <p>Final kappa value at max x boundary. Default 1.5.</p> <code>kappa_start_miny</code> <code>float</code> <p>Initial kappa value at min y boundary. Default 1.0.</p> <code>kappa_end_miny</code> <code>float</code> <p>Final kappa value at min y boundary. Default 1.5.</p> <code>kappa_start_maxy</code> <code>float</code> <p>Initial kappa value at max y boundary. Default 1.0.</p> <code>kappa_end_maxy</code> <code>float</code> <p>Final kappa value at max y boundary. Default 1.5.</p> <code>kappa_start_minz</code> <code>float</code> <p>Initial kappa value at min z boundary. Default 1.0.</p> <code>kappa_end_minz</code> <code>float</code> <p>Final kappa value at min z boundary. Default 1.5.</p> <code>kappa_start_maxz</code> <code>float</code> <p>Initial kappa value at max z boundary. Default 1.0.</p> <code>kappa_end_maxz</code> <code>float</code> <p>Final kappa value at max z boundary. Default 1.5.</p> Source code in <code>src/fdtdx/objects/boundaries/initialization.py</code> <pre><code>@extended_autoinit\nclass BoundaryConfig(ExtendedTreeClass):\n    \"\"\"Configuration class for boundary conditions.\n\n    This class stores parameters for boundary conditions in all six directions (min/max x/y/z).\n    Supports both PML and periodic boundaries. For PML, the parameters control the absorption\n    properties and physical size of the PML regions.\n\n    Attributes:\n        boundary_type_minx (str): Boundary type at minimum x (\"pml\" or \"periodic\"). Default \"pml\".\n        boundary_type_maxx (str): Boundary type at maximum x (\"pml\" or \"periodic\"). Default \"pml\".\n        boundary_type_miny (str): Boundary type at minimum y (\"pml\" or \"periodic\"). Default \"pml\".\n        boundary_type_maxy (str): Boundary type at maximum y (\"pml\" or \"periodic\"). Default \"pml\".\n        boundary_type_minz (str): Boundary type at minimum z (\"pml\" or \"periodic\"). Default \"pml\".\n        boundary_type_maxz (str): Boundary type at maximum z (\"pml\" or \"periodic\"). Default \"pml\".\n        thickness_grid_minx (int): Number of grid cells for PML at minimum x boundary. Default 10.\n        thickness_grid_maxx (int): Number of grid cells for PML at maximum x boundary. Default 10.\n        thickness_grid_miny (int): Number of grid cells for PML at minimum y boundary. Default 10.\n        thickness_grid_maxy (int): Number of grid cells for PML at maximum y boundary. Default 10.\n        thickness_grid_minz (int): Number of grid cells for PML at minimum z boundary. Default 10.\n        thickness_grid_maxz (int): Number of grid cells for PML at maximum z boundary. Default 10.\n        kappa_start_minx (float): Initial kappa value at min x boundary. Default 1.0.\n        kappa_end_minx (float): Final kappa value at min x boundary. Default 1.5.\n        kappa_start_maxx (float): Initial kappa value at max x boundary. Default 1.0.\n        kappa_end_maxx (float): Final kappa value at max x boundary. Default 1.5.\n        kappa_start_miny (float): Initial kappa value at min y boundary. Default 1.0.\n        kappa_end_miny (float): Final kappa value at min y boundary. Default 1.5.\n        kappa_start_maxy (float): Initial kappa value at max y boundary. Default 1.0.\n        kappa_end_maxy (float): Final kappa value at max y boundary. Default 1.5.\n        kappa_start_minz (float): Initial kappa value at min z boundary. Default 1.0.\n        kappa_end_minz (float): Final kappa value at min z boundary. Default 1.5.\n        kappa_start_maxz (float): Initial kappa value at max z boundary. Default 1.0.\n        kappa_end_maxz (float): Final kappa value at max z boundary. Default 1.5.\n    \"\"\"\n\n    boundary_type_minx: str = \"pml\"\n    boundary_type_maxx: str = \"pml\"\n    boundary_type_miny: str = \"pml\"\n    boundary_type_maxy: str = \"pml\"\n    boundary_type_minz: str = \"pml\"\n    boundary_type_maxz: str = \"pml\"\n    thickness_grid_minx: int = 10\n    thickness_grid_maxx: int = 10\n    thickness_grid_miny: int = 10\n    thickness_grid_maxy: int = 10\n    thickness_grid_minz: int = 10\n    thickness_grid_maxz: int = 10\n    kappa_start_minx: float = 1.0\n    kappa_end_minx: float = 1.5\n    kappa_start_maxx: float = 1.0\n    kappa_end_maxx: float = 1.5\n    kappa_start_miny: float = 1.0\n    kappa_end_miny: float = 1.5\n    kappa_start_maxy: float = 1.0\n    kappa_end_maxy: float = 1.5\n    kappa_start_minz: float = 1.0\n    kappa_end_minz: float = 1.5\n    kappa_start_maxz: float = 1.0\n    kappa_end_maxz: float = 1.5\n\n    def get_dict(self) -&gt; dict[str, int]:\n        \"\"\"Gets a dictionary mapping boundary names to their grid thicknesses.\n\n        Returns:\n            dict[str, int]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z'\n                mapping to their respective grid thickness values.\n        \"\"\"\n        return {\n            \"min_x\": self.thickness_grid_minx,\n            \"max_x\": self.thickness_grid_maxx,\n            \"min_y\": self.thickness_grid_miny,\n            \"max_y\": self.thickness_grid_maxy,\n            \"min_z\": self.thickness_grid_minz,\n            \"max_z\": self.thickness_grid_maxz,\n        }\n\n    def get_type_dict(self) -&gt; dict[str, str]:\n        \"\"\"Gets a dictionary mapping boundary names to their boundary types.\n\n        Returns:\n            dict[str, str]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z'\n                mapping to their respective boundary types (\"pml\" or \"periodic\").\n        \"\"\"\n        return {\n            \"min_x\": self.boundary_type_minx,\n            \"max_x\": self.boundary_type_maxx,\n            \"min_y\": self.boundary_type_miny,\n            \"max_y\": self.boundary_type_maxy,\n            \"min_z\": self.boundary_type_minz,\n            \"max_z\": self.boundary_type_maxz,\n        }\n\n    def get_kappa_dict(\n        self,\n        prop: Literal[\"kappa_start\", \"kappa_end\"],\n    ) -&gt; dict[str, float]:\n        \"\"\"Gets a dictionary mapping boundary names to their kappa values.\n\n        Args:\n            prop: Which kappa property to get, either \"kappa_start\" or \"kappa_end\"\n\n        Returns:\n            dict[str, float]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z'\n                mapping to their respective kappa values.\n\n        Raises:\n            Exception: If prop is not \"kappa_start\" or \"kappa_end\"\n        \"\"\"\n        if prop == \"kappa_start\":\n            return {\n                \"min_x\": self.kappa_start_minx,\n                \"max_x\": self.kappa_start_maxx,\n                \"min_y\": self.kappa_start_miny,\n                \"max_y\": self.kappa_start_maxy,\n                \"min_z\": self.kappa_start_minz,\n                \"max_z\": self.kappa_start_maxz,\n            }\n        elif prop == \"kappa_end\":\n            return {\n                \"min_x\": self.kappa_end_minx,\n                \"max_x\": self.kappa_end_maxx,\n                \"min_y\": self.kappa_end_miny,\n                \"max_y\": self.kappa_end_maxy,\n                \"min_z\": self.kappa_end_minz,\n                \"max_z\": self.kappa_end_maxz,\n            }\n        else:\n            raise Exception(f\"Unknown: {prop=}\")\n\n    def get_inside_boundary_slice(self) -&gt; tuple[slice, slice, slice]:\n        \"\"\"Gets slice objects for the non-PML interior region of the simulation volume.\n\n        Returns:\n            tuple[slice, slice, slice]: Three slice objects for indexing the x, y, z dimensions\n                respectively, excluding the PML boundary regions.\n        \"\"\"\n        return (\n            slice(\n                self.thickness_grid_minx + 1 if self.boundary_type_minx == \"pml\" else 0,\n                -self.thickness_grid_maxx - 1 if self.boundary_type_maxx == \"pml\" else None,\n            ),\n            slice(\n                self.thickness_grid_miny + 1 if self.boundary_type_miny == \"pml\" else 0,\n                -self.thickness_grid_maxy - 1 if self.boundary_type_maxy == \"pml\" else None,\n            ),\n            slice(\n                self.thickness_grid_minz + 1 if self.boundary_type_minz == \"pml\" else 0,\n                -self.thickness_grid_maxz - 1 if self.boundary_type_maxz == \"pml\" else None,\n            ),\n        )\n\n    @classmethod\n    def from_uniform_bound(\n        cls,\n        thickness: int = 10,\n        boundary_type: str = \"pml\",\n        kappa_start: float = 1,\n        kappa_end: float = 1.5,\n    ) -&gt; \"BoundaryConfig\":\n        \"\"\"Creates a BoundaryConfig with uniform parameters for all boundaries.\n\n        Args:\n            thickness: Grid thickness to use for all PML boundaries\n            boundary_type: Type of boundary to use (\"pml\" or \"periodic\"). Defaults to \"pml\".\n            kappa_start: Initial kappa value for all boundaries. Defaults to 1.0.\n            kappa_end: Final kappa value for all boundaries. Defaults to 1.5.\n\n        Returns:\n            BoundaryConfig: New config object with uniform parameters\n        \"\"\"\n        return cls(\n            boundary_type_minx=boundary_type,\n            boundary_type_maxx=boundary_type,\n            boundary_type_miny=boundary_type,\n            boundary_type_maxy=boundary_type,\n            boundary_type_minz=boundary_type,\n            boundary_type_maxz=boundary_type,\n            thickness_grid_minx=thickness,\n            thickness_grid_maxx=thickness,\n            thickness_grid_miny=thickness,\n            thickness_grid_maxy=thickness,\n            thickness_grid_minz=thickness,\n            thickness_grid_maxz=thickness,\n            kappa_start_minx=kappa_start,\n            kappa_end_minx=kappa_end,\n            kappa_start_maxx=kappa_start,\n            kappa_end_maxx=kappa_end,\n            kappa_start_miny=kappa_start,\n            kappa_end_miny=kappa_end,\n            kappa_start_maxy=kappa_start,\n            kappa_end_maxy=kappa_end,\n            kappa_start_minz=kappa_start,\n            kappa_end_minz=kappa_end,\n            kappa_start_maxz=kappa_start,\n            kappa_end_maxz=kappa_end,\n        )\n</code></pre>"},{"location":"api/objects/boundaries/#fdtdx.objects.boundaries.BoundaryConfig.from_uniform_bound","title":"<code>from_uniform_bound(thickness=10, boundary_type='pml', kappa_start=1, kappa_end=1.5)</code>  <code>classmethod</code>","text":"<p>Creates a BoundaryConfig with uniform parameters for all boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>thickness</code> <code>int</code> <p>Grid thickness to use for all PML boundaries</p> <code>10</code> <code>boundary_type</code> <code>str</code> <p>Type of boundary to use (\"pml\" or \"periodic\"). Defaults to \"pml\".</p> <code>'pml'</code> <code>kappa_start</code> <code>float</code> <p>Initial kappa value for all boundaries. Defaults to 1.0.</p> <code>1</code> <code>kappa_end</code> <code>float</code> <p>Final kappa value for all boundaries. Defaults to 1.5.</p> <code>1.5</code> <p>Returns:</p> Name Type Description <code>BoundaryConfig</code> <code>BoundaryConfig</code> <p>New config object with uniform parameters</p> Source code in <code>src/fdtdx/objects/boundaries/initialization.py</code> <pre><code>@classmethod\ndef from_uniform_bound(\n    cls,\n    thickness: int = 10,\n    boundary_type: str = \"pml\",\n    kappa_start: float = 1,\n    kappa_end: float = 1.5,\n) -&gt; \"BoundaryConfig\":\n    \"\"\"Creates a BoundaryConfig with uniform parameters for all boundaries.\n\n    Args:\n        thickness: Grid thickness to use for all PML boundaries\n        boundary_type: Type of boundary to use (\"pml\" or \"periodic\"). Defaults to \"pml\".\n        kappa_start: Initial kappa value for all boundaries. Defaults to 1.0.\n        kappa_end: Final kappa value for all boundaries. Defaults to 1.5.\n\n    Returns:\n        BoundaryConfig: New config object with uniform parameters\n    \"\"\"\n    return cls(\n        boundary_type_minx=boundary_type,\n        boundary_type_maxx=boundary_type,\n        boundary_type_miny=boundary_type,\n        boundary_type_maxy=boundary_type,\n        boundary_type_minz=boundary_type,\n        boundary_type_maxz=boundary_type,\n        thickness_grid_minx=thickness,\n        thickness_grid_maxx=thickness,\n        thickness_grid_miny=thickness,\n        thickness_grid_maxy=thickness,\n        thickness_grid_minz=thickness,\n        thickness_grid_maxz=thickness,\n        kappa_start_minx=kappa_start,\n        kappa_end_minx=kappa_end,\n        kappa_start_maxx=kappa_start,\n        kappa_end_maxx=kappa_end,\n        kappa_start_miny=kappa_start,\n        kappa_end_miny=kappa_end,\n        kappa_start_maxy=kappa_start,\n        kappa_end_maxy=kappa_end,\n        kappa_start_minz=kappa_start,\n        kappa_end_minz=kappa_end,\n        kappa_start_maxz=kappa_start,\n        kappa_end_maxz=kappa_end,\n    )\n</code></pre>"},{"location":"api/objects/boundaries/#fdtdx.objects.boundaries.BoundaryConfig.get_dict","title":"<code>get_dict()</code>","text":"<p>Gets a dictionary mapping boundary names to their grid thicknesses.</p> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>dict[str, int]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective grid thickness values.</p> Source code in <code>src/fdtdx/objects/boundaries/initialization.py</code> <pre><code>def get_dict(self) -&gt; dict[str, int]:\n    \"\"\"Gets a dictionary mapping boundary names to their grid thicknesses.\n\n    Returns:\n        dict[str, int]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z'\n            mapping to their respective grid thickness values.\n    \"\"\"\n    return {\n        \"min_x\": self.thickness_grid_minx,\n        \"max_x\": self.thickness_grid_maxx,\n        \"min_y\": self.thickness_grid_miny,\n        \"max_y\": self.thickness_grid_maxy,\n        \"min_z\": self.thickness_grid_minz,\n        \"max_z\": self.thickness_grid_maxz,\n    }\n</code></pre>"},{"location":"api/objects/boundaries/#fdtdx.objects.boundaries.BoundaryConfig.get_inside_boundary_slice","title":"<code>get_inside_boundary_slice()</code>","text":"<p>Gets slice objects for the non-PML interior region of the simulation volume.</p> <p>Returns:</p> Type Description <code>tuple[slice, slice, slice]</code> <p>tuple[slice, slice, slice]: Three slice objects for indexing the x, y, z dimensions respectively, excluding the PML boundary regions.</p> Source code in <code>src/fdtdx/objects/boundaries/initialization.py</code> <pre><code>def get_inside_boundary_slice(self) -&gt; tuple[slice, slice, slice]:\n    \"\"\"Gets slice objects for the non-PML interior region of the simulation volume.\n\n    Returns:\n        tuple[slice, slice, slice]: Three slice objects for indexing the x, y, z dimensions\n            respectively, excluding the PML boundary regions.\n    \"\"\"\n    return (\n        slice(\n            self.thickness_grid_minx + 1 if self.boundary_type_minx == \"pml\" else 0,\n            -self.thickness_grid_maxx - 1 if self.boundary_type_maxx == \"pml\" else None,\n        ),\n        slice(\n            self.thickness_grid_miny + 1 if self.boundary_type_miny == \"pml\" else 0,\n            -self.thickness_grid_maxy - 1 if self.boundary_type_maxy == \"pml\" else None,\n        ),\n        slice(\n            self.thickness_grid_minz + 1 if self.boundary_type_minz == \"pml\" else 0,\n            -self.thickness_grid_maxz - 1 if self.boundary_type_maxz == \"pml\" else None,\n        ),\n    )\n</code></pre>"},{"location":"api/objects/boundaries/#fdtdx.objects.boundaries.BoundaryConfig.get_kappa_dict","title":"<code>get_kappa_dict(prop)</code>","text":"<p>Gets a dictionary mapping boundary names to their kappa values.</p> <p>Parameters:</p> Name Type Description Default <code>prop</code> <code>Literal['kappa_start', 'kappa_end']</code> <p>Which kappa property to get, either \"kappa_start\" or \"kappa_end\"</p> required <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>dict[str, float]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective kappa values.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If prop is not \"kappa_start\" or \"kappa_end\"</p> Source code in <code>src/fdtdx/objects/boundaries/initialization.py</code> <pre><code>def get_kappa_dict(\n    self,\n    prop: Literal[\"kappa_start\", \"kappa_end\"],\n) -&gt; dict[str, float]:\n    \"\"\"Gets a dictionary mapping boundary names to their kappa values.\n\n    Args:\n        prop: Which kappa property to get, either \"kappa_start\" or \"kappa_end\"\n\n    Returns:\n        dict[str, float]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z'\n            mapping to their respective kappa values.\n\n    Raises:\n        Exception: If prop is not \"kappa_start\" or \"kappa_end\"\n    \"\"\"\n    if prop == \"kappa_start\":\n        return {\n            \"min_x\": self.kappa_start_minx,\n            \"max_x\": self.kappa_start_maxx,\n            \"min_y\": self.kappa_start_miny,\n            \"max_y\": self.kappa_start_maxy,\n            \"min_z\": self.kappa_start_minz,\n            \"max_z\": self.kappa_start_maxz,\n        }\n    elif prop == \"kappa_end\":\n        return {\n            \"min_x\": self.kappa_end_minx,\n            \"max_x\": self.kappa_end_maxx,\n            \"min_y\": self.kappa_end_miny,\n            \"max_y\": self.kappa_end_maxy,\n            \"min_z\": self.kappa_end_minz,\n            \"max_z\": self.kappa_end_maxz,\n        }\n    else:\n        raise Exception(f\"Unknown: {prop=}\")\n</code></pre>"},{"location":"api/objects/boundaries/#fdtdx.objects.boundaries.BoundaryConfig.get_type_dict","title":"<code>get_type_dict()</code>","text":"<p>Gets a dictionary mapping boundary names to their boundary types.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective boundary types (\"pml\" or \"periodic\").</p> Source code in <code>src/fdtdx/objects/boundaries/initialization.py</code> <pre><code>def get_type_dict(self) -&gt; dict[str, str]:\n    \"\"\"Gets a dictionary mapping boundary names to their boundary types.\n\n    Returns:\n        dict[str, str]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z'\n            mapping to their respective boundary types (\"pml\" or \"periodic\").\n    \"\"\"\n    return {\n        \"min_x\": self.boundary_type_minx,\n        \"max_x\": self.boundary_type_maxx,\n        \"min_y\": self.boundary_type_miny,\n        \"max_y\": self.boundary_type_maxy,\n        \"min_z\": self.boundary_type_minz,\n        \"max_z\": self.boundary_type_maxz,\n    }\n</code></pre>"},{"location":"api/objects/boundaries/#fdtdx.objects.boundaries.boundary_objects_from_config","title":"<code>fdtdx.objects.boundaries.boundary_objects_from_config(config, volume)</code>","text":"<p>Creates boundary objects from a boundary configuration.</p> <p>Creates PerfectlyMatchedLayer or PeriodicBoundary objects for all six boundaries (min/max x/y/z) based on the provided configuration. Also generates position constraints to properly place the boundary objects relative to the simulation volume.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BoundaryConfig</code> <p>Configuration object containing boundary parameters</p> required <code>volume</code> <code>SimulationObject</code> <p>The main simulation volume object that the boundaries will surround</p> required <p>Returns:</p> Type Description <code>tuple[dict[str, Union[PerfectlyMatchedLayer, PeriodicBoundary]], list[PositionConstraint]]</code> <p>tuple containing: - dict mapping boundary names ('min_x', 'max_x', etc) to boundary objects - list of PositionConstraint objects for placing the boundaries</p> Source code in <code>src/fdtdx/objects/boundaries/initialization.py</code> <pre><code>def boundary_objects_from_config(\n    config: BoundaryConfig,\n    volume: SimulationObject,\n) -&gt; tuple[dict[str, Union[PerfectlyMatchedLayer, PeriodicBoundary]], list[PositionConstraint]]:\n    \"\"\"Creates boundary objects from a boundary configuration.\n\n    Creates PerfectlyMatchedLayer or PeriodicBoundary objects for all six boundaries\n    (min/max x/y/z) based on the provided configuration. Also generates position\n    constraints to properly place the boundary objects relative to the simulation volume.\n\n    Args:\n        config: Configuration object containing boundary parameters\n        volume: The main simulation volume object that the boundaries will surround\n\n    Returns:\n        tuple containing:\n            - dict mapping boundary names ('min_x', 'max_x', etc) to boundary objects\n            - list of PositionConstraint objects for placing the boundaries\n    \"\"\"\n    boundaries, constraints = {}, []\n    thickness_dict = config.get_dict()\n    type_dict = config.get_type_dict()\n    kappa_start_dict = config.get_kappa_dict(\"kappa_start\")\n    kappa_end_dict = config.get_kappa_dict(\"kappa_end\")\n\n    for kind, thickness in thickness_dict.items():\n        axis, direction = axis_direction_from_kind(kind)\n        boundary_type = type_dict[kind]\n        kappa_start, kappa_end = kappa_start_dict[kind], kappa_end_dict[kind]\n\n        grid_shape_list: list[int | None] = [None, None, None]\n        grid_shape_list[axis] = thickness if boundary_type == \"pml\" else 1\n        grid_shape: PartialGridShape3D = tuple(grid_shape_list)  # type: ignore\n\n        other_axes = [0, 1, 2]\n        del other_axes[axis]\n\n        if boundary_type == \"pml\":\n            cur_boundary = PerfectlyMatchedLayer(\n                axis=axis,\n                partial_grid_shape=grid_shape,\n                kappa_start=kappa_start,\n                kappa_end=kappa_end,\n                direction=direction,\n            )\n        else:  # periodic\n            cur_boundary = PeriodicBoundary(\n                axis=axis,\n                partial_grid_shape=grid_shape,\n                direction=direction,\n            )\n\n        direction_int = -1 if direction == \"-\" else 1\n        pos_constraint = cur_boundary.place_relative_to(\n            volume,\n            axes=(axis, other_axes[0], other_axes[1]),\n            own_positions=(direction_int, 0, 0),\n            other_positions=(direction_int, 0, 0),\n        )\n\n        boundaries[kind] = cur_boundary\n        constraints.append(pos_constraint)\n\n    return boundaries, constraints\n</code></pre>"},{"location":"api/objects/boundaries/#boundary-objects","title":"Boundary Objects","text":""},{"location":"api/objects/boundaries/#fdtdx.objects.boundaries.PerfectlyMatchedLayer","title":"<code>fdtdx.objects.boundaries.PerfectlyMatchedLayer</code>","text":"<p>               Bases: <code>BaseBoundary</code></p> <p>Implements a Convolutional Perfectly Matched Layer (CPML) boundary condition.</p> <p>The CPML absorbs outgoing electromagnetic waves with minimal reflection by using a complex coordinate stretching approach. This implementation supports arbitrary axis orientation and both positive/negative directions.</p> <p>Attributes:</p> Name Type Description <code>axis</code> <code>int</code> <p>Principal axis for PML (0=x, 1=y, 2=z)</p> <code>direction</code> <code>Literal['+', '-']</code> <p>Direction along axis (\"+\" or \"-\")</p> <code>alpha</code> <code>float</code> <p>Loss parameter for complex frequency shifting</p> <code>kappa_start</code> <code>float</code> <p>Initial kappa stretching coefficient</p> <code>kappa_end</code> <code>float</code> <p>Final kappa stretching coefficient</p> <code>color</code> <code>tuple[float, float, float]</code> <p>RGB color tuple for visualization</p> Source code in <code>src/fdtdx/objects/boundaries/perfectly_matched_layer.py</code> <pre><code>@extended_autoinit\nclass PerfectlyMatchedLayer(BaseBoundary):\n    \"\"\"Implements a Convolutional Perfectly Matched Layer (CPML) boundary condition.\n\n    The CPML absorbs outgoing electromagnetic waves with minimal reflection by using\n    a complex coordinate stretching approach. This implementation supports arbitrary\n    axis orientation and both positive/negative directions.\n\n    Attributes:\n        axis: Principal axis for PML (0=x, 1=y, 2=z)\n        direction: Direction along axis (\"+\" or \"-\")\n        alpha: Loss parameter for complex frequency shifting\n        kappa_start: Initial kappa stretching coefficient\n        kappa_end: Final kappa stretching coefficient\n        color: RGB color tuple for visualization\n    \"\"\"\n\n    axis: int = field(kind=\"KW_ONLY\")  # type: ignore\n    direction: Literal[\"+\", \"-\"] = frozen_field(kind=\"KW_ONLY\")  # type: ignore\n    alpha: float = 1.0e-8\n    kappa_start: float = 1.0\n    kappa_end: float = 1.5\n    color: tuple[float, float, float] = DARK_GREY\n\n    @property\n    def descriptive_name(self) -&gt; str:\n        \"\"\"Gets a human-readable name describing this PML boundary's location.\n\n        Returns:\n            str: Description like \"min_x\" or \"max_z\" indicating position\n        \"\"\"\n        axis_str = \"x\" if self.axis == 0 else \"y\" if self.axis == 1 else \"z\"\n        direction_str = \"min\" if self.direction == \"-\" else \"max\"\n        return f\"{direction_str}_{axis_str}\"\n\n    @property\n    def thickness(self) -&gt; int:\n        \"\"\"Gets the thickness of the PML layer in grid points.\n\n        Returns:\n            int: Number of grid points in the PML along its axis\n        \"\"\"\n        return self.grid_shape[self.axis]\n\n    def init_state(\n        self,\n    ) -&gt; BoundaryState:\n        dtype = self._config.dtype\n        sigma_E, sigma_H = standard_sigma_from_direction_axis(\n            thickness=self.thickness,\n            direction=self.direction,\n            axis=self.axis,\n            dtype=dtype,\n        )\n\n        kappa = kappa_from_direction_axis(\n            kappa_start=self.kappa_start,\n            kappa_end=self.kappa_end,\n            thickness=self.thickness,\n            direction=self.direction,\n            axis=self.axis,\n            dtype=dtype,\n        )\n\n        bE = jnp.exp(-self._config.courant_number * (sigma_E / kappa + self.alpha))\n        bH = jnp.exp(-self._config.courant_number * (sigma_H / kappa + self.alpha))\n\n        cE = (bE - 1) * sigma_E / (sigma_E * kappa + kappa**2 * self.alpha)\n        cH = (bH - 1) * sigma_H / (sigma_H * kappa + kappa**2 * self.alpha)\n\n        ext_shape = (3,) + self.grid_shape\n\n        boundary_state = BoundaryState(\n            psi_Ex=jnp.zeros(shape=ext_shape, dtype=dtype),\n            psi_Ey=jnp.zeros(shape=ext_shape, dtype=dtype),\n            psi_Ez=jnp.zeros(shape=ext_shape, dtype=dtype),\n            psi_Hx=jnp.zeros(shape=ext_shape, dtype=dtype),\n            psi_Hy=jnp.zeros(shape=ext_shape, dtype=dtype),\n            psi_Hz=jnp.zeros(shape=ext_shape, dtype=dtype),\n            bE=bE.astype(dtype),\n            bH=bH.astype(dtype),\n            cE=cE.astype(dtype),\n            cH=cH.astype(dtype),\n            kappa=kappa.astype(dtype),\n        )\n        return boundary_state\n\n    def reset_state(self, state: BoundaryState) -&gt; BoundaryState:\n        dtype = self._config.dtype\n        sigma_E, sigma_H = standard_sigma_from_direction_axis(\n            thickness=self.thickness,\n            direction=self.direction,\n            axis=self.axis,\n            dtype=dtype,\n        )\n\n        kappa = kappa_from_direction_axis(\n            kappa_start=self.kappa_start,\n            kappa_end=self.kappa_end,\n            thickness=self.thickness,\n            direction=self.direction,\n            axis=self.axis,\n            dtype=dtype,\n        )\n\n        bE = jnp.exp(-self._config.courant_number * (sigma_E / kappa + self.alpha))\n        bH = jnp.exp(-self._config.courant_number * (sigma_H / kappa + self.alpha))\n\n        cE = (bE - 1) * sigma_E / (sigma_E * kappa + kappa**2 * self.alpha)\n        cH = (bH - 1) * sigma_H / (sigma_H * kappa + kappa**2 * self.alpha)\n\n        new_state = BoundaryState(\n            psi_Ex=state.psi_Ex * 0,\n            psi_Ey=state.psi_Ey * 0,\n            psi_Ez=state.psi_Ez * 0,\n            psi_Hx=state.psi_Hx * 0,\n            psi_Hy=state.psi_Hy * 0,\n            psi_Hz=state.psi_Hz * 0,\n            bE=bE.astype(dtype),\n            bH=bH.astype(dtype),\n            cE=cE.astype(dtype),\n            cH=cH.astype(dtype),\n            kappa=kappa.astype(dtype),\n        )\n        return new_state\n\n    def boundary_interface_grid_shape(self) -&gt; GridShape3D:\n        if self.axis == 0:\n            return 1, self.grid_shape[1], self.grid_shape[2]\n        elif self.axis == 1:\n            return self.grid_shape[0], 1, self.grid_shape[2]\n        elif self.axis == 2:\n            return self.grid_shape[0], self.grid_shape[1], 1\n        raise Exception(f\"Invalid axis: {self.axis=}\")\n\n    def boundary_interface_slice_tuple(self) -&gt; SliceTuple3D:\n        slice_list = [*self._grid_slice_tuple]\n        if self.direction == \"+\":\n            slice_list[self.axis] = (self._grid_slice_tuple[self.axis][0], self._grid_slice_tuple[self.axis][0] + 1)\n        elif self.direction == \"-\":\n            slice_list[self.axis] = (self._grid_slice_tuple[self.axis][1] - 1, self._grid_slice_tuple[self.axis][1])\n        return slice_list[0], slice_list[1], slice_list[2]\n\n    def boundary_interface_slice(self) -&gt; Slice3D:\n        slice_list = [*self.grid_slice]\n        if self.direction == \"+\":\n            slice_list[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][0], self._grid_slice_tuple[self.axis][0] + 1\n            )\n        elif self.direction == \"-\":\n            slice_list[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][1] - 1, self._grid_slice_tuple[self.axis][1]\n            )\n        return slice_list[0], slice_list[1], slice_list[2]\n\n    def update_E_boundary_state(\n        self,\n        boundary_state: BoundaryState,\n        H: jax.Array,\n    ) -&gt; BoundaryState:\n        Hx = H[0, *self.grid_slice]\n        Hy = H[1, *self.grid_slice]\n        Hz = H[2, *self.grid_slice]\n\n        psi_Ex = boundary_state.psi_Ex * boundary_state.bE\n        psi_Ey = boundary_state.psi_Ey * boundary_state.bE\n        psi_Ez = boundary_state.psi_Ez * boundary_state.bE\n\n        psi_Ex = psi_Ex.at[1, :, 1:, :].add(\n            (Hz[:, 1:, :] - Hz[:, :-1, :])\n            * (boundary_state.cE[1, :, 1:, :] if self.axis == 1 else boundary_state.cE[1])\n        )\n        psi_Ex = psi_Ex.at[2, :, :, 1:].add(\n            (Hy[:, :, 1:] - Hy[:, :, :-1])\n            * (boundary_state.cE[2, :, :, 1:] if self.axis == 2 else boundary_state.cE[2])\n        )\n\n        psi_Ey = psi_Ey.at[2, :, :, 1:].add(\n            (Hx[:, :, 1:] - Hx[:, :, :-1])\n            * (boundary_state.cE[2, :, :, 1:] if self.axis == 2 else boundary_state.cE[2])\n        )\n        psi_Ey = psi_Ey.at[0, 1:, :, :].add(\n            (Hz[1:, :, :] - Hz[:-1, :, :])\n            * (boundary_state.cE[0, 1:, :, :] if self.axis == 0 else boundary_state.cE[0])\n        )\n\n        psi_Ez = psi_Ez.at[0, 1:, :, :].add(\n            (Hy[1:, :, :] - Hy[:-1, :, :])\n            * (boundary_state.cE[0, 1:, :, :] if self.axis == 0 else boundary_state.cE[0])\n        )\n        psi_Ez = psi_Ez.at[1, :, 1:, :].add(\n            (Hx[:, 1:, :] - Hx[:, :-1, :])\n            * (boundary_state.cE[1, :, 1:, :] if self.axis == 1 else boundary_state.cE[1])\n        )\n\n        boundary_state = boundary_state.at[\"psi_Ex\"].set(psi_Ex)\n        boundary_state = boundary_state.at[\"psi_Ey\"].set(psi_Ey)\n        boundary_state = boundary_state.at[\"psi_Ez\"].set(psi_Ez)\n\n        return boundary_state\n\n    def update_H_boundary_state(\n        self,\n        boundary_state: BoundaryState,\n        E: jax.Array,\n    ) -&gt; BoundaryState:\n        Ex = E[0, *self.grid_slice]\n        Ey = E[1, *self.grid_slice]\n        Ez = E[2, *self.grid_slice]\n\n        psi_Hx = boundary_state.psi_Hx * boundary_state.bH\n        psi_Hy = boundary_state.psi_Hy * boundary_state.bH\n        psi_Hz = boundary_state.psi_Hz * boundary_state.bH\n\n        psi_Hx = psi_Hx.at[1, :, :-1, :].add(\n            (Ez[:, 1:, :] - Ez[:, :-1, :])\n            * (boundary_state.cH[1, :, :-1, :] if self.axis == 1 else boundary_state.cH[1])\n        )\n        psi_Hx = psi_Hx.at[2, :, :, :-1].add(\n            (Ey[:, :, 1:] - Ey[:, :, :-1])\n            * (boundary_state.cH[2, :, :, :-1] if self.axis == 2 else boundary_state.cH[2])\n        )\n\n        psi_Hy = psi_Hy.at[2, :, :, :-1].add(\n            (Ex[:, :, 1:] - Ex[:, :, :-1])\n            * (boundary_state.cH[2, :, :, :-1] if self.axis == 2 else boundary_state.cH[2])\n        )\n        psi_Hy = psi_Hy.at[0, :-1, :, :].add(\n            (Ez[1:, :, :] - Ez[:-1, :, :])\n            * (boundary_state.cH[0, :-1, :, :] if self.axis == 0 else boundary_state.cH[0])\n        )\n\n        psi_Hz = psi_Hz.at[0, :-1, :, :].add(\n            (Ey[1:, :, :] - Ey[:-1, :, :])\n            * (boundary_state.cH[0, :-1, :, :] if self.axis == 0 else boundary_state.cH[0])\n        )\n        psi_Hz = psi_Hz.at[1, :, :-1, :].add(\n            (Ex[:, 1:, :] - Ex[:, :-1, :])\n            * (boundary_state.cH[1, :, :-1, :] if self.axis == 1 else boundary_state.cH[1])\n        )\n\n        boundary_state = boundary_state.at[\"psi_Hx\"].set(psi_Hx)\n        boundary_state = boundary_state.at[\"psi_Hy\"].set(psi_Hy)\n        boundary_state = boundary_state.at[\"psi_Hz\"].set(psi_Hz)\n\n        return boundary_state\n\n    def update_E(\n        self,\n        E: jax.Array,\n        boundary_state: BoundaryState,\n        inverse_permittivity: jax.Array,\n    ) -&gt; jax.Array:\n        phi_Ex = boundary_state.psi_Ex[1] - boundary_state.psi_Ex[2]\n        phi_Ey = boundary_state.psi_Ey[2] - boundary_state.psi_Ey[0]\n        phi_Ez = boundary_state.psi_Ez[0] - boundary_state.psi_Ez[1]\n        phi_E = jnp.stack((phi_Ex, phi_Ey, phi_Ez), axis=0)\n\n        E = E.at[:, *self.grid_slice].divide(boundary_state.kappa)\n        inv_perm_slice = inverse_permittivity[self.grid_slice]\n        update = self._config.courant_number * inv_perm_slice * phi_E\n        E = E.at[:, *self.grid_slice].add(update)\n        return E\n\n    def update_H(\n        self,\n        H: jax.Array,\n        boundary_state: BoundaryState,\n        inverse_permeability: jax.Array | float,\n    ) -&gt; jax.Array:\n        phi_Hx = boundary_state.psi_Hx[1] - boundary_state.psi_Hx[2]\n        phi_Hy = boundary_state.psi_Hy[2] - boundary_state.psi_Hy[0]\n        phi_Hz = boundary_state.psi_Hz[0] - boundary_state.psi_Hz[1]\n        phi_H = jnp.stack((phi_Hx, phi_Hy, phi_Hz), axis=0)\n\n        H = H.at[:, *self.grid_slice].divide(boundary_state.kappa)\n        if isinstance(inverse_permeability, jax.Array) and inverse_permeability.ndim &gt; 0:\n            inverse_permeability = inverse_permeability[self.grid_slice]\n        update = -self._config.courant_number * inverse_permeability * phi_H\n        H = H.at[:, *self.grid_slice].add(update)\n        return H\n</code></pre>"},{"location":"api/objects/boundaries/#fdtdx.objects.boundaries.PerfectlyMatchedLayer.descriptive_name","title":"<code>descriptive_name: str</code>  <code>property</code>","text":"<p>Gets a human-readable name describing this PML boundary's location.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Description like \"min_x\" or \"max_z\" indicating position</p>"},{"location":"api/objects/boundaries/#fdtdx.objects.boundaries.PerfectlyMatchedLayer.thickness","title":"<code>thickness: int</code>  <code>property</code>","text":"<p>Gets the thickness of the PML layer in grid points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of grid points in the PML along its axis</p>"},{"location":"api/objects/boundaries/#fdtdx.objects.boundaries.PeriodicBoundary","title":"<code>fdtdx.objects.boundaries.PeriodicBoundary</code>","text":"<p>               Bases: <code>BaseBoundary</code></p> <p>Implements periodic boundary conditions.</p> <p>The periodic boundary connects opposite sides of the simulation domain, making waves that exit one side reenter from the opposite side.</p> <p>Attributes:</p> Name Type Description <code>axis</code> <code>int</code> <p>Principal axis for periodicity (0=x, 1=y, 2=z)</p> <code>direction</code> <code>Literal['+', '-']</code> <p>Direction along axis (\"+\" or \"-\")</p> <code>color</code> <code>tuple[float, float, float]</code> <p>RGB color tuple for visualization</p> Source code in <code>src/fdtdx/objects/boundaries/periodic.py</code> <pre><code>@extended_autoinit\nclass PeriodicBoundary(BaseBoundary):\n    \"\"\"Implements periodic boundary conditions.\n\n    The periodic boundary connects opposite sides of the simulation domain,\n    making waves that exit one side reenter from the opposite side.\n\n    Attributes:\n        axis: Principal axis for periodicity (0=x, 1=y, 2=z)\n        direction: Direction along axis (\"+\" or \"-\")\n        color: RGB color tuple for visualization\n    \"\"\"\n\n    axis: int = field(kind=\"KW_ONLY\")  # type: ignore\n    direction: Literal[\"+\", \"-\"] = frozen_field(kind=\"KW_ONLY\")  # type: ignore\n    color: tuple[float, float, float] = LIGHT_BLUE\n\n    @property\n    def descriptive_name(self) -&gt; str:\n        \"\"\"Gets a human-readable name describing this periodic boundary's location.\n\n        Returns:\n            str: Description like \"min_x\" or \"max_z\" indicating position\n        \"\"\"\n        axis_str = \"x\" if self.axis == 0 else \"y\" if self.axis == 1 else \"z\"\n        direction_str = \"min\" if self.direction == \"-\" else \"max\"\n        return f\"{direction_str}_{axis_str}\"\n\n    @property\n    def thickness(self) -&gt; int:\n        \"\"\"Gets the thickness of the periodic boundary layer in grid points.\n\n        Returns:\n            int: Number of grid points in the boundary layer (always 1 for periodic)\n        \"\"\"\n        return 1\n\n    def init_state(\n        self,\n    ) -&gt; PeriodicBoundaryState:\n        dtype = self._config.dtype\n        ext_shape = (3,) + self.grid_shape\n\n        boundary_state = PeriodicBoundaryState(\n            E_opposite=jnp.zeros(shape=ext_shape, dtype=dtype),\n            H_opposite=jnp.zeros(shape=ext_shape, dtype=dtype),\n        )\n        return boundary_state\n\n    def reset_state(self, state: PeriodicBoundaryState) -&gt; PeriodicBoundaryState:\n        new_state = PeriodicBoundaryState(\n            E_opposite=state.E_opposite * 0,\n            H_opposite=state.H_opposite * 0,\n        )\n        return new_state\n\n    def boundary_interface_grid_shape(self) -&gt; GridShape3D:\n        if self.axis == 0:\n            return 1, self.grid_shape[1], self.grid_shape[2]\n        elif self.axis == 1:\n            return self.grid_shape[0], 1, self.grid_shape[2]\n        elif self.axis == 2:\n            return self.grid_shape[0], self.grid_shape[1], 1\n        raise Exception(f\"Invalid axis: {self.axis=}\")\n\n    def boundary_interface_slice_tuple(self) -&gt; SliceTuple3D:\n        slice_list = [*self._grid_slice_tuple]\n        if self.direction == \"+\":\n            slice_list[self.axis] = (self._grid_slice_tuple[self.axis][0], self._grid_slice_tuple[self.axis][0] + 1)\n        elif self.direction == \"-\":\n            slice_list[self.axis] = (self._grid_slice_tuple[self.axis][1] - 1, self._grid_slice_tuple[self.axis][1])\n        return slice_list[0], slice_list[1], slice_list[2]\n\n    def boundary_interface_slice(self) -&gt; Slice3D:\n        slice_list = [*self.grid_slice]\n        if self.direction == \"+\":\n            slice_list[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][0], self._grid_slice_tuple[self.axis][0] + 1\n            )\n        elif self.direction == \"-\":\n            slice_list[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][1] - 1, self._grid_slice_tuple[self.axis][1]\n            )\n        return slice_list[0], slice_list[1], slice_list[2]\n\n    def update_E_boundary_state(\n        self,\n        boundary_state: PeriodicBoundaryState,\n        H: jax.Array,\n    ) -&gt; PeriodicBoundaryState:\n        # Get field values from opposite boundary\n        opposite_slice = list(self.grid_slice)\n        if self.direction == \"+\":\n            opposite_slice[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][1] - 1, self._grid_slice_tuple[self.axis][1]\n            )\n        else:\n            opposite_slice[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][0], self._grid_slice_tuple[self.axis][0] + 1\n            )\n\n        # Store H field values from opposite boundary\n        H_opposite = jnp.array(H[..., opposite_slice[0], opposite_slice[1], opposite_slice[2]])\n\n        return PeriodicBoundaryState(\n            E_opposite=boundary_state.E_opposite,  # Keep existing E values\n            H_opposite=H_opposite,  # Update H values\n        )\n\n    def update_H_boundary_state(\n        self,\n        boundary_state: PeriodicBoundaryState,\n        E: jax.Array,\n    ) -&gt; PeriodicBoundaryState:\n        # Get field values from opposite boundary\n        opposite_slice = list(self.grid_slice)\n        if self.direction == \"+\":\n            opposite_slice[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][1] - 1, self._grid_slice_tuple[self.axis][1]\n            )\n        else:\n            opposite_slice[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][0], self._grid_slice_tuple[self.axis][0] + 1\n            )\n\n        # Store E field values from opposite boundary\n        E_opposite = jnp.array(E[..., opposite_slice[0], opposite_slice[1], opposite_slice[2]])\n\n        return PeriodicBoundaryState(\n            E_opposite=E_opposite,  # Update E values\n            H_opposite=boundary_state.H_opposite,  # Keep existing H values\n        )\n\n    def update_E(\n        self,\n        E: jax.Array,\n        boundary_state: PeriodicBoundaryState,\n        inverse_permittivity: jax.Array,\n    ) -&gt; jax.Array:\n        del boundary_state, inverse_permittivity\n        # Get the boundary slice\n        boundary_slice = list(self.grid_slice)\n        if self.direction == \"+\":\n            boundary_slice[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][0], self._grid_slice_tuple[self.axis][0] + 1\n            )\n            # Copy from opposite boundary (last slice)\n            opposite_slice = list(self.grid_slice)\n            opposite_slice[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][1] - 1, self._grid_slice_tuple[self.axis][1]\n            )\n        else:\n            boundary_slice[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][1] - 1, self._grid_slice_tuple[self.axis][1]\n            )\n            # Copy from opposite boundary (first slice)\n            opposite_slice = list(self.grid_slice)\n            opposite_slice[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][0], self._grid_slice_tuple[self.axis][0] + 1\n            )\n\n        # Copy field values from opposite boundary\n        E = E.at[..., boundary_slice[0], boundary_slice[1], boundary_slice[2]].set(\n            E[..., opposite_slice[0], opposite_slice[1], opposite_slice[2]]\n        )\n\n        return E\n\n    def update_H(\n        self,\n        H: jax.Array,\n        boundary_state: PeriodicBoundaryState,\n        inverse_permeability: jax.Array | float,\n    ) -&gt; jax.Array:\n        del boundary_state, inverse_permeability\n        # Get the boundary slice\n        boundary_slice = list(self.grid_slice)\n        if self.direction == \"+\":\n            boundary_slice[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][0], self._grid_slice_tuple[self.axis][0] + 1\n            )\n            # Copy from opposite boundary (last slice)\n            opposite_slice = list(self.grid_slice)\n            opposite_slice[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][1] - 1, self._grid_slice_tuple[self.axis][1]\n            )\n        else:\n            boundary_slice[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][1] - 1, self._grid_slice_tuple[self.axis][1]\n            )\n            # Copy from opposite boundary (first slice)\n            opposite_slice = list(self.grid_slice)\n            opposite_slice[self.axis] = slice(\n                self._grid_slice_tuple[self.axis][0], self._grid_slice_tuple[self.axis][0] + 1\n            )\n\n        # Copy field values from opposite boundary\n        H = H.at[..., boundary_slice[0], boundary_slice[1], boundary_slice[2]].set(\n            H[..., opposite_slice[0], opposite_slice[1], opposite_slice[2]]\n        )\n\n        return H\n</code></pre>"},{"location":"api/objects/boundaries/#fdtdx.objects.boundaries.PeriodicBoundary.descriptive_name","title":"<code>descriptive_name: str</code>  <code>property</code>","text":"<p>Gets a human-readable name describing this periodic boundary's location.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Description like \"min_x\" or \"max_z\" indicating position</p>"},{"location":"api/objects/boundaries/#fdtdx.objects.boundaries.PeriodicBoundary.thickness","title":"<code>thickness: int</code>  <code>property</code>","text":"<p>Gets the thickness of the periodic boundary layer in grid points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of grid points in the boundary layer (always 1 for periodic)</p>"},{"location":"api/objects/detectors/","title":"Detectors","text":""},{"location":"api/objects/detectors/#_1","title":"Detectors","text":""},{"location":"api/objects/detectors/#detectors","title":"Detectors","text":"<p>In FDTDX, detectors can be used to perform measurements within a simulation. In conjunction with the Logger, these detectors can also automatically produce plots or even videos.</p>"},{"location":"api/objects/detectors/#fdtdx.objects.detectors.EnergyDetector","title":"<code>fdtdx.objects.detectors.EnergyDetector</code>","text":"<p>               Bases: <code>Detector</code></p> <p>Detector for measuring electromagnetic energy distribution.</p> <p>This detector computes and records the electromagnetic energy density at specified points in the simulation volume. It can operate in different modes to either record full 3D data, 2D slices, or reduced volume measurements.</p> <p>Attributes:</p> Name Type Description <code>as_slices</code> <code>bool</code> <p>If True, returns energy measurements as 2D slices through the volume.</p> <code>reduce_volume</code> <code>bool</code> <p>If True, reduces the volume data to a single energy value.</p> <code>x_slice,</code> <code>(y_slice, z_slice)</code> <p>Optional real-world positions for slice extraction.</p> <code>aggregate</code> <code>str | None</code> <p>If \"mean\", aggregates slices by averaging instead of using position.</p> Source code in <code>src/fdtdx/objects/detectors/energy.py</code> <pre><code>@extended_autoinit\nclass EnergyDetector(Detector):\n    \"\"\"Detector for measuring electromagnetic energy distribution.\n\n    This detector computes and records the electromagnetic energy density at specified\n    points in the simulation volume. It can operate in different modes to either record\n    full 3D data, 2D slices, or reduced volume measurements.\n\n    Attributes:\n        as_slices: If True, returns energy measurements as 2D slices through the volume.\n        reduce_volume: If True, reduces the volume data to a single energy value.\n        x_slice, y_slice, z_slice: Optional real-world positions for slice extraction.\n        aggregate: If \"mean\", aggregates slices by averaging instead of using position.\n    \"\"\"\n\n    as_slices: bool = False\n    reduce_volume: bool = False\n    x_slice: float | None = None\n    y_slice: float | None = None\n    z_slice: float | None = None\n    aggregate: str | None = None  # e.g., \"mean\"\n\n    def _shape_dtype_single_time_step(\n        self,\n    ) -&gt; dict[str, jax.ShapeDtypeStruct]:\n        if self.as_slices and self.reduce_volume:\n            raise Exception(\"Cannot both reduce volume and save slices!\")\n        gs = self.grid_shape\n        if self.as_slices:\n            return {\n                \"XY Plane\": jax.ShapeDtypeStruct((gs[0], gs[1]), self.dtype),\n                \"XZ Plane\": jax.ShapeDtypeStruct((gs[0], gs[2]), self.dtype),\n                \"YZ Plane\": jax.ShapeDtypeStruct((gs[1], gs[2]), self.dtype),\n            }\n        if self.reduce_volume:\n            return {\"energy\": jax.ShapeDtypeStruct((1,), self.dtype)}\n        return {\"energy\": jax.ShapeDtypeStruct(self.grid_shape, self.dtype)}\n\n    def update(\n        self,\n        time_step: jax.Array,\n        E: jax.Array,\n        H: jax.Array,\n        state: DetectorState,\n        inv_permittivity: jax.Array,\n        inv_permeability: jax.Array | float,\n    ) -&gt; DetectorState:\n        cur_E = E[:, *self.grid_slice]\n        cur_H = H[:, *self.grid_slice]\n        cur_inv_permittivity = inv_permittivity[self.grid_slice]\n        if isinstance(inv_permeability, jax.Array) and inv_permeability.ndim &gt; 0:\n            cur_inv_permeability = inv_permeability[self.grid_slice]\n        else:\n            cur_inv_permeability = inv_permeability\n\n        energy = compute_energy(\n            E=cur_E,\n            H=cur_H,\n            inv_permittivity=cur_inv_permittivity,\n            inv_permeability=cur_inv_permeability,\n        )\n\n        arr_idx = self._time_step_to_arr_idx[time_step]\n\n        if self.as_slices:\n            use_mean = self.aggregate == \"mean\" or any(\n                slice_ is None for slice_ in (self.x_slice, self.y_slice, self.z_slice)\n            )\n\n            if use_mean:\n                energy_xy = energy.mean(axis=2)\n                energy_xz = energy.mean(axis=1)\n                energy_yz = energy.mean(axis=0)\n            else:\n                # Convert real-world positions to indices\n                origin_x = self.grid_slice[0].start * self._config.resolution\n                origin_y = self.grid_slice[1].start * self._config.resolution\n                origin_z = self.grid_slice[2].start * self._config.resolution\n\n                def to_index(real_pos, origin, axis_len):\n                    if real_pos is not None:\n                        idx = int((real_pos - origin) / self._config.resolution)\n                        return max(0, min(idx, axis_len - 1))\n                    return axis_len // 2\n\n                x_idx = to_index(self.x_slice, origin_x, energy.shape[0])\n                y_idx = to_index(self.y_slice, origin_y, energy.shape[1])\n                z_idx = to_index(self.z_slice, origin_z, energy.shape[2])\n\n                energy_xy = energy[:, :, z_idx]\n                energy_xz = energy[:, y_idx, :]\n                energy_yz = energy[x_idx, :, :]\n\n            new_xy = state[\"XY Plane\"].at[arr_idx].set(energy_xy)\n            new_xz = state[\"XZ Plane\"].at[arr_idx].set(energy_xz)\n            new_yz = state[\"YZ Plane\"].at[arr_idx].set(energy_yz)\n\n            return {\n                \"XY Plane\": new_xy,\n                \"XZ Plane\": new_xz,\n                \"YZ Plane\": new_yz,\n            }\n\n        if self.reduce_volume:\n            total_energy = energy.sum()\n            new_arr = state[\"energy\"].at[arr_idx].set(total_energy)\n            return {\"energy\": new_arr}\n\n        new_arr = state[\"energy\"].at[arr_idx].set(energy)\n        return {\"energy\": new_arr}\n</code></pre>"},{"location":"api/objects/detectors/#fdtdx.objects.detectors.PoyntingFluxDetector","title":"<code>fdtdx.objects.detectors.PoyntingFluxDetector</code>","text":"<p>               Bases: <code>Detector</code></p> <p>Detector for measuring Poynting flux in electromagnetic simulations.</p> <p>This detector computes the Poynting flux (power flow) through a specified surface in the simulation volume. It can measure flux in either positive or negative direction along the propagation axis, and optionally reduce measurements to a single value by summing over the detection surface.</p> <p>Attributes:</p> Name Type Description <code>direction</code> <code>Literal['+', '-']</code> <p>Direction of flux measurement, either \"+\" for positive or \"-\" for negative along the propagation axis.</p> <code>reduce_volume</code> <code>bool</code> <p>If True, reduces measurements to a single value by summing over the detection surface. If False, maintains spatial distribution.</p> <code>fixed_propagation_axis</code> <code>int | None</code> <p>By default, the propagation axis for calculating the poynting flux is the axis, where the detector has a grid shape of 1. If the detector has a shape of 1 in more than one axes or a different axis should be used, then this attribute can/has to be set.</p> <code>keep_all_components</code> <code>bool</code> <p>By default, only the poynting flux component for the propagation axis is returned (scalar). with this option, all three vector components are returned.</p> Source code in <code>src/fdtdx/objects/detectors/poynting_flux.py</code> <pre><code>@extended_autoinit\nclass PoyntingFluxDetector(Detector):\n    \"\"\"Detector for measuring Poynting flux in electromagnetic simulations.\n\n    This detector computes the Poynting flux (power flow) through a specified surface\n    in the simulation volume. It can measure flux in either positive or negative\n    direction along the propagation axis, and optionally reduce measurements to a\n    single value by summing over the detection surface.\n\n    Attributes:\n        direction: Direction of flux measurement, either \"+\" for positive or \"-\" for\n            negative along the propagation axis.\n        reduce_volume: If True, reduces measurements to a single value by summing\n            over the detection surface. If False, maintains spatial distribution.\n        fixed_propagation_axis: By default, the propagation axis for calculating the poynting flux is the axis, where\n            the detector has a grid shape of 1. If the detector has a shape of 1 in more than one axes or a different\n            axis should be used, then this attribute can/has to be set.\n        keep_all_components: By default, only the poynting flux component for the propagation axis is returned (scalar).\n            with this option, all three vector components are returned.\n    \"\"\"\n\n    direction: Literal[\"+\", \"-\"] = frozen_field(kind=\"KW_ONLY\")  # type: ignore\n    reduce_volume: bool = True\n    fixed_propagation_axis: int | None = None\n    keep_all_components: bool = False\n\n    @property\n    def propagation_axis(self) -&gt; int:\n        \"\"\"Determines the axis along which Poynting flux is measured.\n\n        The propagation axis is identified as the dimension with size 1 in the\n        detector's grid shape, representing a plane perpendicular to the flux\n        measurement direction.\n\n        Returns:\n            int: Index of the propagation axis (0 for x, 1 for y, 2 for z)\n\n        Raises:\n            Exception: If detector shape does not have exactly one dimension of size 1\n        \"\"\"\n        if self.fixed_propagation_axis is not None:\n            if self.fixed_propagation_axis not in [0, 1, 2]:\n                raise Exception(f\"Invalid: {self.fixed_propagation_axis=}\")\n            return self.fixed_propagation_axis\n        if sum([a == 1 for a in self.grid_shape]) != 1:\n            raise Exception(f\"Invalid poynting flux detector shape: {self.grid_shape}\")\n        return self.grid_shape.index(1)\n\n    def _shape_dtype_single_time_step(\n        self,\n    ) -&gt; dict[str, jax.ShapeDtypeStruct]:\n        if self.keep_all_components:\n            shape = (3,) if self.reduce_volume else (3, *self.grid_shape)\n        else:\n            shape = (1,) if self.reduce_volume else self.grid_shape\n        return {\"poynting_flux\": jax.ShapeDtypeStruct(shape, self.dtype)}\n\n    def update(\n        self,\n        time_step: jax.Array,\n        E: jax.Array,\n        H: jax.Array,\n        state: DetectorState,\n        inv_permittivity: jax.Array,\n        inv_permeability: jax.Array | float,\n    ) -&gt; DetectorState:\n        del inv_permeability, inv_permittivity\n        cur_E = E[:, *self.grid_slice]\n        cur_H = H[:, *self.grid_slice]\n\n        pf = poynting_flux(cur_E, cur_H)\n        if not self.keep_all_components:\n            pf = pf[self.propagation_axis]\n        if self.direction == \"-\":\n            pf = -pf\n        if self.reduce_volume:\n            if self.keep_all_components:\n                pf = pf.sum(axis=(1, 2, 3))\n            else:\n                pf = pf.sum()\n        arr_idx = self._time_step_to_arr_idx[time_step]\n        new_full_arr = state[\"poynting_flux\"].at[arr_idx].set(pf)\n        new_state = {\"poynting_flux\": new_full_arr}\n        return new_state\n</code></pre>"},{"location":"api/objects/detectors/#fdtdx.objects.detectors.PoyntingFluxDetector.propagation_axis","title":"<code>propagation_axis: int</code>  <code>property</code>","text":"<p>Determines the axis along which Poynting flux is measured.</p> <p>The propagation axis is identified as the dimension with size 1 in the detector's grid shape, representing a plane perpendicular to the flux measurement direction.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the propagation axis (0 for x, 1 for y, 2 for z)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If detector shape does not have exactly one dimension of size 1</p>"},{"location":"api/objects/detectors/#fdtdx.objects.detectors.PhasorDetector","title":"<code>fdtdx.objects.detectors.PhasorDetector</code>","text":"<p>               Bases: <code>Detector</code></p> <p>Detector for measuring frequency components of electromagnetic fields using an efficient Phasor Implementation.</p> <p>This detector computes complex phasor representations of the field components at specified frequencies, enabling frequency-domain analysis of the electromagnetic fields. The amplitude and phase of the original phase can be reconstructed using jnp.abs(phasor) and jnp.angle(phasor). The reconstruction itself can then be achieved using amplitude * jnp.cos(2 * jnp.pi * freq * t - phase).</p> <p>Attributes:</p> Name Type Description <code>wave_characters</code> <code>Sequence[WaveCharacter]</code> <p>Sequence of WaveCharacters to analyze</p> <code>reduce_volume</code> <code>bool</code> <p>If True, reduces the volume of recorded data.</p> <code>components</code> <code>Sequence[Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']]</code> <p>Sequence of field components to measure. Can include any of: \"Ex\", \"Ey\", \"Ez\", \"Hx\", \"Hy\", \"Hz\".</p> Source code in <code>src/fdtdx/objects/detectors/phasor.py</code> <pre><code>@extended_autoinit\nclass PhasorDetector(Detector):\n    \"\"\"Detector for measuring frequency components of electromagnetic fields using an efficient Phasor Implementation.\n\n    This detector computes complex phasor representations of the field components at specified\n    frequencies, enabling frequency-domain analysis of the electromagnetic fields.\n    The amplitude and phase of the original phase can be reconstructed using jnp.abs(phasor) and jnp.angle(phasor).\n    The reconstruction itself can then be achieved using amplitude * jnp.cos(2 * jnp.pi * freq * t - phase).\n\n    Attributes:\n        wave_characters: Sequence of WaveCharacters to analyze\n        reduce_volume: If True, reduces the volume of recorded data.\n        components: Sequence of field components to measure. Can include any of:\n            \"Ex\", \"Ey\", \"Ez\", \"Hx\", \"Hy\", \"Hz\".\n    \"\"\"\n\n    wave_characters: Sequence[WaveCharacter] = field()\n    reduce_volume: bool = False\n    components: Sequence[Literal[\"Ex\", \"Ey\", \"Ez\", \"Hx\", \"Hy\", \"Hz\"]] = frozen_field(\n        default=(\"Ex\", \"Ey\", \"Ez\", \"Hx\", \"Hy\", \"Hz\"),\n    )\n    dtype: jnp.dtype = frozen_field(\n        default=jnp.complex64,\n        kind=\"KW_ONLY\",\n    )\n    plot: bool = False\n\n    def __post_init__(\n        self,\n    ):\n        if self.dtype not in [jnp.complex64, jnp.complex128]:\n            raise Exception(f\"Invalid dtype in PhasorDetector: {self.dtype}\")\n\n    @property\n    def _angular_frequencies(self) -&gt; jax.Array:\n        freqs = [wc.frequency for wc in self.wave_characters]\n        return 2 * jnp.pi * jnp.array(freqs)\n\n    def _num_latent_time_steps(self) -&gt; int:\n        return 1\n\n    def _shape_dtype_single_time_step(\n        self,\n    ) -&gt; dict[str, jax.ShapeDtypeStruct]:\n        field_dtype = jnp.complex128 if self.dtype == jnp.float64 else jnp.complex64\n        num_components = len(self.components)\n        num_frequencies = len(self._angular_frequencies)\n        grid_shape = self.grid_shape if not self.reduce_volume else tuple([])\n        phasor_shape = (num_frequencies, num_components, *grid_shape)\n        return {\"phasor\": jax.ShapeDtypeStruct(shape=phasor_shape, dtype=field_dtype)}\n\n    def update(\n        self,\n        time_step: jax.Array,\n        E: jax.Array,\n        H: jax.Array,\n        state: DetectorState,\n        inv_permittivity: jax.Array,\n        inv_permeability: jax.Array | float,\n    ) -&gt; DetectorState:\n        del inv_permeability, inv_permittivity\n        time_passed = time_step * self._config.time_step_duration\n        static_scale = 2 / self.num_time_steps_recorded\n\n        E, H = E[:, *self.grid_slice], H[:, *self.grid_slice]\n        fields = []\n        if \"Ex\" in self.components:\n            fields.append(E[0])\n        if \"Ey\" in self.components:\n            fields.append(E[1])\n        if \"Ez\" in self.components:\n            fields.append(E[2])\n        if \"Hx\" in self.components:\n            fields.append(H[0])\n        if \"Hy\" in self.components:\n            fields.append(H[1])\n        if \"Hz\" in self.components:\n            fields.append(H[2])\n\n        EH = jnp.stack(fields, axis=0)\n\n        # Vectorized phasor calculation for all frequencies\n        phase_angles = self._angular_frequencies[:, None] * time_passed  # Shape: (num_freqs, 1)\n        phasors = jnp.exp(1j * phase_angles)  # Shape: (num_freqs, 1)\n        new_phasors = EH[None, ...] * phasors[..., None] * static_scale  # Broadcasting handles the multiplication\n\n        if self.reduce_volume:\n            # Average over all spatial dimensions\n            spatial_axes = tuple(range(2, new_phasors.ndim))  # Skip freq and component axes\n            new_phasors = new_phasors.mean(axis=spatial_axes) if spatial_axes else new_phasors\n\n        if self.inverse:\n            result = state[\"phasor\"] - new_phasors[None, ...]\n        else:\n            result = state[\"phasor\"] + new_phasors[None, ...]\n        return {\"phasor\": result.astype(self.dtype)}\n</code></pre>"},{"location":"api/objects/detectors/#fdtdx.objects.detectors.DiffractiveDetector","title":"<code>fdtdx.objects.detectors.DiffractiveDetector</code>","text":"<p>               Bases: <code>Detector</code></p> <p>Detector for computing Fourier transforms of fields at specific frequencies and diffraction orders.</p> <p>This detector computes field amplitudes for specific diffraction orders and frequencies through a specified plane in the simulation volume. It can measure diffraction in either positive or negative direction along the propagation axis.</p> <p>Attributes:</p> Name Type Description <code>frequencies</code> <code>Sequence[float]</code> <p>List of frequencies to analyze (in Hz)</p> <code>orders</code> <code>Sequence[Tuple[int, int]]</code> <p>Tuple of (nx, ny) pairs specifying diffraction orders to compute</p> <code>direction</code> <code>Literal['+', '-']</code> <p>Direction of diffraction analysis (\"+\" or \"-\") along propagation axis</p> Source code in <code>src/fdtdx/objects/detectors/diffractive.py</code> <pre><code>@extended_autoinit\nclass DiffractiveDetector(Detector):\n    \"\"\"Detector for computing Fourier transforms of fields at specific frequencies and diffraction orders.\n\n    This detector computes field amplitudes for specific diffraction orders and frequencies through\n    a specified plane in the simulation volume. It can measure diffraction in either positive or negative\n    direction along the propagation axis.\n\n    Attributes:\n        frequencies: List of frequencies to analyze (in Hz)\n        orders: Tuple of (nx, ny) pairs specifying diffraction orders to compute\n        direction: Direction of diffraction analysis (\"+\" or \"-\") along propagation axis\n    \"\"\"\n\n    frequencies: Sequence[float] = field(kind=\"KW_ONLY\")  # type: ignore\n    orders: Sequence[Tuple[int, int]] = ((0, 0),)\n    direction: Literal[\"+\", \"-\"] = frozen_field(kind=\"KW_ONLY\")  # type: ignore\n    dtype: jnp.dtype = frozen_field(default=jnp.complex64, kind=\"KW_ONLY\")\n\n    def __post_init__(self):\n        if self.dtype not in [jnp.complex64, jnp.complex128]:\n            raise Exception(f\"Invalid dtype in DiffractiveDetector: {self.dtype}\")\n\n    @property\n    def propagation_axis(self) -&gt; int:\n        \"\"\"Determines the axis along which diffraction is measured.\n\n        The propagation axis is identified as the dimension with size 1 in the\n        detector's grid shape, representing a plane perpendicular to the diffraction\n        measurement direction.\n\n        Returns:\n            int: Index of the propagation axis (0 for x, 1 for y, 2 for z)\n\n        Raises:\n            Exception: If detector shape does not have exactly one dimension of size 1\n        \"\"\"\n        if sum([a == 1 for a in self.grid_shape]) != 1:\n            raise Exception(f\"Invalid diffractive detector shape: {self.grid_shape}\")\n        return self.grid_shape.index(1)\n\n    # def _validate_orders(self, wavelength: float) -&gt; None:\n    #     \"\"\"Validate that requested diffraction orders are physically realizable.\n\n    #     Args:\n    #         wavelength: Wavelength of the light in meters\n\n    #     Raises:\n    #         Exception: If any requested order is not physically realizable\n    #     \"\"\"\n    #     if self._Nx is None:\n    #         raise Exception(\"Order info not yet computed. Run update first.\")\n\n    #     # Maximum possible orders based on grid\n    #     max_nx = self._Nx // 2\n    #     max_ny = self._Ny // 2\n\n    #     # Check Nyquist limits for all orders at once\n    #     nx_valid = jnp.all(jnp.abs(jnp.array([o[0] for o in self.orders])) &lt;= max_nx)\n    #     ny_valid = jnp.all(jnp.abs(jnp.array([o[1] for o in self.orders])) &lt;= max_ny)\n\n    #     if not (nx_valid and ny_valid):\n    #         raise Exception(f\"Some orders exceed Nyquist limit for grid size ({self._Nx}, {self._Ny})\")\n\n    #     # Check physical realizability for all orders at once\n    #     k0 = 2 * jnp.pi / wavelength\n    #     kt_squared = self._kx_normalized**2 + self._ky_normalized**2\n\n    #     if jnp.any(kt_squared &gt; k0**2):\n    #         raise Exception(f\"Some orders are evanescent at wavelength {wavelength*1e9:.1f}nm\")\n\n    def _shape_dtype_single_time_step(self) -&gt; dict[str, jax.ShapeDtypeStruct]:\n        num_freqs = len(self.frequencies)\n        num_orders = len(self.orders)\n\n        shape = (num_freqs, num_orders)\n\n        # Ensure we're using a complex dtype\n        field_dtype = jnp.complex128 if self.dtype == jnp.float64 else jnp.complex64\n        return {\"diffractive\": jax.ShapeDtypeStruct(shape=shape, dtype=field_dtype)}\n\n    def _num_latent_time_steps(self) -&gt; int:\n        return 1\n\n    def update(\n        self,\n        time_step: jax.Array,\n        E: jax.Array,\n        H: jax.Array,\n        state: DetectorState,\n        inv_permittivity: jax.Array,\n        inv_permeability: jax.Array | float,\n    ) -&gt; DetectorState:\n        del inv_permittivity, inv_permeability\n\n        # Get grid dimensions for the plane perpendicular to propagation axis\n        prop_axis = self.propagation_axis\n        plane_dims = [i for i in range(3) if i != prop_axis]\n        Nx, Ny = [self.grid_shape[i] for i in plane_dims]\n\n        # Get current field values at the specified plane\n        cur_E = E[:, *self.grid_slice]  # Shape: (3, nx, ny, 1)\n        cur_H = H[:, *self.grid_slice]  # Shape: (3, nx, ny, 1)\n\n        # Remove the normal axis dimension since it should be 1\n        cur_E = jnp.squeeze(cur_E, axis=prop_axis + 1)  # Shape: (3, nx, ny)\n        cur_H = jnp.squeeze(cur_H, axis=prop_axis + 1)  # Shape: (3, nx, ny)\n\n        # Compute FFT of each field component\n        E_k = jnp.fft.fft2(cur_E, axes=tuple(d + 1 for d in plane_dims))  # FFT in spatial dimensions\n        H_k = jnp.fft.fft2(cur_H, axes=tuple(d + 1 for d in plane_dims))\n\n        # Convert orders to array for vectorization\n        orders = jnp.array(self.orders)  # Shape: (num_orders, 2)\n\n        # Compute FFT indices for all orders\n        kx_indices = jnp.where(orders[:, 0] &gt;= 0, orders[:, 0], Nx + orders[:, 0])\n        ky_indices = jnp.where(orders[:, 1] &gt;= 0, orders[:, 1], Ny + orders[:, 1])\n\n        # Compute wavevectors\n        dx = dy = self._config.resolution\n        kx = 2 * jnp.pi * jnp.fft.fftfreq(Nx, dx)\n        ky = 2 * jnp.pi * jnp.fft.fftfreq(Ny, dy)\n        k0 = 2 * jnp.pi * self.frequencies[0] / constants.c  # Use first frequency for now\n\n        # For each requested order, compute the diffracted power\n        order_amplitudes = []\n        for kx_idx, ky_idx in zip(kx_indices, ky_indices):\n            # Get the field components for this k-point\n            E_order = E_k[:, kx_idx, ky_idx]\n            H_order = H_k[:, kx_idx, ky_idx]\n\n            # Compute kz for propagating waves\n            kz = jnp.sqrt(k0**2 - kx[kx_idx] ** 2 - ky[ky_idx] ** 2 + 0j)\n            k_vec = jnp.array([kx[kx_idx], ky[ky_idx], kz])\n\n            # Project fields to be transverse to k\n            E_t = E_order - jnp.dot(E_order, k_vec) * k_vec / jnp.dot(k_vec, k_vec)\n            H_t = H_order - jnp.dot(H_order, k_vec) * k_vec / jnp.dot(k_vec, k_vec)\n\n            # Compute power in this order\n            P_order = jnp.abs(jnp.cross(E_t, jnp.conj(H_t)).sum())\n            if self.direction == \"-\":\n                P_order = -P_order\n            order_amplitudes.append(P_order)\n\n        order_amplitudes = jnp.array(order_amplitudes)\n\n        # Time domain analysis - vectorized for all frequencies\n        t = time_step * self._config.time_step_duration\n        angular_frequencies = 2 * jnp.pi * jnp.array(self.frequencies)\n        phase_angles = angular_frequencies[:, None] * t  # Shape: (num_freqs, 1)\n        phasors = jnp.exp(-1j * phase_angles)  # Shape: (num_freqs, 1)\n\n        # Compute all frequency components for all orders at once\n        order_amplitudes = order_amplitudes[None, :]  # Shape: (1, num_orders)\n        new_values = order_amplitudes * phasors  # Shape: (num_freqs, num_orders)\n\n        # Update state\n        arr_idx = self._time_step_to_arr_idx[time_step]\n        new_state = state.copy()\n        new_state[\"diffractive\"] = new_state[\"diffractive\"].at[arr_idx].set(new_values)\n\n        return new_state\n</code></pre>"},{"location":"api/objects/detectors/#fdtdx.objects.detectors.DiffractiveDetector.propagation_axis","title":"<code>propagation_axis: int</code>  <code>property</code>","text":"<p>Determines the axis along which diffraction is measured.</p> <p>The propagation axis is identified as the dimension with size 1 in the detector's grid shape, representing a plane perpendicular to the diffraction measurement direction.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the propagation axis (0 for x, 1 for y, 2 for z)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If detector shape does not have exactly one dimension of size 1</p>"},{"location":"api/objects/device/","title":"Device","text":""},{"location":"api/objects/device/#_1","title":"Device","text":""},{"location":"api/objects/device/#devices","title":"Devices","text":"<p>In FDTDX, devices are objects whose shape can be optimized. A device has a corresponding set of latent parameters, which are mapped to produce the current shape of the device. </p>"},{"location":"api/objects/device/#fdtdx.objects.device.DiscreteDevice","title":"<code>fdtdx.objects.device.DiscreteDevice</code>","text":"<p>               Bases: <code>BaseDevice</code></p> <p>A device with discrete material states.</p> <p>This class represents a simulation object whose permittivity distribution can be optimized through gradient-based methods, with discrete transitions between materials. The permittivity values are controlled by parameters that are mapped through constraints to produce the final device structure.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>Optional name identifier for the device</p> <code>constraint_mapping</code> <p>Maps optimization parameters to permittivity values</p> <code>dtype</code> <p>Data type for device parameters, defaults to float32</p> <code>color</code> <p>RGB color tuple for visualization, defaults to pink</p> Source code in <code>src/fdtdx/objects/device/device.py</code> <pre><code>@extended_autoinit\nclass DiscreteDevice(BaseDevice):\n    \"\"\"A device with discrete material states.\n\n    This class represents a simulation object whose permittivity distribution can be\n    optimized through gradient-based methods, with discrete transitions between materials.\n    The permittivity values are controlled by parameters that are mapped through constraints\n    to produce the final device structure.\n\n    Attributes:\n        name: Optional name identifier for the device\n        constraint_mapping: Maps optimization parameters to permittivity values\n        dtype: Data type for device parameters, defaults to float32\n        color: RGB color tuple for visualization, defaults to pink\n    \"\"\"\n\n    material: dict[str, Material] = frozen_field(kind=\"KW_ONLY\")  # type: ignore\n    parameter_mapping: DiscreteParameterMapping = frozen_field(kind=\"KW_ONLY\")  # type:ignore\n\n    def place_on_grid(\n        self: Self,\n        grid_slice_tuple: SliceTuple3D,\n        config: SimulationConfig,\n        key: jax.Array,\n    ) -&gt; Self:\n        self = super().place_on_grid(\n            grid_slice_tuple=grid_slice_tuple,\n            config=config,\n            key=key,\n        )\n        mapping = self.parameter_mapping.init_modules(\n            config=config,\n            material=self.material,\n            output_shape_dtype=jax.ShapeDtypeStruct(\n                shape=self.matrix_voxel_grid_shape,\n                dtype=jnp.int32,\n            ),\n        )\n        self = self.aset(\"parameter_mapping\", mapping)\n        return self\n</code></pre>"},{"location":"api/objects/device/#parameter-mapping","title":"Parameter Mapping","text":""},{"location":"api/objects/device/#fdtdx.objects.device.DiscreteParameterMapping","title":"<code>fdtdx.objects.device.DiscreteParameterMapping</code>","text":"<p>               Bases: <code>LatentParameterMapping</code></p> Source code in <code>src/fdtdx/objects/device/parameters/mapping.py</code> <pre><code>@extended_autoinit\nclass DiscreteParameterMapping(LatentParameterMapping):\n    discretization: Discretization = frozen_field(kind=\"KW_ONLY\", default=ClosestIndex())\n    post_transforms: Sequence[DiscreteTransformation] = frozen_field(default=tuple([]), kind=\"KW_ONLY\")\n\n    def init_modules(\n        self: Self,\n        config: SimulationConfig,\n        material: dict[str, Material],\n        output_shape_dtype: jax.ShapeDtypeStruct,\n    ) -&gt; Self:\n        new_post_transforms = []\n        for t in self.post_transforms:\n            cur_transform = t.init_module(\n                config=config,\n                material=material,\n            )\n            new_post_transforms.append(cur_transform)\n        new_discretization = self.discretization.init_module(\n            config=config,\n            material=material,\n            output_shape_dtype=output_shape_dtype,\n        )\n\n        new_latent_transforms = []\n        cur_output_shape_dtype = new_discretization._input_shape_dtypes\n        for m in self.latent_transforms:\n            m_new = m.init_module(\n                config=config,\n                material=material,\n                output_shape_dtypes=cur_output_shape_dtype,\n            )\n            new_latent_transforms.append(m_new)\n            cur_output_shape_dtype = m_new._input_shape_dtypes\n        self = super().init_modules(\n            config=config,\n            material=material,\n            output_shape_dtypes=cur_output_shape_dtype,\n        )\n        self = self.aset(\"latent_transforms\", new_latent_transforms)\n        self = self.aset(\"discretization\", new_discretization)\n        self = self.aset(\"post_transforms\", new_post_transforms)\n        return self\n\n    def __call__(\n        self,\n        input_params: dict[str, jax.Array] | jax.Array,\n    ) -&gt; jax.Array:\n        latent = super().__call__(\n            input_params=input_params,\n        )\n        discretized = self.discretization(latent)\n        cur_arr = discretized\n        for transform in self.post_transforms:\n            cur_arr = transform(cur_arr)\n        return cur_arr\n</code></pre>"},{"location":"api/objects/device/#tranformation-of-latent-parameters","title":"Tranformation of latent parameters","text":""},{"location":"api/objects/device/#fdtdx.objects.device.StandardToInversePermittivityRange","title":"<code>fdtdx.objects.device.StandardToInversePermittivityRange</code>","text":"<p>               Bases: <code>SameShapeDtypeLatentTransform</code></p> <p>Maps standard [0,1] range to inverse permittivity range.</p> <p>Linearly maps values from [0,1] to the range between minimum and maximum inverse permittivity values allowed by the material configuration.</p> Source code in <code>src/fdtdx/objects/device/parameters/latent.py</code> <pre><code>@extended_autoinit\nclass StandardToInversePermittivityRange(SameShapeDtypeLatentTransform):\n    \"\"\"Maps standard [0,1] range to inverse permittivity range.\n\n    Linearly maps values from [0,1] to the range between minimum and maximum\n    inverse permittivity values allowed by the material configuration.\n    \"\"\"\n\n    def transform(\n        self,\n        input_params: dict[str, jax.Array] | jax.Array,\n    ) -&gt; dict[str, jax.Array] | jax.Array:\n        # determine minimum and maximum allowed permittivity\n        max_inv_perm, min_inv_perm = -math.inf, math.inf\n        if isinstance(self._material, dict):\n            for k, v in self._material.items():\n                p = 1 / v.permittivity\n                if p &gt; max_inv_perm:\n                    max_inv_perm = p\n                if p &lt; min_inv_perm:\n                    min_inv_perm = p\n        elif isinstance(self._material, ContinuousMaterialRange):\n            start_perm = self._material.start_material.permittivity\n            end_perm = self._material.end_material.permittivity\n            max_inv_perm = max(start_perm, end_perm)\n            min_inv_perm = min(start_perm, end_perm)\n\n        # transform\n        if isinstance(input_params, dict):\n            result = {}\n            for k, v in input_params.items():\n                mapped = v * (max_inv_perm - min_inv_perm) + min_inv_perm\n                result[k] = mapped\n        else:\n            result = input_params * (max_inv_perm - min_inv_perm) + min_inv_perm\n        return result\n</code></pre>"},{"location":"api/objects/device/#fdtdx.objects.device.StandardToPlusOneMinusOneRange","title":"<code>fdtdx.objects.device.StandardToPlusOneMinusOneRange</code>","text":"<p>               Bases: <code>StandardToCustomRange</code></p> <p>Maps standard [0,1] range to [-1,1] range.</p> <p>Special case of StandardToCustomRange that maps to [-1,1] range. Used for symmetric value ranges around zero.</p> <p>Attributes:</p> Name Type Description <code>min_value</code> <code>float</code> <p>Fixed to -1</p> <code>max_value</code> <code>float</code> <p>Fixed to 1</p> Source code in <code>src/fdtdx/objects/device/parameters/latent.py</code> <pre><code>@extended_autoinit\nclass StandardToPlusOneMinusOneRange(StandardToCustomRange):\n    \"\"\"Maps standard [0,1] range to [-1,1] range.\n\n    Special case of StandardToCustomRange that maps to [-1,1] range.\n    Used for symmetric value ranges around zero.\n\n    Attributes:\n        min_value: Fixed to -1\n        max_value: Fixed to 1\n    \"\"\"\n\n    min_value: float = frozen_field(default=-1, init=False)\n    max_value: float = frozen_field(default=1, init=False)\n</code></pre>"},{"location":"api/objects/device/#fdtdx.objects.device.StandardToCustomRange","title":"<code>fdtdx.objects.device.StandardToCustomRange</code>","text":"<p>               Bases: <code>SameShapeDtypeLatentTransform</code></p> <p>Maps standard [0,1] range to custom range [min_value, max_value].</p> <p>Linearly maps values from [0,1] to a custom range specified by min_value and max_value parameters.</p> <p>Attributes:</p> Name Type Description <code>min_value</code> <code>float</code> <p>Minimum value of target range</p> <code>max_value</code> <code>float</code> <p>Maximum value of target range</p> Source code in <code>src/fdtdx/objects/device/parameters/latent.py</code> <pre><code>@extended_autoinit\nclass StandardToCustomRange(SameShapeDtypeLatentTransform):\n    \"\"\"Maps standard [0,1] range to custom range [min_value, max_value].\n\n    Linearly maps values from [0,1] to a custom range specified by min_value\n    and max_value parameters.\n\n    Attributes:\n        min_value: Minimum value of target range\n        max_value: Maximum value of target range\n    \"\"\"\n\n    min_value: float = frozen_field(default=0)\n    max_value: float = frozen_field(default=1)\n\n    def transform(\n        self,\n        input_params: dict[str, jax.Array] | jax.Array,\n    ) -&gt; dict[str, jax.Array] | jax.Array:\n        if isinstance(input_params, dict):\n            result = {}\n            for k, v in input_params.items():\n                mapped = v * (self.max_value - self.min_value) + self.min_value\n                result[k] = mapped\n        else:\n            result = input_params * (self.max_value - self.min_value) + self.min_value\n        return result\n</code></pre>"},{"location":"api/objects/device/#discretizations","title":"Discretizations","text":""},{"location":"api/objects/device/#fdtdx.objects.device.ClosestIndex","title":"<code>fdtdx.objects.device.ClosestIndex</code>","text":"<p>               Bases: <code>Discretization</code></p> <p>Maps continuous latent values to nearest allowed material indices.</p> <p>For each input value, finds the index of the closest allowed inverse permittivity value. Uses straight-through gradient estimation to maintain differentiability.</p> Source code in <code>src/fdtdx/objects/device/parameters/discretization.py</code> <pre><code>@extended_autoinit\nclass ClosestIndex(Discretization):\n    \"\"\"Maps continuous latent values to nearest allowed material indices.\n\n    For each input value, finds the index of the closest allowed inverse\n    permittivity value. Uses straight-through gradient estimation to maintain\n    differentiability.\n    \"\"\"\n\n    def __call__(\n        self,\n        input_params: dict[str, jax.Array] | jax.Array,\n    ) -&gt; jax.Array:\n        if not isinstance(input_params, jax.Array):\n            raise Exception(\"Closest Index cannot be used with latent parameters that contain multiple entries\")\n        arr = input_params\n        allowed_inv_perms = 1 / jnp.asarray(compute_allowed_permittivities(self._material))\n        dist = jnp.abs(arr[..., None] - allowed_inv_perms)\n        discrete = jnp.argmin(dist, axis=-1)\n        result = straight_through_estimator(arr, discrete)\n        return result\n</code></pre>"},{"location":"api/objects/device/#fdtdx.objects.device.PillarDiscretization","title":"<code>fdtdx.objects.device.PillarDiscretization</code>","text":"<p>               Bases: <code>Discretization</code></p> <p>Constraint module for mapping pillar structures to allowed configurations.</p> <p>Maps arbitrary pillar structures to the nearest allowed configurations based on material constraints and geometry requirements. Ensures structures meet fabrication rules like single polymer columns and no trapped air holes.</p> <p>Attributes:</p> Name Type Description <code>axis</code> <code>int</code> <p>Axis along which to enforce pillar constraints (0=x, 1=y, 2=z).</p> <code>single_polymer_columns</code> <code>bool</code> <p>If True, restrict to single polymer columns.</p> <code>distance_metric</code> <code>Literal['euclidean', 'permittivity_differences_plus_average_permittivity']</code> <p>Method to compute distances between material distributions: - \"euclidean\": Standard Euclidean distance between permittivity values - \"permittivity_differences_plus_average_permittivity\": Weighted combination   of permittivity differences and average permittivity values, optimized   for material distribution comparisons</p> Source code in <code>src/fdtdx/objects/device/parameters/discretization.py</code> <pre><code>@extended_autoinit\nclass PillarDiscretization(Discretization):\n    \"\"\"Constraint module for mapping pillar structures to allowed configurations.\n\n    Maps arbitrary pillar structures to the nearest allowed configurations based on\n    material constraints and geometry requirements. Ensures structures meet fabrication\n    rules like single polymer columns and no trapped air holes.\n\n    Attributes:\n        axis: Axis along which to enforce pillar constraints (0=x, 1=y, 2=z).\n        single_polymer_columns: If True, restrict to single polymer columns.\n        distance_metric: Method to compute distances between material distributions:\n            - \"euclidean\": Standard Euclidean distance between permittivity values\n            - \"permittivity_differences_plus_average_permittivity\": Weighted combination\n              of permittivity differences and average permittivity values, optimized\n              for material distribution comparisons\n    \"\"\"\n\n    axis: int = frozen_field(kind=\"KW_ONLY\")\n    single_polymer_columns: bool = frozen_field(kind=\"KW_ONLY\")\n\n    distance_metric: Literal[\"euclidean\", \"permittivity_differences_plus_average_permittivity\"] = frozen_field(\n        default=\"permittivity_differences_plus_average_permittivity\",\n    )\n    _allowed_indices: jax.Array = frozen_private_field()\n\n    def init_module(\n        self: Self,\n        config: SimulationConfig,\n        material: dict[str, Material],\n        output_shape_dtype: jax.ShapeDtypeStruct,\n    ) -&gt; Self:\n        self = super().init_module(\n            config=config,\n            material=material,\n            output_shape_dtype=output_shape_dtype,\n        )\n        air_name = get_air_name(self._material)\n        ordered_name_list = compute_ordered_names(self._material)\n        air_idx = ordered_name_list.index(air_name)\n\n        allowed_columns = compute_allowed_indices(\n            num_layers=output_shape_dtype.shape[self.axis],\n            indices=list(range(len(material))),\n            fill_holes_with_index=[air_idx],\n            single_polymer_columns=self.single_polymer_columns,\n        )\n        self = self.aset(\"_allowed_indices\", allowed_columns)\n        logger.info(f\"{allowed_columns=}\")\n        logger.info(f\"{allowed_columns.shape=}\")\n        return self\n\n    def __call__(\n        self,\n        input_params: dict[str, jax.Array] | jax.Array,\n    ) -&gt; jax.Array:\n        if not isinstance(input_params, jax.Array):\n            raise Exception(\"BrushConstraint2D cannot be used with latent parameters that contain multiple entries\")\n\n        allowed_inv_perms = 1 / jnp.asarray(compute_allowed_permittivities(self._material))\n\n        nearest_allowed_index = nearest_index(\n            values=input_params,\n            allowed_values=allowed_inv_perms,\n            axis=self.axis,\n            distance_metric=self.distance_metric,\n            allowed_indices=self._allowed_indices,\n            return_distances=False,\n        )\n        result_index = self._allowed_indices[nearest_allowed_index]\n        if self.axis == 2:\n            pass  # no transposition needed\n        elif self.axis == 1:\n            result_index = jnp.transpose(result_index, axes=(0, 2, 1))\n        elif self.axis == 0:\n            result_index = jnp.transpose(result_index, axes=(2, 0, 1))\n        else:\n            raise Exception(f\"invalid axis: {self.axis}\")\n        result_index = straight_through_estimator(input_params, result_index)\n        return result_index\n</code></pre>"},{"location":"api/objects/device/#fdtdx.objects.device.BrushConstraint2D","title":"<code>fdtdx.objects.device.BrushConstraint2D</code>","text":"<p>               Bases: <code>Discretization</code></p> <p>Applies 2D brush-based constraints to ensure minimum feature sizes.</p> <p>Implements the brush-based constraint method described in: https://pubs.acs.org/doi/10.1021/acsphotonics.2c00313</p> <p>This ensures minimum feature sizes and connectivity in 2D designs by using morphological operations with a brush kernel.</p> <p>Attributes:</p> Name Type Description <code>brush</code> <code>Array</code> <p>JAX array defining the brush kernel for morphological operations.</p> <code>axis</code> <code>int</code> <p>Axis along which to apply the 2D constraint (perpendicular plane).</p> Source code in <code>src/fdtdx/objects/device/parameters/discretization.py</code> <pre><code>@extended_autoinit\nclass BrushConstraint2D(Discretization):\n    \"\"\"Applies 2D brush-based constraints to ensure minimum feature sizes.\n\n    Implements the brush-based constraint method described in:\n    https://pubs.acs.org/doi/10.1021/acsphotonics.2c00313\n\n    This ensures minimum feature sizes and connectivity in 2D designs by using\n    morphological operations with a brush kernel.\n\n    Attributes:\n        brush: JAX array defining the brush kernel for morphological operations.\n        axis: Axis along which to apply the 2D constraint (perpendicular plane).\n    \"\"\"\n\n    brush: jax.Array = frozen_field()\n    axis: int = frozen_field()\n\n    def __call__(\n        self,\n        input_params: dict[str, jax.Array] | jax.Array,\n    ) -&gt; jax.Array:\n        if not isinstance(input_params, jax.Array):\n            raise Exception(\"BrushConstraint2D cannot be used with latent parameters that contain multiple entries\")\n        if len(self._material) &gt; 2:\n            raise Exception(\"BrushConstraint2D currently only implemented for single material and air\")\n        s = input_params.shape\n        if len(s) != 3:\n            raise Exception(f\"BrushConstraint2D Generator can only work with 2D-Arrays, got {s=}\")\n        if s[self.axis] != 1:\n            raise Exception(f\"BrushConstraint2D Generator needs array size 1 in axis, but got {s=}\")\n        arr_2d = jnp.take(\n            input_params,\n            jnp.asarray(0),\n            axis=self.axis,\n        )\n\n        cur_result = 1 - self._generator(arr_2d)\n\n        air_name = get_air_name(self._material)\n        ordered_name_list = compute_ordered_names(self._material)\n        air_idx = ordered_name_list.index(air_name)\n        if air_idx != 0:\n            cur_result = 1 - cur_result\n        cur_result = jnp.expand_dims(cur_result, axis=self.axis)\n        result = straight_through_estimator(input_params, cur_result)\n        return result\n\n    def _generator(\n        self,\n        arr: jax.Array,\n    ) -&gt; jax.Array:\n        touches_void = jnp.zeros_like(arr, dtype=jnp.bool)\n        touches_solid = jnp.zeros_like(touches_void)\n\n        def cond_fn(arrs):\n            touch_v, touch_s = arrs[0], arrs[1]\n            pixel_existing_solid = dilate_jax(touch_s, self.brush)\n            pixel_existing_void = dilate_jax(touch_v, self.brush)\n            return ~jnp.all(pixel_existing_solid | pixel_existing_void)\n\n        def body_fn(sv_arrs: tuple[jax.Array, jax.Array]):\n            # see Algorithm 1 in paper\n            touch_v, touch_s = sv_arrs[0], sv_arrs[1]\n            # compute touches and pixel arrays\n            pixel_existing_solid = dilate_jax(touch_s, self.brush)\n            pixel_existing_void = dilate_jax(touch_v, self.brush)\n            touch_impossible_solid = dilate_jax(pixel_existing_void, self.brush)\n            touch_impossible_void = dilate_jax(pixel_existing_solid, self.brush)\n            touch_valid_solid = ~touch_impossible_solid &amp; ~touch_s\n            touch_valid_void = ~touch_impossible_void &amp; ~touch_v\n            pixel_possible_solid = dilate_jax(touch_s | touch_valid_solid, self.brush)\n            pixel_possible_void = dilate_jax(touch_v | touch_valid_void, self.brush)\n            pixel_required_solid = ~pixel_existing_solid &amp; ~pixel_possible_void\n            pixel_required_void = ~pixel_existing_void &amp; ~pixel_possible_solid\n            touch_resolving_solid = dilate_jax(pixel_required_solid, self.brush) &amp; touch_valid_solid\n            touch_resolving_void = dilate_jax(pixel_required_void, self.brush) &amp; touch_valid_void\n            touch_free_solid = ~dilate_jax(pixel_possible_void | pixel_existing_void, self.brush) &amp; touch_valid_solid\n            touch_free_void = ~dilate_jax(pixel_possible_solid | pixel_existing_solid, self.brush) &amp; touch_valid_void\n\n            # case 1\n            def select_all_free_touches():\n                new_v = touch_v | touch_free_void\n                new_s = touch_s | touch_free_solid\n                return new_v, new_s\n\n            # case 2\n            def select_best_resolving_touch():\n                values_solid = jnp.where(touch_resolving_solid, arr, -jnp.inf)\n                values_void = jnp.where(touch_resolving_void, -arr, -jnp.inf)\n\n                def select_void():\n                    max_idx = jnp.argmax(values_void)\n                    new_v = touch_v.flatten().at[max_idx].set(True).reshape(touch_s.shape)\n                    return new_v, touch_s\n\n                def select_solid():\n                    max_idx = jnp.argmax(values_solid)\n                    new_s = touch_s.flatten().at[max_idx].set(True).reshape(touch_v.shape)\n                    return touch_v, new_s\n\n                return jax.lax.cond(\n                    jnp.max(values_solid) &gt; jnp.max(values_void),\n                    select_solid,\n                    select_void,\n                )\n\n            # case 3\n            def select_best_valid_touch():\n                values_solid = jnp.where(touch_valid_solid, arr, -jnp.inf)\n                values_void = jnp.where(touch_valid_void, -arr, -jnp.inf)\n\n                def select_void():\n                    max_idx = jnp.argmax(values_void)\n                    new_v = touch_v.flatten().at[max_idx].set(True).reshape(touch_s.shape)\n                    return new_v, touch_s\n\n                def select_solid():\n                    max_idx = jnp.argmax(values_solid)\n                    new_s = touch_s.flatten().at[max_idx].set(True).reshape(touch_v.shape)\n                    return touch_v, new_s\n\n                return jax.lax.cond(\n                    jnp.max(values_solid) &gt; jnp.max(values_void),\n                    select_solid,\n                    select_void,\n                )\n\n            # case 2 and 3\n            def case_2_and_3_function():\n                resolving_exists = jnp.any(touch_resolving_solid | touch_resolving_void)\n\n                return jax.lax.cond(\n                    resolving_exists,\n                    select_best_resolving_touch,\n                    select_best_valid_touch,\n                )\n\n            free_touches_exist = jnp.any(touch_free_solid | touch_free_void)\n            new_v, new_s = jax.lax.cond(\n                free_touches_exist,\n                select_all_free_touches,\n                case_2_and_3_function,\n            )\n            return new_v, new_s\n\n        arrs = (touches_void, touches_solid)\n\n        res_arrs = eqxi.while_loop(\n            cond_fun=cond_fn,\n            body_fun=body_fn,\n            init_val=arrs,\n            kind=\"lax\",\n        )\n        pixel_existing_solid = dilate_jax(res_arrs[1], self.brush)\n        return pixel_existing_solid\n</code></pre>"},{"location":"api/objects/device/#fdtdx.objects.device.circular_brush","title":"<code>fdtdx.objects.device.circular_brush(diameter, size=None)</code>","text":"<p>Creates a circular binary mask/brush for morphological operations.</p> <p>Parameters:</p> Name Type Description Default <code>diameter</code> <code>float</code> <p>Diameter of the circle in grid units.</p> required <code>size</code> <code>int | None</code> <p>Optional size of the output array. If None, uses ceil(diameter) rounded up to next odd number.</p> <code>None</code> <p>Returns:</p> Type Description <code>Array</code> <p>Binary JAX array containing a circular mask where True indicates points</p> <code>Array</code> <p>within the circle diameter.</p> Source code in <code>src/fdtdx/objects/device/parameters/discretization.py</code> <pre><code>def circular_brush(\n    diameter: float,\n    size: int | None = None,\n) -&gt; jax.Array:\n    \"\"\"Creates a circular binary mask/brush for morphological operations.\n\n    Args:\n        diameter: Diameter of the circle in grid units.\n        size: Optional size of the output array. If None, uses ceil(diameter) rounded\n            up to next odd number.\n\n    Returns:\n        Binary JAX array containing a circular mask where True indicates points\n        within the circle diameter.\n    \"\"\"\n    if size is None:\n        s = math.ceil(diameter)\n        if s % 2 == 0:\n            s += 1\n        size = s\n    xy = jnp.stack(jnp.meshgrid(*map(jnp.arange, (size, size)), indexing=\"xy\"), axis=-1) - jnp.asarray((size / 2) - 0.5)\n    euc_dist = jnp.sqrt((xy**2).sum(axis=-1))\n    # the less EQUAL here is important, because otherwise design may be infeasible due to discretization errors\n    mask = euc_dist &lt;= (diameter / 2)\n    return mask\n</code></pre>"},{"location":"api/objects/device/#discrete-postprocessing","title":"Discrete PostProcessing","text":""},{"location":"api/objects/device/#fdtdx.objects.device.BinaryMedianFilterModule","title":"<code>fdtdx.objects.device.BinaryMedianFilterModule</code>","text":"<p>               Bases: <code>DiscreteTransformation</code></p> <p>Performs 3D binary median filtering on the design.</p> <p>Applies a 3D median filter to smooth and clean up binary material distributions. This helps remove small features and noise while preserving larger structures.</p> <p>Attributes:</p> Name Type Description <code>padding_cfg</code> <code>PaddingConfig</code> <p>Configuration for padding behavior at boundaries.</p> <code>kernel_sizes</code> <code>tuple[int, int, int]</code> <p>3-tuple of kernel sizes for each dimension.</p> <code>num_repeats</code> <code>int</code> <p>Number of times to apply the filter consecutively.</p> Source code in <code>src/fdtdx/objects/device/parameters/discrete.py</code> <pre><code>@extended_autoinit\nclass BinaryMedianFilterModule(DiscreteTransformation):\n    \"\"\"Performs 3D binary median filtering on the design.\n\n    Applies a 3D median filter to smooth and clean up binary material distributions.\n    This helps remove small features and noise while preserving larger structures.\n\n    Attributes:\n        padding_cfg: Configuration for padding behavior at boundaries.\n        kernel_sizes: 3-tuple of kernel sizes for each dimension.\n        num_repeats: Number of times to apply the filter consecutively.\n    \"\"\"\n\n    padding_cfg: PaddingConfig = frozen_field()\n    kernel_sizes: tuple[int, int, int] = frozen_field()\n    num_repeats: int = frozen_field(default=1)\n\n    def __call__(\n        self,\n        material_indices: jax.Array,\n    ) -&gt; jax.Array:\n        if len(self._material) != 2:\n            raise Exception(\"BinaryMedianFilterModule only works for two materials!\")\n        cur_arr = material_indices\n        for _ in range(self.num_repeats):\n            cur_arr = binary_median_filter(\n                arr_3d=cur_arr,\n                kernel_sizes=self.kernel_sizes,\n                padding_cfg=self.padding_cfg,\n            )\n        result = straight_through_estimator(material_indices, cur_arr)\n        return result\n</code></pre>"},{"location":"api/objects/device/#fdtdx.objects.device.ConnectHolesAndStructures","title":"<code>fdtdx.objects.device.ConnectHolesAndStructures</code>","text":"<p>               Bases: <code>DiscreteTransformation</code></p> <p>Connects floating polymer regions and ensures air holes connect to outside.</p> <p>This constraint module ensures physical realizability of designs by: 1. Either connecting floating polymer regions to the substrate or removing them 2. Ensuring all air holes are connected to the outside (no trapped air)</p> <p>The bottom (lower z) is treated as the substrate reference.</p> <p>Attributes:</p> Name Type Description <code>fill_material</code> <code>str | None</code> <p>Name of material to use for filling gaps when connecting regions. Required when working with more than 2 materials.</p> Source code in <code>src/fdtdx/objects/device/parameters/discrete.py</code> <pre><code>@extended_autoinit\nclass ConnectHolesAndStructures(DiscreteTransformation):\n    \"\"\"Connects floating polymer regions and ensures air holes connect to outside.\n\n    This constraint module ensures physical realizability of designs by:\n    1. Either connecting floating polymer regions to the substrate or removing them\n    2. Ensuring all air holes are connected to the outside (no trapped air)\n\n    The bottom (lower z) is treated as the substrate reference.\n\n    Attributes:\n        fill_material: Name of material to use for filling gaps when connecting regions.\n            Required when working with more than 2 materials.\n    \"\"\"\n\n    fill_material: str | None = frozen_field(default=None)\n\n    def __call__(\n        self,\n        material_indices: jax.Array,\n    ) -&gt; jax.Array:\n        if len(self._material) &gt; 2 and self.fill_material is None:\n            raise Exception(\n                \"ConnectHolesAndStructures: Need to specify fill material when working with more than a single material\"\n            )\n        air_name = get_air_name(self._material)\n        ordered_name_list = compute_ordered_names(self._material)\n        air_idx = ordered_name_list.index(air_name)\n        is_material_matrix = material_indices != air_idx\n        feasible_material_matrix = connect_holes_and_structures(is_material_matrix)\n\n        result = jnp.empty_like(material_indices)\n        # set air\n        result = jnp.where(\n            feasible_material_matrix,\n            -1,  # this is set below\n            air_idx,\n        )\n        # material where previously was material\n        result = jnp.where(feasible_material_matrix &amp; is_material_matrix, material_indices, result)\n\n        # material, where previously was air\n        fill_name = self.fill_material\n        if fill_name is None:\n            fill_name = ordered_name_list[1 - air_idx]\n        fill_idx = ordered_name_list.index(fill_name)\n        result = jnp.where(\n            feasible_material_matrix &amp; ~is_material_matrix,\n            fill_idx,\n            result,\n        )\n        return result\n</code></pre>"},{"location":"api/objects/device/#fdtdx.objects.device.RemoveFloatingMaterial","title":"<code>fdtdx.objects.device.RemoveFloatingMaterial</code>","text":"<p>               Bases: <code>DiscreteTransformation</code></p> <p>Finds all material that floats in the air and sets their permittivity to air.</p> <p>This constraint module identifies regions of material that are not connected to any substrate or boundary and converts them to air. This helps ensure physically realizable designs by eliminating floating/disconnected material regions.</p> <p>The module only works with binary material systems (2 permittivities) where one material represents air.</p> Source code in <code>src/fdtdx/objects/device/parameters/discrete.py</code> <pre><code>@extended_autoinit\nclass RemoveFloatingMaterial(DiscreteTransformation):\n    \"\"\"Finds all material that floats in the air and sets their permittivity to air.\n\n    This constraint module identifies regions of material that are not connected to any\n    substrate or boundary and converts them to air. This helps ensure physically\n    realizable designs by eliminating floating/disconnected material regions.\n\n    The module only works with binary material systems (2 permittivities) where one\n    material represents air.\n    \"\"\"\n\n    def __call__(\n        self,\n        material_indices: jax.Array,\n    ) -&gt; jax.Array:\n        if len(self._material) != 2:\n            raise NotImplementedError(\"Remove floating material currently only implemented for single material\")\n        air_name = get_air_name(self._material)\n        ordered_name_list = compute_ordered_names(self._material)\n        air_idx = ordered_name_list.index(air_name)\n\n        is_material_matrix = material_indices != air_idx\n        is_material_after_removal = remove_floating_polymer(is_material_matrix)\n        result = (1 - air_idx) * is_material_after_removal + air_idx * ~is_material_after_removal\n        result = straight_through_estimator(material_indices, result)\n        return result\n</code></pre>"},{"location":"api/objects/device/#fdtdx.objects.device.BinaryMedianFilterModule","title":"<code>fdtdx.objects.device.BinaryMedianFilterModule</code>","text":"<p>               Bases: <code>DiscreteTransformation</code></p> <p>Performs 3D binary median filtering on the design.</p> <p>Applies a 3D median filter to smooth and clean up binary material distributions. This helps remove small features and noise while preserving larger structures.</p> <p>Attributes:</p> Name Type Description <code>padding_cfg</code> <code>PaddingConfig</code> <p>Configuration for padding behavior at boundaries.</p> <code>kernel_sizes</code> <code>tuple[int, int, int]</code> <p>3-tuple of kernel sizes for each dimension.</p> <code>num_repeats</code> <code>int</code> <p>Number of times to apply the filter consecutively.</p> Source code in <code>src/fdtdx/objects/device/parameters/discrete.py</code> <pre><code>@extended_autoinit\nclass BinaryMedianFilterModule(DiscreteTransformation):\n    \"\"\"Performs 3D binary median filtering on the design.\n\n    Applies a 3D median filter to smooth and clean up binary material distributions.\n    This helps remove small features and noise while preserving larger structures.\n\n    Attributes:\n        padding_cfg: Configuration for padding behavior at boundaries.\n        kernel_sizes: 3-tuple of kernel sizes for each dimension.\n        num_repeats: Number of times to apply the filter consecutively.\n    \"\"\"\n\n    padding_cfg: PaddingConfig = frozen_field()\n    kernel_sizes: tuple[int, int, int] = frozen_field()\n    num_repeats: int = frozen_field(default=1)\n\n    def __call__(\n        self,\n        material_indices: jax.Array,\n    ) -&gt; jax.Array:\n        if len(self._material) != 2:\n            raise Exception(\"BinaryMedianFilterModule only works for two materials!\")\n        cur_arr = material_indices\n        for _ in range(self.num_repeats):\n            cur_arr = binary_median_filter(\n                arr_3d=cur_arr,\n                kernel_sizes=self.kernel_sizes,\n                padding_cfg=self.padding_cfg,\n            )\n        result = straight_through_estimator(material_indices, cur_arr)\n        return result\n</code></pre>"},{"location":"api/objects/object/","title":"Objects","text":""},{"location":"api/objects/object/#_1","title":"Objects","text":""},{"location":"api/objects/object/#core-classes","title":"Core Classes","text":"<p>Base class for all simulation objects with positioning and sizing capabilities. All Objects in FDTDX are cuboid shaped by default, but with multi-material objects more complicated shapes can be realized as well.</p> <p>An object of cuboid shape describing the size and default background material of the simulation volume.</p> <p>An object that has a uniform material throughout its entire volume.</p>"},{"location":"api/objects/object/#fdtdx.objects.object.SimulationObject","title":"<code>fdtdx.objects.object.SimulationObject</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code>, <code>ABC</code></p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>@extended_autoinit\nclass SimulationObject(ExtendedTreeClass, ABC):\n    partial_real_shape: PartialRealShape3D = frozen_field(default=UNDEFINED_SHAPE_3D)\n    partial_grid_shape: PartialGridShape3D = frozen_field(default=UNDEFINED_SHAPE_3D)\n    color: tuple[float, float, float] | None = frozen_field(default=None)  # RGB, interval[0, 1]\n    name: str = frozen_field(  # type: ignore\n        default=None,\n        on_setattr=[UniqueName()],\n    )\n    max_random_real_offsets: tuple[float, float, float] = frozen_field(default=(0, 0, 0))\n    max_random_grid_offsets: tuple[int, int, int] = frozen_field(default=(0, 0, 0))\n\n    _grid_slice_tuple: SliceTuple3D = frozen_private_field(\n        default=INVALID_SLICE_TUPLE_3D,\n    )\n    _config: SimulationConfig = frozen_private_field(default=DUMMY_SIMULATION_CONFIG)\n\n    @property\n    def grid_slice_tuple(self) -&gt; SliceTuple3D:\n        if self._grid_slice_tuple == INVALID_SLICE_TUPLE_3D:\n            raise Exception(f\"Object is not yet initialized: {self}\")\n        return self._grid_slice_tuple\n\n    @property\n    def grid_slice(self) -&gt; Slice3D:\n        tpl = ensure_slice_tuple(self._grid_slice_tuple)\n        if len(tpl) != 3:\n            raise Exception(f\"Invalid slice tuple, this should never happen: {tpl}\")\n        return tpl[0], tpl[1], tpl[2]\n\n    @property\n    def real_shape(self) -&gt; RealShape3D:\n        grid_shape = self.grid_shape\n        real_shape = (\n            grid_shape[0] * self._config.resolution,\n            grid_shape[1] * self._config.resolution,\n            grid_shape[2] * self._config.resolution,\n        )\n        return real_shape\n\n    @property\n    def grid_shape(self) -&gt; GridShape3D:\n        if self._grid_slice_tuple == INVALID_SLICE_TUPLE_3D:\n            raise Exception(\"Cannot compute shape on non-initialized object\")\n        return (\n            self._grid_slice_tuple[0][1] - self._grid_slice_tuple[0][0],\n            self._grid_slice_tuple[1][1] - self._grid_slice_tuple[1][0],\n            self._grid_slice_tuple[2][1] - self._grid_slice_tuple[2][0],\n        )\n\n    def place_on_grid(\n        self: Self,\n        grid_slice_tuple: SliceTuple3D,\n        config: SimulationConfig,\n        key: jax.Array,\n    ) -&gt; Self:\n        del key\n        if self._grid_slice_tuple != INVALID_SLICE_TUPLE_3D:\n            raise Exception(f\"Object is already compiled to grid: {self}\")\n        for axis in range(3):\n            s1, s2 = grid_slice_tuple[axis]\n            if s1 &lt; 0 or s2 &lt; 0 or s2 &lt;= s1:\n                raise Exception(f\"Invalid placement of object {self} at {grid_slice_tuple}\")\n        self = self.aset(\"_grid_slice_tuple\", grid_slice_tuple)\n        self = self.aset(\"_config\", config)\n\n        return self\n\n    def place_relative_to(\n        self,\n        other: \"SimulationObject\",\n        axes: tuple[int, ...] | int,\n        own_positions: tuple[float, ...] | float,\n        other_positions: tuple[float, ...] | float,\n        margins: tuple[float, ...] | float | None = None,\n        grid_margins: tuple[int, ...] | int | None = None,\n    ) -&gt; PositionConstraint:\n        \"\"\"Creates a PositionalConstraint between two objects. The constraint is defined by anchor points on\n        both objects, which are constrainted to be at the same position. Anchors are defined in relative coordinates,\n        i.e. a position of -1 is the left object boundary in the repective axis and a position of +1 the right boundary.\n\n        Args:\n            other: Another object in the simulation scene\n            axes: Eiter a single integer or a tuple describing the axes of the constraints\n            own_positions: The positions of the own anchor in the axes. Must have the same lengths as axes\n            other_positions: The positions of the other objects' anchor in the axes. Must have the same lengths as axes\n            margins: The margins between the anchors of both objects in meters. Must have the same lengths as axes. Defaults to no margin\n            grid_margins: The margins between the anchors of both objects in Yee-grid voxels. Must have the same lengths as axes. Defaults to no margin\n\n        Returns:\n            PositionConstraint: Positional constraint between this object and the other\n        \"\"\"\n        if isinstance(axes, int):\n            axes = (axes,)\n        if isinstance(own_positions, int | float):\n            own_positions = (float(own_positions),)\n        if isinstance(other_positions, int | float):\n            other_positions = (float(other_positions),)\n        if isinstance(margins, int | float):\n            margins = (float(margins),)\n        if isinstance(grid_margins, int):\n            grid_margins = (grid_margins,)\n        if margins is None:\n            margins = tuple([0 for _ in axes])\n        if grid_margins is None:\n            grid_margins = tuple([0 for _ in axes])\n        if (\n            len(axes) != len(own_positions)\n            or len(axes) != len(other_positions)\n            or len(axes) != len(margins)\n            or len(axes) != len(grid_margins)\n        ):\n            raise Exception(\"All inputs should have same lengths\")\n        constraint = PositionConstraint(\n            axes=axes,\n            other_object=other,\n            object=self,\n            other_object_positions=other_positions,\n            object_positions=own_positions,\n            margins=margins,\n            grid_margins=grid_margins,\n        )\n        return constraint\n\n    def size_relative_to(\n        self,\n        other: \"SimulationObject\",\n        axes: tuple[int, ...] | int,\n        other_axes: tuple[int, ...] | int | None = None,\n        proportions: tuple[float, ...] | float | None = None,\n        offsets: tuple[float, ...] | float | None = None,\n        grid_offsets: tuple[int, ...] | int | None = None,\n    ) -&gt; SizeConstraint:\n        \"\"\"Creates a SizeConstraint between two objects. The constraint defines the size of this object relative\n        to another object, allowing for proportional scaling and offsets in specified axes.\n\n        Args:\n            other: Another object in the simulation scene\n            axes: Either a single integer or a tuple describing which axes of this object to constrain\n            other_axes: Either a single integer or a tuple describing which axes of the other object to reference.\n                If None, uses the same axes as specified in 'axes'\n            proportions: Scale factors to apply to the other object's dimensions. Must have same length as axes.\n                If None, defaults to 1.0 (same size)\n            offsets: Additional size offsets in meters to apply after scaling. Must have same length as axes.\n                If None, defaults to 0\n            grid_offsets: Additional size offsets in Yee-grid voxels to apply after scaling. Must have same length as axes.\n                If None, defaults to 0\n\n        Returns:\n            SizeConstraint: Size constraint between this object and the other\n        \"\"\"\n        if isinstance(axes, int):\n            axes = (axes,)\n        if isinstance(other_axes, int):\n            other_axes = (other_axes,)\n        if isinstance(proportions, int | float):\n            proportions = (float(proportions),)\n        if isinstance(offsets, int | float):\n            offsets = (offsets,)\n        if isinstance(grid_offsets, int):\n            grid_offsets = (grid_offsets,)\n        if offsets is None:\n            offsets = tuple([0 for _ in axes])\n        if grid_offsets is None:\n            grid_offsets = tuple([0 for _ in axes])\n        if proportions is None:\n            proportions = tuple([1.0 for _ in axes])\n        if other_axes is None:\n            other_axes = tuple([a for a in axes])\n        if len(axes) != len(proportions) or len(axes) != len(offsets) or len(axes) != len(grid_offsets):\n            raise Exception(\"All inputs should have same lengths\")\n        constraint = SizeConstraint(\n            other_object=other,\n            object=self,\n            axes=axes,\n            other_axes=other_axes,\n            proportions=proportions,\n            offsets=offsets,\n            grid_offsets=grid_offsets,\n        )\n        return constraint\n\n    def same_size(\n        self,\n        other: \"SimulationObject\",\n        axes: tuple[int, ...] | int = (0, 1, 2),\n        offsets: tuple[float, ...] | float | None = None,\n        grid_offsets: tuple[int, ...] | int | None = None,\n    ) -&gt; SizeConstraint:\n        \"\"\"Creates a SizeConstraint that makes this object the same size as another object along specified axes.\n        This is a convenience wrapper around size_relative_to() with proportions set to 1.0.\n\n        Args:\n            other: Another object in the simulation scene\n            axes: Either a single integer or a tuple describing which axes should have the same size.\n                Defaults to all axes (0, 1, 2)\n            offsets: Additional size offsets in meters to apply. Must have same length as axes.\n                If None, defaults to 0\n            grid_offsets: Additional size offsets in Yee-grid voxels to apply. Must have same length as axes.\n                If None, defaults to 0\n\n        Returns:\n            SizeConstraint: Size constraint ensuring equal sizes between objects\n        \"\"\"\n        if isinstance(axes, int):\n            axes = (axes,)\n        proportions = tuple([1 for _ in axes])\n        constraint = self.size_relative_to(\n            other=other,\n            axes=axes,\n            proportions=proportions,\n            offsets=offsets,\n            grid_offsets=grid_offsets,\n        )\n        return constraint\n\n    def place_at_center(\n        self,\n        other: \"SimulationObject\",\n        axes: tuple[int, ...] | int = (0, 1, 2),\n        own_positions: tuple[float, ...] | float | None = None,\n        other_positions: tuple[float, ...] | float | None = None,\n        margins: tuple[float, ...] | float | None = None,\n        grid_margins: tuple[int, ...] | int | None = None,\n    ) -&gt; PositionConstraint:\n        \"\"\"Creates a PositionConstraint that centers this object relative to another object along specified axes.\n        This is a convenience wrapper around place_relative_to() with default positions at the center (0).\n\n        Args:\n            other: Another object in the simulation scene\n            axes: Either a single integer or a tuple describing which axes to center on.\n                Defaults to all axes (0, 1, 2)\n            own_positions: Relative positions on this object (-1 to 1). If None, defaults to center (0)\n            other_positions: Relative positions on other object (-1 to 1). If None, defaults to center (0)\n            margins: Additional margins in meters between objects. Must have same length as axes.\n                If None, defaults to 0\n            grid_margins: Additional margins in Yee-grid voxels between objects. Must have same length as axes.\n                If None, defaults to 0\n\n        Returns:\n            PositionConstraint: Position constraint centering objects relative to each other\n        \"\"\"\n        if isinstance(axes, int):\n            axes = (axes,)\n        if own_positions is None:\n            own_positions = tuple([0 for _ in axes])\n        if other_positions is None:\n            other_positions = tuple([0 for _ in axes])\n        constraint = self.place_relative_to(\n            other=other,\n            axes=axes,\n            own_positions=own_positions,\n            other_positions=other_positions,\n            margins=margins,\n            grid_margins=grid_margins,\n        )\n        return constraint\n\n    def same_position_and_size(\n        self,\n        other: \"SimulationObject\",\n        axes: tuple[int, ...] | int = (0, 1, 2),\n    ) -&gt; tuple[PositionConstraint, SizeConstraint]:\n        \"\"\"Creates both position and size constraints to make this object match another object's position and size.\n        This is a convenience wrapper combining place_at_center() and same_size().\n\n        Args:\n            other: Another object in the simulation scene\n            axes: Either a single integer or a tuple describing which axes to match.\n                Defaults to all axes (0, 1, 2)\n\n        Returns:\n            tuple[PositionConstraint, SizeConstraint]: Position and size constraints for matching objects\n        \"\"\"\n        size_constraint = self.same_size(\n            other=other,\n            axes=axes,\n        )\n        pos_constraint = self.place_at_center(\n            other=other,\n            axes=axes,\n        )\n        return pos_constraint, size_constraint\n\n    def face_to_face_positive_direction(\n        self,\n        other: \"SimulationObject\",\n        axes: tuple[int, ...] | int,\n        margins: tuple[float, ...] | float | None = None,\n        grid_margins: tuple[int, ...] | int | None = None,\n    ) -&gt; PositionConstraint:\n        \"\"\"Creates a PositionConstraint that places this object facing another object in the positive direction\n        of specified axes. The objects will touch at their facing boundaries unless margins are specified.\n\n        Args:\n            other: Another object in the simulation scene\n            axes: Either a single integer or a tuple describing which axes to align on\n            margins: Additional margins in meters between the facing surfaces. Must have same length as axes.\n                If None, defaults to 0\n            grid_margins: Additional margins in Yee-grid voxels between the facing surfaces.\n                Must have same length as axes. If None, defaults to 0\n\n        Returns:\n            PositionConstraint: Position constraint aligning objects face-to-face in positive direction\n        \"\"\"\n        if isinstance(axes, int):\n            axes = (axes,)\n        own_positions = tuple([-1 for _ in axes])\n        other_positions = tuple([1 for _ in axes])\n        constraint = self.place_relative_to(\n            other=other,\n            axes=axes,\n            own_positions=own_positions,\n            other_positions=other_positions,\n            margins=margins,\n            grid_margins=grid_margins,\n        )\n        return constraint\n\n    def face_to_face_negative_direction(\n        self,\n        other: \"SimulationObject\",\n        axes: tuple[int, ...] | int,\n        margins: tuple[float, ...] | float | None = None,\n        grid_margins: tuple[int, ...] | int | None = None,\n    ) -&gt; PositionConstraint:\n        \"\"\"Creates a PositionConstraint that places this object facing another object in the negative direction\n        of specified axes. The objects will touch at their facing boundaries unless margins are specified.\n\n        Args:\n            other: Another object in the simulation scene\n            axes: Either a single integer or a tuple describing which axes to align on\n            margins: Additional margins in meters between the facing surfaces. Must have same length as axes.\n                If None, defaults to 0\n            grid_margins: Additional margins in Yee-grid voxels between the facing surfaces.\n                Must have same length as axes. If None, defaults to 0\n\n        Returns:\n            PositionConstraint: Position constraint aligning objects face-to-face in negative direction\n        \"\"\"\n        if isinstance(axes, int):\n            axes = (axes,)\n        own_positions = tuple([1 for _ in axes])\n        other_positions = tuple([-1 for _ in axes])\n        constraint = self.place_relative_to(\n            other=other,\n            axes=axes,\n            own_positions=own_positions,\n            other_positions=other_positions,\n            margins=margins,\n            grid_margins=grid_margins,\n        )\n        return constraint\n\n    def place_above(\n        self,\n        other: \"SimulationObject\",\n        margins: tuple[float, ...] | float | None = None,\n        grid_margins: tuple[int, ...] | int | None = None,\n    ) -&gt; PositionConstraint:\n        \"\"\"Creates a PositionConstraint that places this object above another object along the z-axis.\n        This is a convenience wrapper around face_to_face_positive_direction() for axis 2 (z-axis).\n\n        Args:\n            other: Another object in the simulation scene\n            margins: Additional vertical margins in meters between objects. If None, defaults to 0\n            grid_margins: Additional vertical margins in Yee-grid voxels between objects.\n                If None, defaults to 0\n\n        Returns:\n            PositionConstraint: Position constraint placing this object above the other\n        \"\"\"\n        constraint = self.face_to_face_positive_direction(\n            other=other,\n            axes=(2,),\n            margins=margins,\n            grid_margins=grid_margins,\n        )\n        return constraint\n\n    def place_below(\n        self,\n        other: \"SimulationObject\",\n        margins: tuple[float, ...] | float | None = None,\n        grid_margins: tuple[int, ...] | int | None = None,\n    ) -&gt; PositionConstraint:\n        \"\"\"Creates a PositionConstraint that places this object below another object along the z-axis.\n        This is a convenience wrapper around face_to_face_negative_direction() for axis 2 (z-axis).\n\n        Args:\n            other: Another object in the simulation scene\n            margins: Additional vertical margins in meters between objects. If None, defaults to 0\n            grid_margins: Additional vertical margins in Yee-grid voxels between objects.\n                If None, defaults to 0\n\n        Returns:\n            PositionConstraint: Position constraint placing this object below the other\n        \"\"\"\n        constraint = self.face_to_face_negative_direction(\n            other=other,\n            axes=(2,),\n            margins=margins,\n            grid_margins=grid_margins,\n        )\n        return constraint\n\n    def set_grid_coordinates(\n        self,\n        axes: tuple[int, ...] | int,\n        sides: tuple[Literal[\"+\", \"-\"], ...] | Literal[\"+\", \"-\"],\n        coordinates: tuple[int, ...] | int,\n    ) -&gt; GridCoordinateConstraint:\n        \"\"\"Creates a GridCoordinateConstraint that forces specific sides of this object to align with\n        given grid coordinates. Used for precise positioning in the discretized simulation space.\n\n        Args:\n            axes: Either a single integer or a tuple describing which axes to constrain\n            sides: Either a single string or a tuple of strings ('+' or '-') indicating which side\n                of each axis to constrain. Must have same length as axes\n            coordinates: Either a single integer or a tuple of integers specifying the grid coordinates\n                to align with. Must have same length as axes\n\n        Returns:\n            GridCoordinateConstraint: Constraint forcing alignment with specific grid coordinates\n        \"\"\"\n        if isinstance(axes, int):\n            axes = (axes,)\n        if isinstance(sides, str):\n            sides = (sides,)\n        if isinstance(coordinates, int):\n            coordinates = (coordinates,)\n        if len(axes) != len(sides) or len(axes) != len(coordinates):\n            raise Exception(\"All inputs need to have the same lengths!\")\n        return GridCoordinateConstraint(\n            object=self,\n            axes=axes,\n            sides=sides,\n            coordinates=coordinates,\n        )\n\n    def set_real_coordinates(\n        self,\n        axes: tuple[int, ...] | int,\n        sides: tuple[Literal[\"+\", \"-\"], ...] | Literal[\"+\", \"-\"],\n        coordinates: tuple[float, ...] | float,\n    ) -&gt; RealCoordinateConstraint:\n        \"\"\"Creates a RealCoordinateConstraint that forces specific sides of this object to align with\n        given real-space coordinates. Used for precise positioning in physical units.\n\n        Args:\n            axes: Either a single integer or a tuple describing which axes to constrain\n            sides: Either a single string or a tuple of strings ('+' or '-') indicating which side\n                of each axis to constrain. Must have same length as axes\n            coordinates: Either a single float or a tuple of floats specifying the real-space coordinates\n                in meters to align with. Must have same length as axes\n\n        Returns:\n            RealCoordinateConstraint: Constraint forcing alignment with specific real-space coordinates\n        \"\"\"\n        if isinstance(axes, int):\n            axes = (axes,)\n        if isinstance(sides, str):\n            sides = (sides,)\n        if isinstance(coordinates, int | float):\n            coordinates = (float(coordinates),)\n        if len(axes) != len(sides) or len(axes) != len(coordinates):\n            raise Exception(\"All inputs need to have the same lengths!\")\n        return RealCoordinateConstraint(\n            object=self,\n            axes=axes,\n            sides=sides,\n            coordinates=coordinates,\n        )\n\n    def extend_to(\n        self,\n        other: Optional[\"SimulationObject\"],\n        axis: int,\n        direction: Literal[\"+\", \"-\"],\n        other_position: float | None = None,\n        offset: float = 0,\n        grid_offset: int = 0,\n    ) -&gt; SizeExtensionConstraint:\n        \"\"\"Creates a SizeExtensionConstraint that extends this object along a specified axis until it\n        reaches another object or the simulation boundary. The extension can be in either positive or\n        negative direction.\n\n        Args:\n            other: Target object to extend to, or None to extend to simulation boundary\n            axis: Which axis to extend along (0, 1, or 2)\n            direction: Direction to extend in ('+' or '-')\n            other_position: Relative position on target object (-1 to 1) to extend to.\n                If None, defaults to the corresponding side (-1 for '+' direction, 1 for '-' direction)\n            offset: Additional offset in meters to apply after extension. Ignored when extending to\n                simulation boundary\n            grid_offset: Additional offset in Yee-grid voxels to apply after extension. Ignored when\n                extending to simulation boundary\n\n        Returns:\n            SizeExtensionConstraint: Constraint defining how the object extends\n        \"\"\"\n        # default: extend to corresponding side\n        if other_position is None:\n            other_position = -1 if direction == \"+\" else 1\n        if other is None:\n            if offset != 0 or grid_offset != 0:\n                raise Exception(\"Cannot use offset when extending object to infinity\")\n        return SizeExtensionConstraint(\n            object=self,\n            other_object=other,\n            axis=axis,\n            direction=direction,\n            other_position=other_position,\n            offset=offset,\n            grid_offset=grid_offset,\n        )\n\n    def check_overlap(\n        self,\n        other: \"SimulationObject\",\n    ) -&gt; bool:\n        for axis in range(3):\n            s_start, s_end = self._grid_slice_tuple[axis]\n            o_start, o_end = other._grid_slice_tuple[axis]\n            if o_start &lt;= s_start &lt;= o_end:\n                return True\n            if o_start &lt;= s_end &lt;= o_end:\n                return True\n        return False\n\n    def __eq__(\n        self: Self,\n        other,\n    ) -&gt; bool:\n        if not isinstance(other, SimulationObject):\n            return False\n        return self.name == other.name\n\n    def __hash__(self) -&gt; int:\n        return hash(self.name)\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.SimulationObject.extend_to","title":"<code>extend_to(other, axis, direction, other_position=None, offset=0, grid_offset=0)</code>","text":"<p>Creates a SizeExtensionConstraint that extends this object along a specified axis until it reaches another object or the simulation boundary. The extension can be in either positive or negative direction.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[SimulationObject]</code> <p>Target object to extend to, or None to extend to simulation boundary</p> required <code>axis</code> <code>int</code> <p>Which axis to extend along (0, 1, or 2)</p> required <code>direction</code> <code>Literal['+', '-']</code> <p>Direction to extend in ('+' or '-')</p> required <code>other_position</code> <code>float | None</code> <p>Relative position on target object (-1 to 1) to extend to. If None, defaults to the corresponding side (-1 for '+' direction, 1 for '-' direction)</p> <code>None</code> <code>offset</code> <code>float</code> <p>Additional offset in meters to apply after extension. Ignored when extending to simulation boundary</p> <code>0</code> <code>grid_offset</code> <code>int</code> <p>Additional offset in Yee-grid voxels to apply after extension. Ignored when extending to simulation boundary</p> <code>0</code> <p>Returns:</p> Name Type Description <code>SizeExtensionConstraint</code> <code>SizeExtensionConstraint</code> <p>Constraint defining how the object extends</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def extend_to(\n    self,\n    other: Optional[\"SimulationObject\"],\n    axis: int,\n    direction: Literal[\"+\", \"-\"],\n    other_position: float | None = None,\n    offset: float = 0,\n    grid_offset: int = 0,\n) -&gt; SizeExtensionConstraint:\n    \"\"\"Creates a SizeExtensionConstraint that extends this object along a specified axis until it\n    reaches another object or the simulation boundary. The extension can be in either positive or\n    negative direction.\n\n    Args:\n        other: Target object to extend to, or None to extend to simulation boundary\n        axis: Which axis to extend along (0, 1, or 2)\n        direction: Direction to extend in ('+' or '-')\n        other_position: Relative position on target object (-1 to 1) to extend to.\n            If None, defaults to the corresponding side (-1 for '+' direction, 1 for '-' direction)\n        offset: Additional offset in meters to apply after extension. Ignored when extending to\n            simulation boundary\n        grid_offset: Additional offset in Yee-grid voxels to apply after extension. Ignored when\n            extending to simulation boundary\n\n    Returns:\n        SizeExtensionConstraint: Constraint defining how the object extends\n    \"\"\"\n    # default: extend to corresponding side\n    if other_position is None:\n        other_position = -1 if direction == \"+\" else 1\n    if other is None:\n        if offset != 0 or grid_offset != 0:\n            raise Exception(\"Cannot use offset when extending object to infinity\")\n    return SizeExtensionConstraint(\n        object=self,\n        other_object=other,\n        axis=axis,\n        direction=direction,\n        other_position=other_position,\n        offset=offset,\n        grid_offset=grid_offset,\n    )\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.SimulationObject.face_to_face_negative_direction","title":"<code>face_to_face_negative_direction(other, axes, margins=None, grid_margins=None)</code>","text":"<p>Creates a PositionConstraint that places this object facing another object in the negative direction of specified axes. The objects will touch at their facing boundaries unless margins are specified.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes to align on</p> required <code>margins</code> <code>tuple[float, ...] | float | None</code> <p>Additional margins in meters between the facing surfaces. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <code>grid_margins</code> <code>tuple[int, ...] | int | None</code> <p>Additional margins in Yee-grid voxels between the facing surfaces. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PositionConstraint</code> <code>PositionConstraint</code> <p>Position constraint aligning objects face-to-face in negative direction</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def face_to_face_negative_direction(\n    self,\n    other: \"SimulationObject\",\n    axes: tuple[int, ...] | int,\n    margins: tuple[float, ...] | float | None = None,\n    grid_margins: tuple[int, ...] | int | None = None,\n) -&gt; PositionConstraint:\n    \"\"\"Creates a PositionConstraint that places this object facing another object in the negative direction\n    of specified axes. The objects will touch at their facing boundaries unless margins are specified.\n\n    Args:\n        other: Another object in the simulation scene\n        axes: Either a single integer or a tuple describing which axes to align on\n        margins: Additional margins in meters between the facing surfaces. Must have same length as axes.\n            If None, defaults to 0\n        grid_margins: Additional margins in Yee-grid voxels between the facing surfaces.\n            Must have same length as axes. If None, defaults to 0\n\n    Returns:\n        PositionConstraint: Position constraint aligning objects face-to-face in negative direction\n    \"\"\"\n    if isinstance(axes, int):\n        axes = (axes,)\n    own_positions = tuple([1 for _ in axes])\n    other_positions = tuple([-1 for _ in axes])\n    constraint = self.place_relative_to(\n        other=other,\n        axes=axes,\n        own_positions=own_positions,\n        other_positions=other_positions,\n        margins=margins,\n        grid_margins=grid_margins,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.SimulationObject.face_to_face_positive_direction","title":"<code>face_to_face_positive_direction(other, axes, margins=None, grid_margins=None)</code>","text":"<p>Creates a PositionConstraint that places this object facing another object in the positive direction of specified axes. The objects will touch at their facing boundaries unless margins are specified.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes to align on</p> required <code>margins</code> <code>tuple[float, ...] | float | None</code> <p>Additional margins in meters between the facing surfaces. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <code>grid_margins</code> <code>tuple[int, ...] | int | None</code> <p>Additional margins in Yee-grid voxels between the facing surfaces. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PositionConstraint</code> <code>PositionConstraint</code> <p>Position constraint aligning objects face-to-face in positive direction</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def face_to_face_positive_direction(\n    self,\n    other: \"SimulationObject\",\n    axes: tuple[int, ...] | int,\n    margins: tuple[float, ...] | float | None = None,\n    grid_margins: tuple[int, ...] | int | None = None,\n) -&gt; PositionConstraint:\n    \"\"\"Creates a PositionConstraint that places this object facing another object in the positive direction\n    of specified axes. The objects will touch at their facing boundaries unless margins are specified.\n\n    Args:\n        other: Another object in the simulation scene\n        axes: Either a single integer or a tuple describing which axes to align on\n        margins: Additional margins in meters between the facing surfaces. Must have same length as axes.\n            If None, defaults to 0\n        grid_margins: Additional margins in Yee-grid voxels between the facing surfaces.\n            Must have same length as axes. If None, defaults to 0\n\n    Returns:\n        PositionConstraint: Position constraint aligning objects face-to-face in positive direction\n    \"\"\"\n    if isinstance(axes, int):\n        axes = (axes,)\n    own_positions = tuple([-1 for _ in axes])\n    other_positions = tuple([1 for _ in axes])\n    constraint = self.place_relative_to(\n        other=other,\n        axes=axes,\n        own_positions=own_positions,\n        other_positions=other_positions,\n        margins=margins,\n        grid_margins=grid_margins,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.SimulationObject.place_above","title":"<code>place_above(other, margins=None, grid_margins=None)</code>","text":"<p>Creates a PositionConstraint that places this object above another object along the z-axis. This is a convenience wrapper around face_to_face_positive_direction() for axis 2 (z-axis).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>margins</code> <code>tuple[float, ...] | float | None</code> <p>Additional vertical margins in meters between objects. If None, defaults to 0</p> <code>None</code> <code>grid_margins</code> <code>tuple[int, ...] | int | None</code> <p>Additional vertical margins in Yee-grid voxels between objects. If None, defaults to 0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PositionConstraint</code> <code>PositionConstraint</code> <p>Position constraint placing this object above the other</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def place_above(\n    self,\n    other: \"SimulationObject\",\n    margins: tuple[float, ...] | float | None = None,\n    grid_margins: tuple[int, ...] | int | None = None,\n) -&gt; PositionConstraint:\n    \"\"\"Creates a PositionConstraint that places this object above another object along the z-axis.\n    This is a convenience wrapper around face_to_face_positive_direction() for axis 2 (z-axis).\n\n    Args:\n        other: Another object in the simulation scene\n        margins: Additional vertical margins in meters between objects. If None, defaults to 0\n        grid_margins: Additional vertical margins in Yee-grid voxels between objects.\n            If None, defaults to 0\n\n    Returns:\n        PositionConstraint: Position constraint placing this object above the other\n    \"\"\"\n    constraint = self.face_to_face_positive_direction(\n        other=other,\n        axes=(2,),\n        margins=margins,\n        grid_margins=grid_margins,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.SimulationObject.place_at_center","title":"<code>place_at_center(other, axes=(0, 1, 2), own_positions=None, other_positions=None, margins=None, grid_margins=None)</code>","text":"<p>Creates a PositionConstraint that centers this object relative to another object along specified axes. This is a convenience wrapper around place_relative_to() with default positions at the center (0).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes to center on. Defaults to all axes (0, 1, 2)</p> <code>(0, 1, 2)</code> <code>own_positions</code> <code>tuple[float, ...] | float | None</code> <p>Relative positions on this object (-1 to 1). If None, defaults to center (0)</p> <code>None</code> <code>other_positions</code> <code>tuple[float, ...] | float | None</code> <p>Relative positions on other object (-1 to 1). If None, defaults to center (0)</p> <code>None</code> <code>margins</code> <code>tuple[float, ...] | float | None</code> <p>Additional margins in meters between objects. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <code>grid_margins</code> <code>tuple[int, ...] | int | None</code> <p>Additional margins in Yee-grid voxels between objects. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PositionConstraint</code> <code>PositionConstraint</code> <p>Position constraint centering objects relative to each other</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def place_at_center(\n    self,\n    other: \"SimulationObject\",\n    axes: tuple[int, ...] | int = (0, 1, 2),\n    own_positions: tuple[float, ...] | float | None = None,\n    other_positions: tuple[float, ...] | float | None = None,\n    margins: tuple[float, ...] | float | None = None,\n    grid_margins: tuple[int, ...] | int | None = None,\n) -&gt; PositionConstraint:\n    \"\"\"Creates a PositionConstraint that centers this object relative to another object along specified axes.\n    This is a convenience wrapper around place_relative_to() with default positions at the center (0).\n\n    Args:\n        other: Another object in the simulation scene\n        axes: Either a single integer or a tuple describing which axes to center on.\n            Defaults to all axes (0, 1, 2)\n        own_positions: Relative positions on this object (-1 to 1). If None, defaults to center (0)\n        other_positions: Relative positions on other object (-1 to 1). If None, defaults to center (0)\n        margins: Additional margins in meters between objects. Must have same length as axes.\n            If None, defaults to 0\n        grid_margins: Additional margins in Yee-grid voxels between objects. Must have same length as axes.\n            If None, defaults to 0\n\n    Returns:\n        PositionConstraint: Position constraint centering objects relative to each other\n    \"\"\"\n    if isinstance(axes, int):\n        axes = (axes,)\n    if own_positions is None:\n        own_positions = tuple([0 for _ in axes])\n    if other_positions is None:\n        other_positions = tuple([0 for _ in axes])\n    constraint = self.place_relative_to(\n        other=other,\n        axes=axes,\n        own_positions=own_positions,\n        other_positions=other_positions,\n        margins=margins,\n        grid_margins=grid_margins,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.SimulationObject.place_below","title":"<code>place_below(other, margins=None, grid_margins=None)</code>","text":"<p>Creates a PositionConstraint that places this object below another object along the z-axis. This is a convenience wrapper around face_to_face_negative_direction() for axis 2 (z-axis).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>margins</code> <code>tuple[float, ...] | float | None</code> <p>Additional vertical margins in meters between objects. If None, defaults to 0</p> <code>None</code> <code>grid_margins</code> <code>tuple[int, ...] | int | None</code> <p>Additional vertical margins in Yee-grid voxels between objects. If None, defaults to 0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PositionConstraint</code> <code>PositionConstraint</code> <p>Position constraint placing this object below the other</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def place_below(\n    self,\n    other: \"SimulationObject\",\n    margins: tuple[float, ...] | float | None = None,\n    grid_margins: tuple[int, ...] | int | None = None,\n) -&gt; PositionConstraint:\n    \"\"\"Creates a PositionConstraint that places this object below another object along the z-axis.\n    This is a convenience wrapper around face_to_face_negative_direction() for axis 2 (z-axis).\n\n    Args:\n        other: Another object in the simulation scene\n        margins: Additional vertical margins in meters between objects. If None, defaults to 0\n        grid_margins: Additional vertical margins in Yee-grid voxels between objects.\n            If None, defaults to 0\n\n    Returns:\n        PositionConstraint: Position constraint placing this object below the other\n    \"\"\"\n    constraint = self.face_to_face_negative_direction(\n        other=other,\n        axes=(2,),\n        margins=margins,\n        grid_margins=grid_margins,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.SimulationObject.place_relative_to","title":"<code>place_relative_to(other, axes, own_positions, other_positions, margins=None, grid_margins=None)</code>","text":"<p>Creates a PositionalConstraint between two objects. The constraint is defined by anchor points on both objects, which are constrainted to be at the same position. Anchors are defined in relative coordinates, i.e. a position of -1 is the left object boundary in the repective axis and a position of +1 the right boundary.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>axes</code> <code>tuple[int, ...] | int</code> <p>Eiter a single integer or a tuple describing the axes of the constraints</p> required <code>own_positions</code> <code>tuple[float, ...] | float</code> <p>The positions of the own anchor in the axes. Must have the same lengths as axes</p> required <code>other_positions</code> <code>tuple[float, ...] | float</code> <p>The positions of the other objects' anchor in the axes. Must have the same lengths as axes</p> required <code>margins</code> <code>tuple[float, ...] | float | None</code> <p>The margins between the anchors of both objects in meters. Must have the same lengths as axes. Defaults to no margin</p> <code>None</code> <code>grid_margins</code> <code>tuple[int, ...] | int | None</code> <p>The margins between the anchors of both objects in Yee-grid voxels. Must have the same lengths as axes. Defaults to no margin</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PositionConstraint</code> <code>PositionConstraint</code> <p>Positional constraint between this object and the other</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def place_relative_to(\n    self,\n    other: \"SimulationObject\",\n    axes: tuple[int, ...] | int,\n    own_positions: tuple[float, ...] | float,\n    other_positions: tuple[float, ...] | float,\n    margins: tuple[float, ...] | float | None = None,\n    grid_margins: tuple[int, ...] | int | None = None,\n) -&gt; PositionConstraint:\n    \"\"\"Creates a PositionalConstraint between two objects. The constraint is defined by anchor points on\n    both objects, which are constrainted to be at the same position. Anchors are defined in relative coordinates,\n    i.e. a position of -1 is the left object boundary in the repective axis and a position of +1 the right boundary.\n\n    Args:\n        other: Another object in the simulation scene\n        axes: Eiter a single integer or a tuple describing the axes of the constraints\n        own_positions: The positions of the own anchor in the axes. Must have the same lengths as axes\n        other_positions: The positions of the other objects' anchor in the axes. Must have the same lengths as axes\n        margins: The margins between the anchors of both objects in meters. Must have the same lengths as axes. Defaults to no margin\n        grid_margins: The margins between the anchors of both objects in Yee-grid voxels. Must have the same lengths as axes. Defaults to no margin\n\n    Returns:\n        PositionConstraint: Positional constraint between this object and the other\n    \"\"\"\n    if isinstance(axes, int):\n        axes = (axes,)\n    if isinstance(own_positions, int | float):\n        own_positions = (float(own_positions),)\n    if isinstance(other_positions, int | float):\n        other_positions = (float(other_positions),)\n    if isinstance(margins, int | float):\n        margins = (float(margins),)\n    if isinstance(grid_margins, int):\n        grid_margins = (grid_margins,)\n    if margins is None:\n        margins = tuple([0 for _ in axes])\n    if grid_margins is None:\n        grid_margins = tuple([0 for _ in axes])\n    if (\n        len(axes) != len(own_positions)\n        or len(axes) != len(other_positions)\n        or len(axes) != len(margins)\n        or len(axes) != len(grid_margins)\n    ):\n        raise Exception(\"All inputs should have same lengths\")\n    constraint = PositionConstraint(\n        axes=axes,\n        other_object=other,\n        object=self,\n        other_object_positions=other_positions,\n        object_positions=own_positions,\n        margins=margins,\n        grid_margins=grid_margins,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.SimulationObject.same_position_and_size","title":"<code>same_position_and_size(other, axes=(0, 1, 2))</code>","text":"<p>Creates both position and size constraints to make this object match another object's position and size. This is a convenience wrapper combining place_at_center() and same_size().</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes to match. Defaults to all axes (0, 1, 2)</p> <code>(0, 1, 2)</code> <p>Returns:</p> Type Description <code>tuple[PositionConstraint, SizeConstraint]</code> <p>tuple[PositionConstraint, SizeConstraint]: Position and size constraints for matching objects</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def same_position_and_size(\n    self,\n    other: \"SimulationObject\",\n    axes: tuple[int, ...] | int = (0, 1, 2),\n) -&gt; tuple[PositionConstraint, SizeConstraint]:\n    \"\"\"Creates both position and size constraints to make this object match another object's position and size.\n    This is a convenience wrapper combining place_at_center() and same_size().\n\n    Args:\n        other: Another object in the simulation scene\n        axes: Either a single integer or a tuple describing which axes to match.\n            Defaults to all axes (0, 1, 2)\n\n    Returns:\n        tuple[PositionConstraint, SizeConstraint]: Position and size constraints for matching objects\n    \"\"\"\n    size_constraint = self.same_size(\n        other=other,\n        axes=axes,\n    )\n    pos_constraint = self.place_at_center(\n        other=other,\n        axes=axes,\n    )\n    return pos_constraint, size_constraint\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.SimulationObject.same_size","title":"<code>same_size(other, axes=(0, 1, 2), offsets=None, grid_offsets=None)</code>","text":"<p>Creates a SizeConstraint that makes this object the same size as another object along specified axes. This is a convenience wrapper around size_relative_to() with proportions set to 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes should have the same size. Defaults to all axes (0, 1, 2)</p> <code>(0, 1, 2)</code> <code>offsets</code> <code>tuple[float, ...] | float | None</code> <p>Additional size offsets in meters to apply. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <code>grid_offsets</code> <code>tuple[int, ...] | int | None</code> <p>Additional size offsets in Yee-grid voxels to apply. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SizeConstraint</code> <code>SizeConstraint</code> <p>Size constraint ensuring equal sizes between objects</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def same_size(\n    self,\n    other: \"SimulationObject\",\n    axes: tuple[int, ...] | int = (0, 1, 2),\n    offsets: tuple[float, ...] | float | None = None,\n    grid_offsets: tuple[int, ...] | int | None = None,\n) -&gt; SizeConstraint:\n    \"\"\"Creates a SizeConstraint that makes this object the same size as another object along specified axes.\n    This is a convenience wrapper around size_relative_to() with proportions set to 1.0.\n\n    Args:\n        other: Another object in the simulation scene\n        axes: Either a single integer or a tuple describing which axes should have the same size.\n            Defaults to all axes (0, 1, 2)\n        offsets: Additional size offsets in meters to apply. Must have same length as axes.\n            If None, defaults to 0\n        grid_offsets: Additional size offsets in Yee-grid voxels to apply. Must have same length as axes.\n            If None, defaults to 0\n\n    Returns:\n        SizeConstraint: Size constraint ensuring equal sizes between objects\n    \"\"\"\n    if isinstance(axes, int):\n        axes = (axes,)\n    proportions = tuple([1 for _ in axes])\n    constraint = self.size_relative_to(\n        other=other,\n        axes=axes,\n        proportions=proportions,\n        offsets=offsets,\n        grid_offsets=grid_offsets,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.SimulationObject.set_grid_coordinates","title":"<code>set_grid_coordinates(axes, sides, coordinates)</code>","text":"<p>Creates a GridCoordinateConstraint that forces specific sides of this object to align with given grid coordinates. Used for precise positioning in the discretized simulation space.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes to constrain</p> required <code>sides</code> <code>tuple[Literal['+', '-'], ...] | Literal['+', '-']</code> <p>Either a single string or a tuple of strings ('+' or '-') indicating which side of each axis to constrain. Must have same length as axes</p> required <code>coordinates</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple of integers specifying the grid coordinates to align with. Must have same length as axes</p> required <p>Returns:</p> Name Type Description <code>GridCoordinateConstraint</code> <code>GridCoordinateConstraint</code> <p>Constraint forcing alignment with specific grid coordinates</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def set_grid_coordinates(\n    self,\n    axes: tuple[int, ...] | int,\n    sides: tuple[Literal[\"+\", \"-\"], ...] | Literal[\"+\", \"-\"],\n    coordinates: tuple[int, ...] | int,\n) -&gt; GridCoordinateConstraint:\n    \"\"\"Creates a GridCoordinateConstraint that forces specific sides of this object to align with\n    given grid coordinates. Used for precise positioning in the discretized simulation space.\n\n    Args:\n        axes: Either a single integer or a tuple describing which axes to constrain\n        sides: Either a single string or a tuple of strings ('+' or '-') indicating which side\n            of each axis to constrain. Must have same length as axes\n        coordinates: Either a single integer or a tuple of integers specifying the grid coordinates\n            to align with. Must have same length as axes\n\n    Returns:\n        GridCoordinateConstraint: Constraint forcing alignment with specific grid coordinates\n    \"\"\"\n    if isinstance(axes, int):\n        axes = (axes,)\n    if isinstance(sides, str):\n        sides = (sides,)\n    if isinstance(coordinates, int):\n        coordinates = (coordinates,)\n    if len(axes) != len(sides) or len(axes) != len(coordinates):\n        raise Exception(\"All inputs need to have the same lengths!\")\n    return GridCoordinateConstraint(\n        object=self,\n        axes=axes,\n        sides=sides,\n        coordinates=coordinates,\n    )\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.SimulationObject.set_real_coordinates","title":"<code>set_real_coordinates(axes, sides, coordinates)</code>","text":"<p>Creates a RealCoordinateConstraint that forces specific sides of this object to align with given real-space coordinates. Used for precise positioning in physical units.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes to constrain</p> required <code>sides</code> <code>tuple[Literal['+', '-'], ...] | Literal['+', '-']</code> <p>Either a single string or a tuple of strings ('+' or '-') indicating which side of each axis to constrain. Must have same length as axes</p> required <code>coordinates</code> <code>tuple[float, ...] | float</code> <p>Either a single float or a tuple of floats specifying the real-space coordinates in meters to align with. Must have same length as axes</p> required <p>Returns:</p> Name Type Description <code>RealCoordinateConstraint</code> <code>RealCoordinateConstraint</code> <p>Constraint forcing alignment with specific real-space coordinates</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def set_real_coordinates(\n    self,\n    axes: tuple[int, ...] | int,\n    sides: tuple[Literal[\"+\", \"-\"], ...] | Literal[\"+\", \"-\"],\n    coordinates: tuple[float, ...] | float,\n) -&gt; RealCoordinateConstraint:\n    \"\"\"Creates a RealCoordinateConstraint that forces specific sides of this object to align with\n    given real-space coordinates. Used for precise positioning in physical units.\n\n    Args:\n        axes: Either a single integer or a tuple describing which axes to constrain\n        sides: Either a single string or a tuple of strings ('+' or '-') indicating which side\n            of each axis to constrain. Must have same length as axes\n        coordinates: Either a single float or a tuple of floats specifying the real-space coordinates\n            in meters to align with. Must have same length as axes\n\n    Returns:\n        RealCoordinateConstraint: Constraint forcing alignment with specific real-space coordinates\n    \"\"\"\n    if isinstance(axes, int):\n        axes = (axes,)\n    if isinstance(sides, str):\n        sides = (sides,)\n    if isinstance(coordinates, int | float):\n        coordinates = (float(coordinates),)\n    if len(axes) != len(sides) or len(axes) != len(coordinates):\n        raise Exception(\"All inputs need to have the same lengths!\")\n    return RealCoordinateConstraint(\n        object=self,\n        axes=axes,\n        sides=sides,\n        coordinates=coordinates,\n    )\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.SimulationObject.size_relative_to","title":"<code>size_relative_to(other, axes, other_axes=None, proportions=None, offsets=None, grid_offsets=None)</code>","text":"<p>Creates a SizeConstraint between two objects. The constraint defines the size of this object relative to another object, allowing for proportional scaling and offsets in specified axes.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes of this object to constrain</p> required <code>other_axes</code> <code>tuple[int, ...] | int | None</code> <p>Either a single integer or a tuple describing which axes of the other object to reference. If None, uses the same axes as specified in 'axes'</p> <code>None</code> <code>proportions</code> <code>tuple[float, ...] | float | None</code> <p>Scale factors to apply to the other object's dimensions. Must have same length as axes. If None, defaults to 1.0 (same size)</p> <code>None</code> <code>offsets</code> <code>tuple[float, ...] | float | None</code> <p>Additional size offsets in meters to apply after scaling. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <code>grid_offsets</code> <code>tuple[int, ...] | int | None</code> <p>Additional size offsets in Yee-grid voxels to apply after scaling. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SizeConstraint</code> <code>SizeConstraint</code> <p>Size constraint between this object and the other</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def size_relative_to(\n    self,\n    other: \"SimulationObject\",\n    axes: tuple[int, ...] | int,\n    other_axes: tuple[int, ...] | int | None = None,\n    proportions: tuple[float, ...] | float | None = None,\n    offsets: tuple[float, ...] | float | None = None,\n    grid_offsets: tuple[int, ...] | int | None = None,\n) -&gt; SizeConstraint:\n    \"\"\"Creates a SizeConstraint between two objects. The constraint defines the size of this object relative\n    to another object, allowing for proportional scaling and offsets in specified axes.\n\n    Args:\n        other: Another object in the simulation scene\n        axes: Either a single integer or a tuple describing which axes of this object to constrain\n        other_axes: Either a single integer or a tuple describing which axes of the other object to reference.\n            If None, uses the same axes as specified in 'axes'\n        proportions: Scale factors to apply to the other object's dimensions. Must have same length as axes.\n            If None, defaults to 1.0 (same size)\n        offsets: Additional size offsets in meters to apply after scaling. Must have same length as axes.\n            If None, defaults to 0\n        grid_offsets: Additional size offsets in Yee-grid voxels to apply after scaling. Must have same length as axes.\n            If None, defaults to 0\n\n    Returns:\n        SizeConstraint: Size constraint between this object and the other\n    \"\"\"\n    if isinstance(axes, int):\n        axes = (axes,)\n    if isinstance(other_axes, int):\n        other_axes = (other_axes,)\n    if isinstance(proportions, int | float):\n        proportions = (float(proportions),)\n    if isinstance(offsets, int | float):\n        offsets = (offsets,)\n    if isinstance(grid_offsets, int):\n        grid_offsets = (grid_offsets,)\n    if offsets is None:\n        offsets = tuple([0 for _ in axes])\n    if grid_offsets is None:\n        grid_offsets = tuple([0 for _ in axes])\n    if proportions is None:\n        proportions = tuple([1.0 for _ in axes])\n    if other_axes is None:\n        other_axes = tuple([a for a in axes])\n    if len(axes) != len(proportions) or len(axes) != len(offsets) or len(axes) != len(grid_offsets):\n        raise Exception(\"All inputs should have same lengths\")\n    constraint = SizeConstraint(\n        other_object=other,\n        object=self,\n        axes=axes,\n        other_axes=other_axes,\n        proportions=proportions,\n        offsets=offsets,\n        grid_offsets=grid_offsets,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.SimulationVolume","title":"<code>fdtdx.objects.SimulationVolume</code>","text":"<p>               Bases: <code>UniformMaterialObject</code></p> <p>Background material for the entire simulation volume.</p> <p>Defines the default material properties for the simulation background. Usually represents air/vacuum with \u03b5\u1d63=1.0 and \u03bc\u1d63=1.0.</p> Source code in <code>src/fdtdx/objects/static_material/uniform.py</code> <pre><code>@extended_autoinit\nclass SimulationVolume(UniformMaterialObject):\n    \"\"\"Background material for the entire simulation volume.\n\n    Defines the default material properties for the simulation background.\n    Usually represents air/vacuum with \u03b5\u1d63=1.0 and \u03bc\u1d63=1.0.\n    \"\"\"\n\n    placement_order = -1000\n    material: Material = field(\n        default=Material(\n            permittivity=1.0,\n            permeability=1.0,\n        ),\n        kind=\"KW_ONLY\",\n    )\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.UniformMaterialObject","title":"<code>fdtdx.objects.UniformMaterialObject</code>","text":"<p>               Bases: <code>StaticMaterialObject</code></p> Source code in <code>src/fdtdx/objects/static_material/uniform.py</code> <pre><code>@extended_autoinit\nclass UniformMaterialObject(StaticMaterialObject):\n    material: Material = field(kind=\"KW_ONLY\")  # type: ignore\n    color: tuple[float, float, float] | None = LIGHT_GREY\n</code></pre>"},{"location":"api/objects/object/#convenience-wrapper","title":"Convenience Wrapper","text":"<p>A substrate of uniform material. This is just a wrapper for an object with uniform material.</p> <p>A waveguide of uniform material. This is just a wrapper for an object with uniform material.</p>"},{"location":"api/objects/object/#fdtdx.objects.Substrate","title":"<code>fdtdx.objects.Substrate</code>","text":"<p>               Bases: <code>UniformMaterialObject</code></p> <p>Material representing a substrate layer.</p> <p>Used to model substrate materials like silicon dioxide. Visualized in light brown color by default.</p> Source code in <code>src/fdtdx/objects/static_material/uniform.py</code> <pre><code>@extended_autoinit\nclass Substrate(UniformMaterialObject):\n    \"\"\"Material representing a substrate layer.\n\n    Used to model substrate materials like silicon dioxide.\n    Visualized in light brown color by default.\n    \"\"\"\n\n    color: tuple[float, float, float] | None = LIGHT_BROWN\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.Waveguide","title":"<code>fdtdx.objects.Waveguide</code>","text":"<p>               Bases: <code>UniformMaterialObject</code></p> <p>Material for optical waveguides.</p> <p>Used to model waveguide structures that can guide electromagnetic waves. Visualized in light blue color by default.</p> <p>Attributes:</p> Name Type Description <code>permittivity</code> <p>Required relative permittivity of the waveguide material</p> <code>color</code> <code>tuple[float, float, float] | None</code> <p>RGB tuple for visualization, defaults to light blue</p> Source code in <code>src/fdtdx/objects/static_material/uniform.py</code> <pre><code>@extended_autoinit\nclass Waveguide(UniformMaterialObject):\n    \"\"\"Material for optical waveguides.\n\n    Used to model waveguide structures that can guide electromagnetic waves.\n    Visualized in light blue color by default.\n\n    Attributes:\n        permittivity: Required relative permittivity of the waveguide material\n        color: RGB tuple for visualization, defaults to light blue\n    \"\"\"\n\n    color: tuple[float, float, float] | None = LIGHT_BLUE\n</code></pre>"},{"location":"api/objects/object/#positioningsizing-constraints","title":"Positioning/Sizing Constraints","text":"<p>Defines relative positioning between simulation objects.</p> <p>Controls size relationships between objects.</p> <p>Extends objects to reach other objects or boundaries.</p> <p>Aligns objects to specific grid coordinates.</p> <p>Positions objects at specific physical coordinates.</p>"},{"location":"api/objects/object/#fdtdx.objects.object.PositionConstraint","title":"<code>fdtdx.objects.object.PositionConstraint</code>  <code>dataclass</code>","text":"<p>Defines a positional relationship between two simulation objects.</p> <p>A constraint that positions one object relative to another, with optional margins and offsets. Used to specify how objects should be placed in the simulation volume relative to each other.</p> <p>Attributes:</p> Name Type Description <code>object</code> <code>SimulationObject</code> <p>The \"child\" object whose position is being adjusted</p> <code>other_object</code> <code>SimulationObject</code> <p>The \"parent\" object that serves as reference</p> <code>axes</code> <code>tuple[int, ...]</code> <p>Which axes (x,y,z) this constraint applies to</p> <code>object_positions</code> <code>tuple[float, ...]</code> <p>Relative positions on child object (-1 to 1)</p> <code>other_object_positions</code> <code>tuple[float, ...]</code> <p>Relative positions on parent object (-1 to 1)</p> <code>margins</code> <code>tuple[float, ...]</code> <p>Optional real-space margins between objects</p> <code>grid_margins</code> <code>tuple[int, ...]</code> <p>Optional grid-space margins between objects</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>@dataclass(kw_only=True, frozen=True)\nclass PositionConstraint:\n    \"\"\"Defines a positional relationship between two simulation objects.\n\n    A constraint that positions one object relative to another, with optional\n    margins and offsets. Used to specify how objects should be placed in the\n    simulation volume relative to each other.\n\n    Attributes:\n        object: The \"child\" object whose position is being adjusted\n        other_object: The \"parent\" object that serves as reference\n        axes: Which axes (x,y,z) this constraint applies to\n        object_positions: Relative positions on child object (-1 to 1)\n        other_object_positions: Relative positions on parent object (-1 to 1)\n        margins: Optional real-space margins between objects\n        grid_margins: Optional grid-space margins between objects\n    \"\"\"\n\n    object: \"SimulationObject\"  # \"child\" object, whose pos is adjusted\n    other_object: \"SimulationObject\"  # \"parent\" object\n    axes: tuple[int, ...]\n    object_positions: tuple[float, ...]\n    other_object_positions: tuple[float, ...]\n    margins: tuple[float, ...]\n    grid_margins: tuple[int, ...]\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.SizeConstraint","title":"<code>fdtdx.objects.object.SizeConstraint</code>  <code>dataclass</code>","text":"<p>Defines a size relationship between two simulation objects.</p> <p>A constraint that sets the size of one object relative to another, with optional proportions and offsets. Used to specify how objects should be sized relative to each other in the simulation.</p> <p>Attributes:</p> Name Type Description <code>object</code> <code>SimulationObject</code> <p>The \"child\" object whose size is being adjusted</p> <code>other_object</code> <code>SimulationObject</code> <p>The \"parent\" object that serves as reference</p> <code>axes</code> <code>tuple[int, ...]</code> <p>Which axes of the child to constrain</p> <code>other_axes</code> <code>tuple[int, ...]</code> <p>Which axes of the parent to reference</p> <code>proportions</code> <code>tuple[float, ...]</code> <p>Size multipliers relative to parent</p> <code>offsets</code> <code>tuple[float, ...]</code> <p>Additional real-space size offsets</p> <code>grid_offsets</code> <code>tuple[int, ...]</code> <p>Additional grid-space size offsets</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>@dataclass(kw_only=True, frozen=True)\nclass SizeConstraint:\n    \"\"\"Defines a size relationship between two simulation objects.\n\n    A constraint that sets the size of one object relative to another, with\n    optional proportions and offsets. Used to specify how objects should be\n    sized relative to each other in the simulation.\n\n    Attributes:\n        object: The \"child\" object whose size is being adjusted\n        other_object: The \"parent\" object that serves as reference\n        axes: Which axes of the child to constrain\n        other_axes: Which axes of the parent to reference\n        proportions: Size multipliers relative to parent\n        offsets: Additional real-space size offsets\n        grid_offsets: Additional grid-space size offsets\n    \"\"\"\n\n    object: \"SimulationObject\"  # \"child\" object, whose size is adjusted\n    other_object: \"SimulationObject\"  # \"parent\" object\n    axes: tuple[int, ...]\n    other_axes: tuple[int, ...]\n    proportions: tuple[float, ...]\n    offsets: tuple[float, ...]\n    grid_offsets: tuple[int, ...]\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.SizeExtensionConstraint","title":"<code>fdtdx.objects.object.SizeExtensionConstraint</code>  <code>dataclass</code>","text":"<p>Defines how an object extends toward another object or boundary.</p> <p>A constraint that extends one object's size until it reaches another object or the simulation boundary. Can extend in positive or negative direction along an axis.</p> <p>Attributes:</p> Name Type Description <code>object</code> <code>SimulationObject</code> <p>The object being extended</p> <code>other_object</code> <code>Optional[SimulationObject]</code> <p>Optional target object to extend to</p> <code>axis</code> <code>int</code> <p>Which axis to extend along</p> <code>direction</code> <code>Literal['+', '-']</code> <p>Direction to extend ('+' or '-')</p> <code>other_position</code> <code>float</code> <p>Relative position on target (-1 to 1)</p> <code>offset</code> <code>float</code> <p>Additional real-space offset</p> <code>grid_offset</code> <code>int</code> <p>Additional grid-space offset</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>@dataclass(kw_only=True, frozen=True)\nclass SizeExtensionConstraint:\n    \"\"\"Defines how an object extends toward another object or boundary.\n\n    A constraint that extends one object's size until it reaches another object\n    or the simulation boundary. Can extend in positive or negative direction\n    along an axis.\n\n    Attributes:\n        object: The object being extended\n        other_object: Optional target object to extend to\n        axis: Which axis to extend along\n        direction: Direction to extend ('+' or '-')\n        other_position: Relative position on target (-1 to 1)\n        offset: Additional real-space offset\n        grid_offset: Additional grid-space offset\n    \"\"\"\n\n    object: \"SimulationObject\"  # \"child\" object, whose size is adjusted\n    other_object: Optional[\"SimulationObject\"]  # \"parent\" object\n    axis: int\n    direction: Literal[\"+\", \"-\"]\n    other_position: float\n    offset: float\n    grid_offset: int\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.GridCoordinateConstraint","title":"<code>fdtdx.objects.object.GridCoordinateConstraint</code>  <code>dataclass</code>","text":"<p>Constrains an object's position to specific grid coordinates.</p> <p>Forces specific sides of an object to align with given grid coordinates. Used for precise positioning in the discretized simulation space.</p> <p>Attributes:</p> Name Type Description <code>object</code> <code>SimulationObject</code> <p>The object to position</p> <code>axes</code> <code>tuple[int, ...]</code> <p>Which axes to constrain</p> <code>sides</code> <code>tuple[Literal['+', '-'], ...]</code> <p>Which side of each axis ('+' or '-')</p> <code>coordinates</code> <code>tuple[int, ...]</code> <p>Grid coordinates to align with</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>@dataclass(kw_only=True, frozen=True)\nclass GridCoordinateConstraint:\n    \"\"\"Constrains an object's position to specific grid coordinates.\n\n    Forces specific sides of an object to align with given grid coordinates.\n    Used for precise positioning in the discretized simulation space.\n\n    Attributes:\n        object: The object to position\n        axes: Which axes to constrain\n        sides: Which side of each axis ('+' or '-')\n        coordinates: Grid coordinates to align with\n    \"\"\"\n\n    object: \"SimulationObject\"\n    axes: tuple[int, ...]\n    sides: tuple[Literal[\"+\", \"-\"], ...]\n    coordinates: tuple[int, ...]\n</code></pre>"},{"location":"api/objects/object/#fdtdx.objects.object.RealCoordinateConstraint","title":"<code>fdtdx.objects.object.RealCoordinateConstraint</code>  <code>dataclass</code>","text":"<p>Constrains an object's position to specific real-space coordinates.</p> <p>Forces specific sides of an object to align with given real-space coordinates. Used for precise positioning in physical units.</p> <p>Attributes:</p> Name Type Description <code>object</code> <code>SimulationObject</code> <p>The object to position</p> <code>axes</code> <code>tuple[int, ...]</code> <p>Which axes to constrain</p> <code>sides</code> <code>tuple[Literal['+', '-'], ...]</code> <p>Which side of each axis ('+' or '-')</p> <code>coordinates</code> <code>tuple[float, ...]</code> <p>Real-space coordinates to align with</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>@dataclass(kw_only=True, frozen=True)\nclass RealCoordinateConstraint:\n    \"\"\"Constrains an object's position to specific real-space coordinates.\n\n    Forces specific sides of an object to align with given real-space coordinates.\n    Used for precise positioning in physical units.\n\n    Attributes:\n        object: The object to position\n        axes: Which axes to constrain\n        sides: Which side of each axis ('+' or '-')\n        coordinates: Real-space coordinates to align with\n    \"\"\"\n\n    object: \"SimulationObject\"\n    axes: tuple[int, ...]\n    sides: tuple[Literal[\"+\", \"-\"], ...]\n    coordinates: tuple[float, ...]\n</code></pre>"},{"location":"api/objects/sources/","title":"Sources","text":""},{"location":"api/objects/sources/#_1","title":"Sources","text":""},{"location":"api/objects/sources/#sources","title":"Sources","text":"<p>A collection of source objects to induce light into a simulation. The spatial profile of the sources can be either a plane, a gaussian or a mode. The temporal profile is set through the correponding attribute. All sources are implemented using the Total-Field/Scattered-Field formulation (also known as soft sources), except for the sources explicitly marked as \"hard\". These directly set the electric/magnetic field to a fixed value.</p> <p>A source with a spatial profile of a gaussian.</p> <p>A source with a spatial profile of a uniform plane.</p> <p>A source with the spatial profile of a mode. The mode is computed automatically and by default a first order mode is used. In the future, we will develop a better interface to support other modes as well.</p> <p>A hard source with the spatial profile of a plane.</p>"},{"location":"api/objects/sources/#fdtdx.objects.sources.GaussianPlaneSource","title":"<code>fdtdx.objects.sources.GaussianPlaneSource</code>","text":"<p>               Bases: <code>LinearlyPolarizedPlaneSource</code></p> Source code in <code>src/fdtdx/objects/sources/linear_polarization.py</code> <pre><code>@extended_autoinit\nclass GaussianPlaneSource(LinearlyPolarizedPlaneSource):\n    radius: float = frozen_field(kind=\"KW_ONLY\")  # type: ignore\n    std: float = frozen_field(kind=\"KW_ONLY\", default=1 / 3)  # relative to radius\n\n    @staticmethod\n    def _gauss_profile(\n        width: int,\n        height: int,\n        axis: int,\n        center: tuple[float, float] | jax.Array,\n        radii: tuple[float, float],\n        std: float,\n    ) -&gt; jax.Array:  # shape (*grid_shape)\n        grid = (\n            jnp.stack(jnp.meshgrid(*map(jnp.arange, (height, width)), indexing=\"xy\"), axis=-1) - jnp.asarray(center)\n        ) / jnp.asarray(radii)\n        euc_dist = (grid**2).sum(axis=-1)\n\n        mask = euc_dist &lt; 1\n        mask = jnp.expand_dims(mask, axis=axis)\n\n        exp_part = jnp.exp(-0.5 * euc_dist / std**2)\n        exp_part = jnp.expand_dims(exp_part, axis=axis)\n\n        profile = jnp.where(mask, exp_part, 0)\n        profile = profile / profile.sum()\n\n        return profile\n\n    def _get_amplitude_raw(\n        self,\n        center: jax.Array,\n    ) -&gt; jax.Array:\n        grid_radius = self.radius / self._config.resolution\n        profile = self._gauss_profile(\n            width=self.grid_shape[self.horizontal_axis],\n            height=self.grid_shape[self.vertical_axis],\n            axis=self.propagation_axis,\n            center=center,\n            radii=(grid_radius, grid_radius),\n            std=self.std,\n        )\n        return profile\n</code></pre>"},{"location":"api/objects/sources/#fdtdx.objects.sources.SimplePlaneSource","title":"<code>fdtdx.objects.sources.SimplePlaneSource</code>","text":"<p>               Bases: <code>LinearlyPolarizedPlaneSource</code></p> Source code in <code>src/fdtdx/objects/sources/linear_polarization.py</code> <pre><code>@extended_autoinit\nclass SimplePlaneSource(LinearlyPolarizedPlaneSource):\n    amplitude: float = 1.0\n\n    def _get_amplitude_raw(\n        self,\n        center: jax.Array,\n    ) -&gt; jax.Array:\n        del center\n        profile = jnp.ones(shape=self.grid_shape, dtype=jnp.float32)\n        return self.amplitude * profile\n</code></pre>"},{"location":"api/objects/sources/#fdtdx.objects.sources.ModePlaneSource","title":"<code>fdtdx.objects.sources.ModePlaneSource</code>","text":"<p>               Bases: <code>TFSFPlaneSource</code></p> Source code in <code>src/fdtdx/objects/sources/mode.py</code> <pre><code>@extended_autoinit\nclass ModePlaneSource(TFSFPlaneSource):\n    mode_index: int = frozen_field(default=0)\n    filter_pol: Literal[\"te\", \"tm\"] | None = frozen_field(default=None)\n\n    _inv_permittivity: jax.Array = frozen_field(default=None, init=False)  # type: ignore\n    _inv_permeability: jax.Array | float = frozen_field(default=None, init=False)  # type: ignore\n\n    def apply(\n        self: Self,\n        key: jax.Array,\n        inv_permittivities: jax.Array,\n        inv_permeabilities: jax.Array | float,\n    ) -&gt; Self:\n        if (\n            self.azimuth_angle != 0\n            or self.elevation_angle != 0\n            or self.max_angle_random_offset != 0\n            or self.max_vertical_offset != 0\n            or self.max_horizontal_offset != 0\n        ):\n            raise NotImplementedError()\n\n        self = super().apply(\n            key=key,\n            inv_permittivities=inv_permittivities,\n            inv_permeabilities=inv_permeabilities,\n        )\n        inv_permittivity_slice = inv_permittivities[*self.grid_slice]\n        if isinstance(inv_permeabilities, jax.Array) and inv_permeabilities.ndim &gt; 0:\n            inv_permeability_slice = inv_permeabilities[*self.grid_slice]\n        else:\n            inv_permeability_slice = inv_permeabilities\n\n        self = self.aset(\"_inv_permittivity\", inv_permittivity_slice)\n        self = self.aset(\"_inv_permeability\", inv_permeability_slice)\n\n        return self\n\n    def get_EH_variation(\n        self,\n        key: jax.Array,\n        inv_permittivities: jax.Array,\n        inv_permeabilities: jax.Array | float,\n    ) -&gt; tuple[\n        jax.Array,  # E: (3, *grid_shape)\n        jax.Array,  # H: (3, *grid_shape)\n        jax.Array,  # time_offset_E: (3, *grid_shape)\n        jax.Array,  # time_offset_H: (3, *grid_shape)\n    ]:\n        del key\n\n        center = jnp.asarray(\n            [round(self.grid_shape[self.horizontal_axis]), round(self.grid_shape[self.vertical_axis])], dtype=jnp.int32\n        )\n\n        inv_permittivity_slice = inv_permittivities[*self.grid_slice]\n        if isinstance(inv_permeabilities, jax.Array) and inv_permeabilities.ndim &gt; 0:\n            inv_permeability_slice = inv_permeabilities[*self.grid_slice]\n        else:\n            inv_permeability_slice = inv_permeabilities\n\n        raw_wave_vector = get_wave_vector_raw(\n            direction=self.direction,\n            propagation_axis=self.propagation_axis,\n        )\n        time_offset_E, time_offset_H = calculate_time_offset_yee(\n            center=center,\n            wave_vector=raw_wave_vector,\n            inv_permittivities=jnp.ones_like(inv_permittivity_slice),\n            inv_permeabilities=jnp.ones_like(inv_permeability_slice),\n            resolution=self._config.resolution,\n            time_step_duration=self._config.time_step_duration,\n        )\n\n        # compute mode\n        mode_E, mode_H, eff_index = compute_mode(\n            frequency=self.wave_character.frequency,\n            inv_permittivities=inv_permittivity_slice,\n            inv_permeabilities=inv_permeability_slice,  # type: ignore\n            resolution=self._config.resolution,\n            direction=self.direction,\n            mode_index=self.mode_index,\n        )\n\n        return mode_E, mode_H, time_offset_E, time_offset_H\n\n    def plot(self, save_path: str | Path):\n        if self._H is None or self._E is None:\n            raise Exception(\"Cannot plot mode without init to grid and apply params first\")\n\n        energy = compute_energy(\n            E=self._E,\n            H=self._H,\n            inv_permittivity=self._inv_permittivity,\n            inv_permeability=self._inv_permeability,\n        )\n        energy_2d = energy.squeeze().T\n\n        plt.clf()\n        fig = plt.figure(figsize=(10, 10))\n        levels = jnp.linspace(energy_2d.min(), energy_2d.max(), 11)[1:]\n        mode_cmap = \"inferno\"\n\n        # Add contour lines on top of the imshow plot\n        plt.contour(energy_2d, cmap=mode_cmap, alpha=0.5, levels=levels)\n        plt.gca().set_aspect(\"equal\")\n\n        plt.colorbar()\n\n        # Ensure the plot takes up the entire figure\n        plt.tight_layout(pad=0)\n\n        plt.savefig(save_path, bbox_inches=\"tight\", pad_inches=0)\n        plt.close(fig)\n</code></pre>"},{"location":"api/objects/sources/#fdtdx.objects.sources.HardConstantAmplitudePlanceSource","title":"<code>fdtdx.objects.sources.HardConstantAmplitudePlanceSource</code>","text":"<p>               Bases: <code>DirectionalPlaneSourceBase</code></p> Source code in <code>src/fdtdx/objects/sources/source.py</code> <pre><code>@extended_autoinit\nclass HardConstantAmplitudePlanceSource(DirectionalPlaneSourceBase):\n    amplitude: float = 1.0\n    fixed_E_polarization_vector: tuple[float, float, float] | None = None\n    fixed_H_polarization_vector: tuple[float, float, float] | None = None\n\n    def update_E(\n        self,\n        E: jax.Array,\n        inv_permittivities: jax.Array,\n        inv_permeabilities: jax.Array | float,\n        time_step: jax.Array,\n        inverse: bool,\n    ) -&gt; jax.Array:\n        del inv_permittivities, inv_permeabilities\n        if inverse:\n            return E\n        delta_t = self._config.time_step_duration\n        time_phase = 2 * jnp.pi * time_step * delta_t / self.wave_character.period + self.wave_character.phase_shift\n        magnitude = jnp.real(self.amplitude * jnp.exp(-1j * time_phase))\n        e_pol, _ = normalize_polarization_for_source(\n            direction=self.direction,\n            propagation_axis=self.propagation_axis,\n            fixed_E_polarization_vector=self.fixed_E_polarization_vector,\n            fixed_H_polarization_vector=self.fixed_E_polarization_vector,\n        )\n        E_update = e_pol[:, None, None, None] * magnitude\n\n        E = E.at[:, *self.grid_slice].set(E_update.astype(E.dtype))\n        return E\n\n    def update_H(\n        self,\n        H: jax.Array,\n        inv_permittivities: jax.Array,\n        inv_permeabilities: jax.Array | float,\n        time_step: jax.Array,\n        inverse: bool,\n    ):\n        del inv_permeabilities, inv_permittivities\n        if inverse:\n            return H\n        delta_t = self._config.time_step_duration\n        time_phase = 2 * jnp.pi * time_step * delta_t / self.wave_character.period + self.wave_character.phase_shift\n        magnitude = jnp.real(self.amplitude * jnp.exp(-1j * time_phase))\n        _, h_pol = normalize_polarization_for_source(\n            direction=self.direction,\n            propagation_axis=self.propagation_axis,\n            fixed_E_polarization_vector=self.fixed_E_polarization_vector,\n            fixed_H_polarization_vector=self.fixed_E_polarization_vector,\n        )\n        H_update = h_pol[:, None, None, None] * magnitude\n\n        H = H.at[:, *self.grid_slice].set(H_update.astype(H.dtype))\n        return H\n\n    def apply(\n        self,\n        key: jax.Array,\n        inv_permittivities: jax.Array,\n        inv_permeabilities: jax.Array | float,\n    ) -&gt; Self:\n        del key, inv_permittivities, inv_permeabilities\n        return self\n</code></pre>"},{"location":"api/objects/sources/#temporal-profiles","title":"Temporal Profiles","text":"<p>A temporal profile which exhibits just a single wave throughout the whole simulation time.</p> <p>A temporal pulse of a gaussian envelope.</p>"},{"location":"api/objects/sources/#fdtdx.objects.sources.SingleFrequencyProfile","title":"<code>fdtdx.objects.sources.SingleFrequencyProfile</code>","text":"<p>               Bases: <code>TemporalProfile</code></p> <p>Simple sinusoidal temporal profile at a single frequency.</p> Source code in <code>src/fdtdx/objects/sources/profile.py</code> <pre><code>@extended_autoinit\nclass SingleFrequencyProfile(TemporalProfile):\n    \"\"\"Simple sinusoidal temporal profile at a single frequency.\"\"\"\n\n    def get_amplitude(\n        self,\n        time: jax.Array,\n        period: float,\n        phase_shift: float = 0.0,\n    ) -&gt; jax.Array:\n        time_phase = 2 * jnp.pi * time / period + phase_shift\n        return jnp.sin(time_phase)\n</code></pre>"},{"location":"api/objects/sources/#fdtdx.objects.sources.GaussianPulseProfile","title":"<code>fdtdx.objects.sources.GaussianPulseProfile</code>","text":"<p>               Bases: <code>TemporalProfile</code></p> <p>Gaussian pulse temporal profile with carrier wave.</p> Source code in <code>src/fdtdx/objects/sources/profile.py</code> <pre><code>@extended_autoinit\nclass GaussianPulseProfile(TemporalProfile):\n    \"\"\"Gaussian pulse temporal profile with carrier wave.\"\"\"\n\n    spectral_width: float  # Width of the Gaussian envelope in frequency domain\n    center_frequency: float  # Center frequency of the pulse\n\n    def get_amplitude(\n        self,\n        time: jax.Array,\n        period: float,\n        phase_shift: float = 0.0,\n    ) -&gt; jax.Array:\n        del period\n        # Calculate envelope parameters\n        sigma_t = 1.0 / (2 * jnp.pi * self.spectral_width)\n        t0 = 6 * sigma_t  # Offset peak to avoid discontinuity at t=0\n\n        # Gaussian envelope\n        envelope = jnp.exp(-((time - t0) ** 2) / (2 * sigma_t**2))\n\n        # Carrier wave\n        carrier_phase = 2 * jnp.pi * self.center_frequency * time + phase_shift\n        carrier = jnp.sin(carrier_phase)\n\n        return envelope * carrier\n</code></pre>"},{"location":"api/objects/static_material/","title":"Static Materials with intricate shapes","text":"<p>This module contains a (currently rather small) collection of objects with a shape that is more intricate than a basic cuboid.</p> <p>An object with the shape of a cylinder.</p>"},{"location":"api/objects/static_material/#fdtdx.objects.static_material.Cylinder","title":"<code>fdtdx.objects.static_material.Cylinder</code>","text":"<p>               Bases: <code>StaticMultiMaterialObject</code></p> <p>A cylindrical optical fiber with configurable properties.</p> <p>This class represents a cylindrical fiber with customizable radius, material, and orientation. The fiber can be positioned along any of the three principal axes.</p> <p>Attributes:</p> Name Type Description <code>radius</code> <code>float</code> <p>The radius of the fiber in meter.</p> <code>material</code> <code>Material</code> <p>The material properties of the fiber.</p> <code>axis</code> <code>int</code> <p>The principal axis along which the fiber extends (0=x, 1=y, 2=z).</p> <code>partial_voxel_grid_shape</code> <code>PartialGridShape3D</code> <p>The shape of the voxel grid in grid units.</p> <code>partial_voxel_real_shape</code> <code>PartialRealShape3D</code> <p>The shape of the voxel grid in physical units.</p> <code>color</code> <code>tuple[float, float, float]</code> <p>RGB color tuple for visualization (default=LIGHT_GREY).</p> Source code in <code>src/fdtdx/objects/static_material/cylinder.py</code> <pre><code>@extended_autoinit\nclass Cylinder(StaticMultiMaterialObject):\n    \"\"\"A cylindrical optical fiber with configurable properties.\n\n    This class represents a cylindrical fiber with customizable radius, material,\n    and orientation. The fiber can be positioned along any of the three principal axes.\n\n    Attributes:\n        radius: The radius of the fiber in meter.\n        material: The material properties of the fiber.\n        axis: The principal axis along which the fiber extends (0=x, 1=y, 2=z).\n        partial_voxel_grid_shape: The shape of the voxel grid in grid units.\n        partial_voxel_real_shape: The shape of the voxel grid in physical units.\n        color: RGB color tuple for visualization (default=LIGHT_GREY).\n    \"\"\"\n\n    radius: float = field(kind=\"KW_ONLY\")  # type: ignore\n    material: Material = field(kind=\"KW_ONLY\")  # type: ignore\n    axis: int = field(kind=\"KW_ONLY\")  # type: ignore\n    partial_voxel_grid_shape: PartialGridShape3D = frozen_private_field(default=UNDEFINED_SHAPE_3D)\n    partial_voxel_real_shape: PartialRealShape3D = frozen_private_field(default=UNDEFINED_SHAPE_3D)\n    color: tuple[float, float, float] = LIGHT_GREY\n\n    @property\n    def horizontal_axis(self) -&gt; int:\n        \"\"\"Gets the horizontal axis perpendicular to the fiber axis.\n\n        Returns:\n            int: The index of the horizontal axis (0=x or 1=y).\n        \"\"\"\n        if self.axis == 0:\n            return 1\n        return 0\n\n    @property\n    def vertical_axis(self) -&gt; int:\n        \"\"\"Gets the vertical axis perpendicular to the fiber axis.\n\n        Returns:\n            int: The index of the vertical axis (1=y or 2=z).\n        \"\"\"\n        if self.axis == 2:\n            return 1\n        return 2\n\n    def place_on_grid(\n        self: Self,\n        grid_slice_tuple: SliceTuple3D,\n        config: SimulationConfig,\n        key: jax.Array,\n    ) -&gt; Self:\n        self = super().place_on_grid(\n            grid_slice_tuple=grid_slice_tuple,\n            config=config,\n            key=key,\n        )\n        permittivity_config = {\n            \"material\": self.material,\n        }\n        self = self.aset(\"permittivity_config\", permittivity_config)\n        return self\n\n    def get_voxel_mask_for_shape(self) -&gt; jax.Array:\n        width = self.grid_shape[self.vertical_axis]\n        height = self.grid_shape[self.horizontal_axis]\n        center = (height / 2, width / 2)\n        grid_radius_exact = self.radius / self._config.resolution\n        grid = (\n            jnp.stack(jnp.meshgrid(*map(jnp.arange, (width, height)), indexing=\"xy\"), axis=-1)\n            - jnp.asarray(center)\n            + 0.5\n        ) / jnp.asarray(grid_radius_exact)\n\n        mask = (grid**2).sum(axis=-1) &lt; 1\n        mask = jnp.expand_dims(mask, axis=self.axis)\n        return mask\n\n    def get_material_mapping(\n        self,\n    ) -&gt; jax.Array:\n        return jnp.zeros(\n            self.grid_shape,\n            dtype=jnp.int32,\n        )\n</code></pre>"},{"location":"api/objects/static_material/#fdtdx.objects.static_material.Cylinder.horizontal_axis","title":"<code>horizontal_axis: int</code>  <code>property</code>","text":"<p>Gets the horizontal axis perpendicular to the fiber axis.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the horizontal axis (0=x or 1=y).</p>"},{"location":"api/objects/static_material/#fdtdx.objects.static_material.Cylinder.vertical_axis","title":"<code>vertical_axis: int</code>  <code>property</code>","text":"<p>Gets the vertical axis perpendicular to the fiber axis.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the vertical axis (1=y or 2=z).</p>"},{"location":"tutorials/interface_compression/","title":"Gradient computation by time reversibility","text":"<p>FDTDX implements automatic differentiation by exploiting the time-reversibility of Maxwell's equations. You can find more details about the time-reversible gradient computation in our paper. </p> <p>For this tutorial, the important point to note is that during the forward simulation, the interface region between PML and actual simulation volume needs to be saved at every time step. Even though this is better than the standard implementation of AutoDiff (which would save the whole 3D volume at every time step), this can still lead to large memory requirements if the simulation is large or the simulation time long. </p> <p>As a remedy, we implement a compression mechanism for these saved fields. The compression settings can be adjusted in the simulation config: <pre><code>from fdtdx.config import GradientConfig, SimulationConfig\nfrom fdtdx.interfaces import (\n    DtypeConversion,\n    Recorder,\n    LinearReconstructEveryK\n)\nimport jax.numpy as jnp\n\ngradient_config = GradientConfig(\n    recorder=Recorder(\n        modules=[\n            LinearReconstructEveryK(2),\n            DtypeConversion(dtype=jnp.float16),\n        ]\n    )\n)\nconfig = SimulationConfig(\n    time=300e-15,\n    resolution=100e-9,\n    dtype=jnp.float32,\n    courant_factor=0.99,\n    gradient_config=gradient_config,  # &lt;- This needs to be set for gradient computation\n)\n</code></pre> Similarly to the constraint mappings, the recorder of the gradient config is defined by a list of modules, which are applied consecutively. In this example, the following two modules are used: - LinearReconstructEveryK: Firstly, this module only saves the boundary fields at every second time step. During reconstruction, the missing values are recomputed by linearly interpolating between the saved time steps. The attribute k=2 defines the step size. - DtypeConversion: The output of the previous module is converted to a different data type. In our example, the simulation runs with 32 bit floating point precision and the module converts these values to 16 bit precision, again saving 50% of the required memory.</p> <p>At the moment, these are the only two important compression modules implemented. Experience has shown that in almost all cases 8bit precision is also sufficient, namely the data type \"jnp.float8_e4m3fnuz\". </p> <p>Regarding the number of time steps, a rule of thumb is that 10 time steps per period should be saved for accurate results. Often lower saving intervals also suffice, but one needs to make sure that this is actually the case. So for example, if the simulation performs 30 time steps per period (this depends on the Courant-Friedrichs-Levy Condition), then a compression of LinearReconstructEveryK(3) should be used to save 10 time steps. The number of time steps per period can be computed by: <pre><code>from fdtdx import constants\nwavelength = 1.55e-6\nperiod = constants.wavelength_to_period(wavelength)\nsteps_per_period = period / config.time_step_duration\n</code></pre></p>"},{"location":"tutorials/interface_compression/#gradient-computation","title":"Gradient Computation","text":"<p>The actual gradient computation can be invoked using the standard jax.grad method on the fdtd_reversible function call. In pseudocode this might look something like this: <pre><code>def loss_function(params, ...)\n    arrays, new_objects, info = apply_params(arrays, objects, params, key)\n\n    _, arrays = reversible_fdtd(\n        arrays=arrays,\n        objects=new_objects,\n        config=config,\n        key=key,\n    )\n    loss = - figure_of_merit(arrays.detector_states)\n    return loss\n\ngrad_function = jax.grad(loss_fn)\ngrad_loss_wrt_params = grad_function(params)\n</code></pre> Of course figure_of_merit can be any objective function that should be optimized. The apply_params function internally calls the Parameter mapping of the device and sets the proper inverse permittivities for the simulation.</p>"},{"location":"tutorials/materials/","title":"Materials Guide","text":"<p>In FDTDX, objects can have different permittivities and permeabilities. Currently, the conductivity of all materials is assumed to be zero, but we are planning to implement conductive materials in the very near future.</p> <p>Also, currently neither dispersion nor non-linear materials are implemented. The implementation of dispersion is scheduled in the near-mid future and afterwards an implementation of non-linear materials will follow.</p> <p>This guide is currently very short and will be expanded with them implementations mentioned above.</p>"},{"location":"tutorials/materials/#uniformmaterial","title":"UniformMaterial","text":"<p>The most basic and also probably most useful object is the UniformMaterialObject. As the name suggests, it has a single material. <pre><code>from fdtdx import constants\nfrom fdtdx.objects import UniformMaterialObject\nfrom fdtdx.material import Material\nfrom fdtdx.core.plotting import colors\n\nuniform_obj = UniformMaterialObject(\n    partial_real_shape=(0.6e-6, 0.6e-6, 0.6e-6),\n    material=Material(permittivity=constants.relative_permittivity_silica),\n    # permeability is one by default\n    permeability=1.0,\n    color=colors.CYAN,\n    name=\"uniform_obj\",\n)\n</code></pre> The name and color attribute are only used for plotting and do not have any effect on the simulation.</p>"},{"location":"tutorials/materials/#device","title":"Device","text":"<p>For inverse design, it is necessary to model objects that can either be one or the other materials. In some applications, it might even be necessary to model objects consisting of more than two materials.</p> <p>In this example, we create a device consisting of voxels that are either air or polymer. <pre><code>material_config = {\n    \"Air\": Material(permittivity=constants.relative_permittivity_air),\n    \"Polymer\": Material(permittivity=constants.relative_permittivity_ma_N_1400_series),\n}\ndevice = Device(\n    name=\"Device\",\n    partial_real_shape=(1e-6, 1e-6, 1e-6),\n    material=material_config,\n    parameter_mapping=...,\n    partial_voxel_real_shape=(0.2e-6, 0.2e-6, 0.2e-6),\n)\n</code></pre> The device has a permittivity config, which defines the different permittivity options. This is currently only implemented for permittivity, but we will expand it in the future to metallic materials as well. </p> <p>The partial_voxel_real_shape argument specifies the size of the uniform material voxels within the device. In this case, voxels, of 200nm^3 have a single permittivity. Since the device has a shape of 1\u00b5m^3, there are 5x5x5=125 of these voxels within the device. </p> <p>Importantly, the size of the device needs to be divisible by the voxel size. Additionally, the voxel size needs to be suffiently larger than the resolution of the Yee-grid in the simulation. For example, if the resolution of the Yee-grid is also 200nm, then this simulation will not produce accurate results. As a rule of thumb, the resolution of the Yee-grid should be at least three times smaller than the size of the voxels.</p> <p>The device has one latent parameter for every voxel. Initially, these latent parameters are uniformly random in the interval [0, 1]. The constraint mapping defines how these latent parameters are mapped to actual inverse permittivity choices. A detailed guide on this topic can be found here.</p>"},{"location":"tutorials/object_placement/","title":"Object Placement Guide","text":"<p>This guide explains how to position objects in a simulation scene in FDTDX. The basic workflow looks like this: 1. Define a Simulation volume 2. Define objects and sizing/placement constraints between objects 3. Compute the actual position of objects in the simulation scene by using the place_objects function 4. Optional, but recommend: Plot the simulation scene using plot_setup() 5. Run a simulation</p>"},{"location":"tutorials/object_placement/#basic-positioning","title":"Basic Positioning","text":"<p>In FDTDX, objects are positioned either directly or relation to other objects through constraints. </p> <p>The first step should always be to define the size of the simulation volume.  FDTDX always uses metrical units, i.e. meters or grid positions referring to the Yee-grid,  which depends on the resolution used. <pre><code># create a simulation config\nconfig = SimulationConfig(\n    time=200e-15,\n    resolution=100e-9\n)\n# Create a simulation volume\nvolume = SimulationVolume(\n    partial_real_shape=(4e-6, 4e-6, 1.5e-6),\n)\n</code></pre></p> <p>We can already use the place_objects and plot_setup function to see the simulation volume. <pre><code>key = jax.random.PRNGKey(seed=42)  # random key\n# place objects and resolve constraints\nobjects, arrays, params, config, info = place_objects(\n    volume=volume,\n    config=config,\n    constraints=[],\n    key=key,\n)\n# plot the simulation scene\nfig = plot_setup(\n    config=config,\n    objects=objects,\n)\nfig.savefig(\"empty_scene.png\")\n</code></pre></p> <p></p> <p>Now, we can start to position some objects in the simulation scene.  We start with a substrate at the bottom of simulation.  To this end, we specify a constraint that aligns the objects in the z-axis (axis 2). The user should specify these constraints and collect them in a list.</p> <p>Positional constraints define an anchor point for both objects, which are constrainted to be at the same position.  The position of the anchor point can be specified in a relative coordinate system of each object.  A relative coordinate system means that a position of -1 would place the anchor at the left boundary of the object,  a position of 0 at the middle and a position of 1 at the right boundary.</p> <p>In case of the substrate, we want the lower boundary of the substrate to be aligned with the lower boundary of the simulation volume.  This ensures that the substrate is placed exactly at the bottom of the simulation.</p> <pre><code># create list of constraints\nplacement_constraints = []\n# create substrate\nsubstrate = UniformMaterialObject(\n    partial_real_shape=(None, None, 0.6e-6),\n    material=Material(permittivity=constants.relative_permittivity_silica),\n)\n# place at the bottom of simulation volume\nconstraint = substrate.place_relative_to(\n    volume,\n    axes=2,\n    own_positions=-1,\n    other_positions=-1,\n    margins=0,\n    grid_margins=0,\n)\nplacement_constraints.append(constraint)\n</code></pre> <p>The margins and grid_margins arguments are optional and would allow to speficy a fixed distance between  the anchor points. The margins argument is in units of meters, the grid margins in units of yee-grid cells. Plotting this again results in</p> <p></p> <p>There exist a number of useful shorthands for rapid placements. Some of them are listed below that place  a cube in the scene. The name and colors argument are only used for plotting.</p> <p><pre><code># place an object on top (z-axis / 2) of another object\ncube1 = UniformMaterialObject(\n    name=\"cube\",\n    color=colors.GREEN,\n    partial_real_shape=(0.5e-6, 0.5e-6, 0.5e-6),\n    material=Material(permittivity=constants.relative_permittivity_silicon),\n)\nplacement_constraints.append(\n    cube1.place_above(substrate)\n)\n\n# place an object at the center of another object\nplacement_constraints.append(\n    cube1.place_at_center(\n        substrate,\n        axes=(0, 1),\n    )\n)\n</code></pre> </p>"},{"location":"tutorials/object_placement/#size-configuration","title":"Size Configuration","text":"<p>Object sizes can be specified in a number of ways.  Firstly, one can directly set the size of an object in the init method. This can either be a specified in Yee-grid cells or metrical units (meter).</p> <p><pre><code># size in meters\ncube = UniformMaterialObject(\n    partial_real_shape=(0.3e-6, 1.0e-6, 0.7e-6),\n    ...\n)\n</code></pre> </p>"},{"location":"tutorials/object_placement/#size-in-grid-units","title":"Size in grid units","text":"<p><pre><code># size in grid units (each 100nm as defined in config above)\ncube = UniformMaterialObject(\n    partial_grid_shape=(4, 10, 2),\n    ...\n)\n</code></pre> </p>"},{"location":"tutorials/object_placement/#combination-of-grid-and-metrical-units","title":"Combination of grid and metrical units","text":"<p><pre><code># partial combination\ncube = UniformMaterialObject(\n    partial_real_shape=(None, 0.5e-6, None),\n    partial_grid_shape=(3, None, 1),\n    ...\n)\n</code></pre> </p>"},{"location":"tutorials/object_placement/#undefined-sizes-can-be-useful","title":"Undefined Sizes can be useful","text":"<p>If the size of an object is only partially defined and does not have any constraints, the size is set to the size of the simulation volume in the respective axis. We actually already used this behavior to define the substrate above.</p> <p><pre><code># z-axis is undefined, size is extended to simulation size\ncube = UniformMaterialObject(\n    partial_real_shape=(None, 0.5e-6, None),\n    partial_grid_shape=(3, None, None),\n    ...\n)\n# This now results in an error:\nplacement_constraints.append(\n    cube1.place_above(substrate)\n)\n</code></pre> Using this specification for the cube, we get the following error: <pre><code>Exception: Inconsisten grid shape (may be due to extension to infinity) at lower bound: 0 != 6 for axis=2, cube (&lt;class 'fdtdx.objects.material.UniformMaterialObject'&gt;). Object has a position constraint that puts the lower boundary at 6, but the lower bound was alreay computed to be at 0. This could be due to a missing size constraint/specification, which resulted in an expansion of the object to the simulation boundary (default size) or another constraint on this object.\n</code></pre> The error occurs, because we tried to place the cube above the substrate, which is no longer possible if the z-size of the cube is the whole simulation size. When we remove the problematic placement constraint, we get the correct simulation scene. </p>"},{"location":"tutorials/object_placement/#relative-sizing-constraint","title":"Relative Sizing constraint","text":"<p>The size of an object can also be set in relation to another object. To demonstrate this, we define a second cube, which should be placed above the substrate and have a 200nm distance to the other cube in the x-axis. <pre><code>cube2 = UniformMaterialObject(\n    name=\"cube2\",\n    color=colors.GREEN,\n    partial_real_shape=(0.5e-6, 0.5e-6, 0.5e-6),\n    material=Material(permittivity=constants.relative_permittivity_silicon),\n)\nplacement_constraints.extend([\n    cube2.place_above(substrate),\n    cube2.place_relative_to(\n        cube1,\n        axes=(0, 1),\n        own_positions=(1, 0),\n        other_positions=(-1, 0),\n        margins=(-200e-9, 0)\n    )\n])\n</code></pre> </p> <p>Now let's change the size definition of the second cube to a relative size constraint, which defines the y-size of the second cube as the size of the first cube in the z-axis. <pre><code>cube2 = UniformMaterialObject(\n    name=\"cube2\",\n    color=colors.GREEN,\n    partial_real_shape=(0.5e-6, None, 0.5e-6),\n    material=Material(permittivity=constants.relative_permittivity_silicon),\n)\nplacement_constraints.append(\n    cube2.size_relative_to(\n        cube1,\n        axes=1,\n        other_axes=2,\n        proportions=1.0,\n    )\n)\n</code></pre> </p> <p>Another useful convenience wrapper is the following: <pre><code>object1.same_size(object2, axes=(0,1))\n</code></pre></p>"},{"location":"tutorials/object_placement/#extending-objects-to-other-objects-or-simulation-boundaries","title":"Extending objects to other objects or Simulation boundaries","text":"<p>The last method to set the size of an object is to constrain the size, such that it extends up to another object in the simulation scene.</p> <p><pre><code># definition of first cube\ncube1 = UniformMaterialObject(\n    partial_real_shape=(0.5e-6, 0.5e-6, 0.5e-6),\n    name=\"cube\",\n    color=colors.GREEN,\n    material=Material(permittivity=constants.relative_permittivity_silicon),\n)\nplacement_constraints.append(\n    cube1.place_above(substrate)\n)\nplacement_constraints.append(\n    cube1.place_at_center(\n        substrate,\n        axes=(0, 1),\n    )\n)\ncube2 = UniformMaterialObject(\n    name=\"cube2\",\n    color=colors.MAGENTA,\n    partial_real_shape=(None, 0.5e-6, 0.5e-6),\n    material=Material(permittivity=constants.relative_permittivity_silicon),\n)\nplacement_constraints.extend([\n    cube2.place_above(substrate),\n    # place at center of y-axis\n    cube2.place_at_center(\n        cube1,\n        axes=1,\n    ),\n    # extend object up to first cube\n    cube2.extend_to(\n        cube1,\n        axis=0,\n        direction=\"+\",\n    )\n])\n</code></pre>  This constrains the size of cube2 such that its upper boundary (\"+\") extends directly up to cube1 in the x-axis.</p> <p>See the Objects API Reference for complete details on all positioning and sizing options.</p>"},{"location":"tutorials/parameter_mapping/","title":"Incorporation of Fabrication Constraints","text":"<p>When using inverse design with FDTDX, fabrication constraints have to be specified. The basic building block for an object optimizable by inverse design is a Device:</p> <pre><code>from fdtdx.objects.device import DiscreteDevice\nfrom fdtdx import constants\nfrom fdtdx.material import Material\n\nmaterial_config = {\n    \"Air\": Material(permittivity=constants.relative_permittivity_air),\n    \"Polymer\": Material(permittivity=constants.relative_permittivity_ma_N_1400_series),\n}\ndevice_scatter = DiscreteDevice(\n    name=\"Device\",\n    partial_real_shape=(1e-6, 1e-6, 1e-6),\n    material=material_config,\n    parameter_mapping=...,  # &lt;- This needs to be filled\n    partial_voxel_real_shape=(0.2e-6, 0.2e-6, 0.2e-6),\n)\n</code></pre> <p>The parameter mapping, which is left empty above, specifies the mapping from continuous latent parameters to materials used in the simulation.</p>"},{"location":"tutorials/parameter_mapping/#simple-example","title":"Simple example","text":"<p>At the beginning of optimization, the latent parameters of a device are always initialized randomly in the interval [0, 1]. Depending on the constraint mapping, these parameteters are mapped to inverse permittivities. Let's look at an example of a simple constraint mapping:</p> <p><pre><code>from fdtdx.objects.device import (\n    ParameterMapping,\n    ClosestIndex,\n    StandardToInversePermittivityRange,\n)\n\nmapping = ParameterMapping(\n    latent_transforms=[StandardToInversePermittivityRange(),],\n    discretization=ClosestIndex(),\n)\n</code></pre> The constraint mapping consists of a chain of modules, or in other words a chain of transformations followed by a discretization. Let's look at the modules in detail: - StandardToInversePermittivityRange(): This Module maps the default [0, 1] range to the range [\\(1 / \\varepsilon_{max}\\), \\(1 / \\varepsilon_{min}\\)], where \\(\\varepsilon_{max}\\) and \\(\\varepsilon_{min}\\) are the maximum and minimum permittivity specified in the permittivity config above. In other words, a latent variable of 0 would be mapped to the smallest inverse permittivity. Similarly, a value of 1 would be mapped to the largest possible inverse permittivity. - ClosestIndex(): This module finds the closest material to the mapped value output from the last module. In math-terms, this is $\\arg\\min_{\\varepsilon} |\\varepsilon - v| $, where \\(\\varepsilon\\) are the allowed permittivity values and \\(v\\) is the output of the last module. Importantly, this module does not return the \\(\\varepsilon\\) itself, but rather the index of \\(\\varepsilon\\) in the valid permittivities.</p> <p>This mapping constraints each voxel independently of the other voxels to the inverse permittivity of either air or polymer. However, often more elaborate fabrication constraints are needed in practice, which we introduce in the following sections.</p>"},{"location":"tutorials/parameter_mapping/#silicon-device-with-minimum-feature-constraint","title":"Silicon Device with minimum feature constraint","text":"<p>Now let's develop a constraint mapping for silicon photonics, which restricts the minimum feature size of a device.</p> <pre><code>from fdtdx.objects.device import (\n    ParameterMapping,\n    StandardToPlusOneMinusOneRange,\n    BrushConstraint2D,\n    circular_brush,\n)\n\nbrush_diameter_in_voxels = round(100e-9 / config.resolution)\nmapping = ParameterMapping(\n    latent_transforms=[StandardToPlusOneMinusOneRange()],\n    discretization=BrushConstraint2D(\n        brush=circular_brush(diameter=brush_diameter_in_voxels),\n        axis=2,\n    ),\n)\n</code></pre> <p>This mapping does not just quantize latent paramters to material indices, but also makes sure that the device adheres to a minimum feature size with regard to a specific brush. In this example, we used a circular brush of 100nm. In other words, one could \"paint\" the design with a brush of this size. In more detail: - StandardToPlusOneMinusOneRange(): maps the standard [0, 1] range to [-1, 1]. This is necessary, because the BrushConstraint2D expects the input to be in this range. - BrushConstraint2D(): maps the output of the previous module to permittivity indices similar to ClosestIndex() described above. However, it also makes sure that the design adheres to a minimum feature size regarding a specific brush shape. The axis argument defines the axis perpendicular to the 2D-design plane used. In our example, the perpendicular axis is 2 (in other words z/upwards). Therefore, the minimum feature constraint is enforced in the XY-plane.</p>"},{"location":"tutorials/parameter_mapping/#3d-fabrication-constraints-for-two-photon-polymerization","title":"3D Fabrication Constraints for Two-Photon-Polymerization","text":"<p>Lastly, let's look at a more involved constraint mapping used to Two-Photon Polymerization (2PP). In 2PP, a laser is focused on liquid monomer to harden the material. This allows the creation of fully three-dimensional designs. </p> <p>Resulting from this fabrication technique multiple constraints arise. Firstly, basic physical knowledge tells us that no material can float in the air without a connection to the ground. In 3D-design, we have to explicitly incorporate this constraint, which was not necessary in 2D (in 2D, all voxels are always connected to the ground). Secondly, there cannot be enclosed air cavities in a design for 2PP. An enclosed cavity would trap unpolmerized monomer and destroy the structural integrity of the design. However, in practice it is often not necessary to explicitly encode this constraint in the simulation. Enclosed cavities seldomly increase a figure of merit and therefore only rarely appear in an optimized design. But, it is important to check after the simulation is finished if any enclosed cavitities exist in the design.</p> <p><pre><code>from fdtdx.objects.device import (\n    ParameterMapping,\n    BOTTOM_Z_PADDING_CONFIG_REPEAT,\n    BinaryMedianFilterModule,\n    RemoveFloatingMaterial,\n    ClosestIndex,\n)\n\nmapping = ParameterMapping(\n    latent_transforms=[StandardToInversePermittivityRange(),],\n    discretization=ClosestIndex(),\n    post_transforms=[\n        BinaryMedianFilterModule(\n            kernel_sizes=(5, 5, 5),\n            padding_cfg=BOTTOM_Z_PADDING_CONFIG_REPEAT,\n            num_repeats=2,\n        ),\n        RemoveFloatingMaterial(),\n    ]\n)\n</code></pre> This constraint mapping is one possibility to implement constraints for 2PP. The two new modules are: - BinaryMedianFilterModule: This module does a soft enforcement of a minimum feature size by smoothing the incoming indices (produced by the previous module) with a median filter. The kernel size describes the size of the smoothing kernel in Yee grid cells. The padding config describes how the boundaries of the design are padded for smoothing. The BOTTOM_Z_PADDING_CONFIG_REPEAT uses a repeat of the boundary values except at the bottom of the design, where the design is padded with non-air-material. Heuristically, this gives the design better ground contact. The num_repeats argument specifies how often the smoothing filter is applied. - RemoveFloatingMaterial: As the name suggests, this module goes through the indices generated by the previous module (BinaryMedianFilter) and removes any floating material without ground connection. Ground connection is computed using a simple flood fill algorithm and all voxels with floating material are converted to air.</p>"}]}
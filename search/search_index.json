{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FDTDX Documentation FDTDX is a high-performance framework for electromagnetic simulations and inverse design of photonic devices. Built on JAX, it provides GPU-accelerated FDTD (Finite-Difference Time-Domain) simulations with automatic differentiation capabilities. Installation Install FDTDX using pip: pip install fdtdx For development installation, clone the repository and install in editable mode: git clone https://github.com/ymahlau/fdtdx cd fdtdx pip install -e . Key Features High Performance Computing Native GPU acceleration through JAX Multi-GPU scaling for large simulations Memory-efficient time-reversal implementation Optimized for large-scale inverse design Flexible boundary conditions with PML support Guides Object Placement Guide - Learn how to position and configure simulation objects Materials Guide - Learn how to use materials in FDTDX Fabrication Constraints - Learn how to use the parameter mapping API to include fabrication constraints Interface Compression - Learn how to use The compresion API to compute gradients with reversible autodiff See the examples folder for complete scripts for inverse design in FDTDX More guides will follow shortly Citation If you find this repository helpful for your work, please consider citing: @article { schubert2024quantized , title = {Quantized Inverse Design for Photonic Integrated Circuits} , author = {Schubert, Frederik and Mahlau, Yannik and Bethmann, Konrad and Hartmann, Fabian and Caspary, Reinhard and Munderloh, Marco and Ostermann, J{\\\"o}rn and Rosenhahn, Bodo} , journal = {arXiv preprint arXiv:2407.10273} , year = {2024} }","title":"Home"},{"location":"#fdtdx-documentation","text":"FDTDX is a high-performance framework for electromagnetic simulations and inverse design of photonic devices. Built on JAX, it provides GPU-accelerated FDTD (Finite-Difference Time-Domain) simulations with automatic differentiation capabilities.","title":"FDTDX Documentation"},{"location":"#installation","text":"Install FDTDX using pip: pip install fdtdx For development installation, clone the repository and install in editable mode: git clone https://github.com/ymahlau/fdtdx cd fdtdx pip install -e .","title":"Installation"},{"location":"#key-features","text":"","title":"Key Features"},{"location":"#high-performance-computing","text":"Native GPU acceleration through JAX Multi-GPU scaling for large simulations Memory-efficient time-reversal implementation Optimized for large-scale inverse design Flexible boundary conditions with PML support","title":"High Performance Computing"},{"location":"#guides","text":"Object Placement Guide - Learn how to position and configure simulation objects Materials Guide - Learn how to use materials in FDTDX Fabrication Constraints - Learn how to use the parameter mapping API to include fabrication constraints Interface Compression - Learn how to use The compresion API to compute gradients with reversible autodiff See the examples folder for complete scripts for inverse design in FDTDX More guides will follow shortly","title":"Guides"},{"location":"#citation","text":"If you find this repository helpful for your work, please consider citing: @article { schubert2024quantized , title = {Quantized Inverse Design for Photonic Integrated Circuits} , author = {Schubert, Frederik and Mahlau, Yannik and Bethmann, Konrad and Hartmann, Fabian and Caspary, Reinhard and Munderloh, Marco and Ostermann, J{\\\"o}rn and Rosenhahn, Bodo} , journal = {arXiv preprint arXiv:2407.10273} , year = {2024} }","title":"Citation"},{"location":"advanced/norms/","text":"Conventions and normalizations used in FDTDX Where is the origin? The origin is at the bottom left front corner of the simulation and corresponds to indices (0, 0, 0) in all arrays. Where is up? In FDTDX, we assume that the following correspond to forward, sideways and up: - For propagation in x-axis, sideways is the y-axis, and up is the z-axis - For propagation in y-axis, sideways is the x-axis, and up is the z-axis - For propagation in z-axis, sideways is the x-axis, and up is the y-axis This convention is independent of the direction (\"+\", \"-\") of propagation. Which direction to go? The forward direction (\"+\") corresponds to an increase of the index in an array. For example, from the index 5, the index 10 can be reached by going in the forward direction. Vice versa, \"-\" corresponds to backwards and index 5 can be reached from index 10 in this direction. Physical constants For FDTDX, we assume that the free space permittivity ( \\(\\varepsilon_{0}\\) ) and permeability ( \\(\\mu_{0}\\) ) are 1.0. This convention can be used because FDTDX is scale-invariant (at least for linear materials). If more complicated material models are introduced enventually, this convention might have to be removed. For everything else, we use metrical units. For example, length is measured in meter, time in seconds, frequency in 1/second. Light speed is 299792458 m/s.","title":"Norms"},{"location":"advanced/norms/#conventions-and-normalizations-used-in-fdtdx","text":"","title":"Conventions and normalizations used in FDTDX"},{"location":"advanced/norms/#where-is-the-origin","text":"The origin is at the bottom left front corner of the simulation and corresponds to indices (0, 0, 0) in all arrays.","title":"Where is the origin?"},{"location":"advanced/norms/#where-is-up","text":"In FDTDX, we assume that the following correspond to forward, sideways and up: - For propagation in x-axis, sideways is the y-axis, and up is the z-axis - For propagation in y-axis, sideways is the x-axis, and up is the z-axis - For propagation in z-axis, sideways is the x-axis, and up is the y-axis This convention is independent of the direction (\"+\", \"-\") of propagation.","title":"Where is up?"},{"location":"advanced/norms/#which-direction-to-go","text":"The forward direction (\"+\") corresponds to an increase of the index in an array. For example, from the index 5, the index 10 can be reached by going in the forward direction. Vice versa, \"-\" corresponds to backwards and index 5 can be reached from index 10 in this direction.","title":"Which direction to go?"},{"location":"advanced/norms/#physical-constants","text":"For FDTDX, we assume that the free space permittivity ( \\(\\varepsilon_{0}\\) ) and permeability ( \\(\\mu_{0}\\) ) are 1.0. This convention can be used because FDTDX is scale-invariant (at least for linear materials). If more complicated material models are introduced enventually, this convention might have to be removed. For everything else, we use metrical units. For example, length is measured in meter, time in seconds, frequency in 1/second. Light speed is 299792458 m/s.","title":"Physical constants"},{"location":"api/internal/compression/","text":"Compression Base Classes fdtdx.interfaces.modules.CompressionModule Bases: TreeClass , ABC Abstract base class for compression modules that process simulation data. This class provides an interface for modules that compress and decompress field data during FDTD simulations. Implementations can perform operations like quantization, dimensionality reduction, or other compression techniques. compress abstractmethod compress ( values : dict [ str , Array ], state : RecordingState , key : Array , ) -> tuple [ dict [ str , jax . Array ], RecordingState ] Compress field values at the current time step. Parameters: values ( dict [ str , Array ] ) \u2013 Dictionary mapping field names to their values. state ( RecordingState ) \u2013 Current recording state. key ( Array ) \u2013 Random key for stochastic operations. Returns: tuple [ dict [ str , Array ], RecordingState ] \u2013 tuple[dict[str, jax.Array], RecordingState]: Tuple containing: - Dictionary of compressed field values - Updated recording state Source code in src/fdtdx/interfaces/modules.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 @abstractmethod def compress ( self , values : dict [ str , jax . Array ], state : RecordingState , key : jax . Array , ) -> tuple [ dict [ str , jax . Array ], # compressed data RecordingState , # updated recording state ]: \"\"\"Compress field values at the current time step. Args: values (dict[str, jax.Array]): Dictionary mapping field names to their values. state (RecordingState): Current recording state. key (jax.Array): Random key for stochastic operations. Returns: tuple[dict[str, jax.Array], RecordingState]: Tuple containing: - Dictionary of compressed field values - Updated recording state \"\"\" del values , state , key raise NotImplementedError () decompress abstractmethod decompress ( values : dict [ str , Array ], state : RecordingState , key : Array , ) -> dict [ str , jax . Array ] Decompress field values back to their original form. Parameters: values ( dict [ str , Array ] ) \u2013 Dictionary mapping field names to their compressed values. state ( RecordingState ) \u2013 Current recording state. key ( Array ) \u2013 Random key for stochastic operations. Returns: dict [ str , Array ] \u2013 dict[str, jax.Array]: Dictionary mapping field names to their decompressed values. Source code in src/fdtdx/interfaces/modules.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @abstractmethod def decompress ( self , values : dict [ str , jax . Array ], state : RecordingState , key : jax . Array , ) -> dict [ str , jax . Array ]: \"\"\"Decompress field values back to their original form. Args: values (dict[str, jax.Array]): Dictionary mapping field names to their compressed values. state (RecordingState): Current recording state. key (jax.Array): Random key for stochastic operations. Returns: dict[str, jax.Array]: Dictionary mapping field names to their decompressed values. \"\"\" del ( values , state , key , ) raise NotImplementedError () init_shapes abstractmethod init_shapes ( input_shape_dtypes : dict [ str , ShapeDtypeStruct ], ) -> tuple [ Self , dict [ str , jax . ShapeDtypeStruct ], dict [ str , jax . ShapeDtypeStruct ], ] Initialize shapes and sizes for the compression module. Parameters: input_shape_dtypes ( dict [ str , ShapeDtypeStruct ] ) \u2013 Dictionary mapping field names to their input shapes/dtypes. Returns: tuple [ Self , dict [ str , ShapeDtypeStruct ], dict [ str , ShapeDtypeStruct ]] \u2013 tuple[Self, dict[str, jax.ShapeDtypeStruct], dict[str, jax.ShapeDtypeStruct]]: Tuple containing: - Self: Updated instance of the compression module - Dictionary mapping field names to their output shapes/dtypes - Dictionary mapping field names to their state shapes/dtypes Source code in src/fdtdx/interfaces/modules.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @abstractmethod def init_shapes ( self , input_shape_dtypes : dict [ str , jax . ShapeDtypeStruct ], ) -> tuple [ Self , dict [ str , jax . ShapeDtypeStruct ], # data dict [ str , jax . ShapeDtypeStruct ], # state shapes/dtypes ]: \"\"\"Initialize shapes and sizes for the compression module. Args: input_shape_dtypes (dict[str, jax.ShapeDtypeStruct]): Dictionary mapping field names to their input shapes/dtypes. Returns: tuple[Self, dict[str, jax.ShapeDtypeStruct], dict[str, jax.ShapeDtypeStruct]]: Tuple containing: - Self: Updated instance of the compression module - Dictionary mapping field names to their output shapes/dtypes - Dictionary mapping field names to their state shapes/dtypes \"\"\" del input_shape_dtypes raise NotImplementedError () fdtdx.interfaces.time_filter.TimeStepFilter Bases: TreeClass , ABC Abstract base class for filtering and processing time steps in FDTD simulations. This class provides an interface for filters that process simulation data at specific time steps. Implementations can perform operations like downsampling, collation, or other temporal processing of field data. compress abstractmethod compress ( values : dict [ str , Array ], state : RecordingState , time_idx : Array , key : Array , ) -> tuple [ dict [ str , jax . Array ], RecordingState ] Compress field values at a given time step. Parameters: values ( dict [ str , Array ] ) \u2013 Dictionary mapping field names to their values. state ( RecordingState ) \u2013 Current recording state. time_idx ( Array ) \u2013 Current time step index. key ( Array ) \u2013 Random key for stochastic operations. Returns: tuple [ dict [ str , Array ], RecordingState ] \u2013 tuple[dict[str, jax.Array], RecordingState]: Tuple containing: - Dictionary of compressed field values - Updated recording state Source code in src/fdtdx/interfaces/time_filter.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @abstractmethod def compress ( self , values : dict [ str , jax . Array ], state : RecordingState , time_idx : jax . Array , # scalar key : jax . Array , ) -> tuple [ dict [ str , jax . Array ], RecordingState , # updated recording state ]: \"\"\"Compress field values at a given time step. Args: values (dict[str, jax.Array]): Dictionary mapping field names to their values. state (RecordingState): Current recording state. time_idx (jax.Array): Current time step index. key (jax.Array): Random key for stochastic operations. Returns: tuple[dict[str, jax.Array], RecordingState]: Tuple containing: - Dictionary of compressed field values - Updated recording state \"\"\" del values , state , time_idx , key raise NotImplementedError () decompress abstractmethod decompress ( values : list [ dict [ str , Array ]], state : RecordingState , arr_indices : Array , time_idx : Array , key : Array , ) -> dict [ str , jax . Array ] Decompress field values to reconstruct data for a time step. Parameters: values ( list [ dict [ str , Array ]] ) \u2013 List of dictionaries containing array values needed for reconstruction. state ( RecordingState ) \u2013 Current recording state. arr_indices ( Array ) \u2013 Array indices needed for reconstruction. time_idx ( Array ) \u2013 Time step index to reconstruct. scalar value. key ( Array ) \u2013 Random key for stochastic operations. Returns: dict [ str , Array ] \u2013 dict[str, jax.Array]: Dictionary of reconstructed field values. Source code in src/fdtdx/interfaces/time_filter.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 @abstractmethod def decompress ( self , values : list [ dict [ str , jax . Array ]], # array values requested above state : RecordingState , arr_indices : jax . Array , time_idx : jax . Array , # scalar key : jax . Array , ) -> dict [ str , jax . Array ]: \"\"\"Decompress field values to reconstruct data for a time step. Args: values (list[dict[str, jax.Array]]): List of dictionaries containing array values needed for reconstruction. state (RecordingState): Current recording state. arr_indices (jax.Array): Array indices needed for reconstruction. time_idx (jax.Array): Time step index to reconstruct. scalar value. key (jax.Array): Random key for stochastic operations. Returns: dict[str, jax.Array]: Dictionary of reconstructed field values. \"\"\" del values , state , arr_indices , time_idx , key raise NotImplementedError () indices_to_decompress abstractmethod indices_to_decompress ( time_idx : Array ) -> jax . Array Get array indices needed to reconstruct data for a given time step. Parameters: time_idx ( Array ) \u2013 Time step index to reconstruct. Returns: Array \u2013 jax.Array: Array of indices needed to reconstruct the data for this time step. Source code in src/fdtdx/interfaces/time_filter.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @abstractmethod def indices_to_decompress ( self , time_idx : jax . Array , # scalar ) -> jax . Array : # 1d-list of array indices necessary to reconstruct \"\"\"Get array indices needed to reconstruct data for a given time step. Args: time_idx (jax.Array): Time step index to reconstruct. Returns: jax.Array: Array of indices needed to reconstruct the data for this time step. \"\"\" del time_idx raise NotImplementedError () init_shapes abstractmethod init_shapes ( input_shape_dtypes : dict [ str , ShapeDtypeStruct ], time_steps_max : int , ) -> tuple [ Self , int , dict [ str , jax . ShapeDtypeStruct ], dict [ str , jax . ShapeDtypeStruct ], ] Initialize shapes and sizes for the time step filter. Parameters: input_shape_dtypes ( dict [ str , ShapeDtypeStruct ] ) \u2013 Dictionary mapping field names to their shape/dtype information. time_steps_max ( int ) \u2013 Maximum number of time steps in the simulation. Returns: tuple [ Self , int , dict [ str , ShapeDtypeStruct ], dict [ str , ShapeDtypeStruct ]] \u2013 tuple[Self, int, dict[str, jax.ShapeDtypeStruct], dict[str, jax.ShapeDtypeStruct]]: A tuple containing: - Updated filter instance - Size of array for storing filtered data - Dictionary of data shapes/dtypes - Dictionary of state shapes/dtypes Source code in src/fdtdx/interfaces/time_filter.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @abstractmethod def init_shapes ( self , input_shape_dtypes : dict [ str , jax . ShapeDtypeStruct ], time_steps_max : int , # maximum number of time steps ) -> tuple [ Self , int , # array size (number of latent time steps) dict [ str , jax . ShapeDtypeStruct ], # data dict [ str , jax . ShapeDtypeStruct ], # state shapes ]: \"\"\"Initialize shapes and sizes for the time step filter. Args: input_shape_dtypes (dict[str, jax.ShapeDtypeStruct]): Dictionary mapping field names to their shape/dtype information. time_steps_max (int): Maximum number of time steps in the simulation. Returns: tuple[Self, int, dict[str, jax.ShapeDtypeStruct], dict[str, jax.ShapeDtypeStruct]]: A tuple containing: - Updated filter instance - Size of array for storing filtered data - Dictionary of data shapes/dtypes - Dictionary of state shapes/dtypes \"\"\" del input_shape_dtypes , time_steps_max raise NotImplementedError () time_to_array_index abstractmethod time_to_array_index ( time_idx : int ) -> int Convert a time step index to its corresponding array index. Parameters: time_idx ( int ) \u2013 Time step index to convert. Returns: int ( int ) \u2013 The corresponding array index if the time step is not filtered, or -1 if the time step is filtered out. Source code in src/fdtdx/interfaces/time_filter.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @abstractmethod def time_to_array_index ( self , time_idx : int , # scalar ) -> int : # array index if not filtered, else -1 \"\"\"Convert a time step index to its corresponding array index. Args: time_idx (int): Time step index to convert. Returns: int: The corresponding array index if the time step is not filtered, or -1 if the time step is filtered out. \"\"\" del time_idx raise NotImplementedError ()","title":"Compression Base Classes"},{"location":"api/internal/compression/#compression-base-classes","text":"","title":"Compression Base Classes"},{"location":"api/internal/compression/#fdtdx.interfaces.modules.CompressionModule","text":"Bases: TreeClass , ABC Abstract base class for compression modules that process simulation data. This class provides an interface for modules that compress and decompress field data during FDTD simulations. Implementations can perform operations like quantization, dimensionality reduction, or other compression techniques.","title":"CompressionModule"},{"location":"api/internal/compression/#fdtdx.interfaces.modules.CompressionModule.compress","text":"compress ( values : dict [ str , Array ], state : RecordingState , key : Array , ) -> tuple [ dict [ str , jax . Array ], RecordingState ] Compress field values at the current time step. Parameters: values ( dict [ str , Array ] ) \u2013 Dictionary mapping field names to their values. state ( RecordingState ) \u2013 Current recording state. key ( Array ) \u2013 Random key for stochastic operations. Returns: tuple [ dict [ str , Array ], RecordingState ] \u2013 tuple[dict[str, jax.Array], RecordingState]: Tuple containing: - Dictionary of compressed field values - Updated recording state Source code in src/fdtdx/interfaces/modules.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 @abstractmethod def compress ( self , values : dict [ str , jax . Array ], state : RecordingState , key : jax . Array , ) -> tuple [ dict [ str , jax . Array ], # compressed data RecordingState , # updated recording state ]: \"\"\"Compress field values at the current time step. Args: values (dict[str, jax.Array]): Dictionary mapping field names to their values. state (RecordingState): Current recording state. key (jax.Array): Random key for stochastic operations. Returns: tuple[dict[str, jax.Array], RecordingState]: Tuple containing: - Dictionary of compressed field values - Updated recording state \"\"\" del values , state , key raise NotImplementedError ()","title":"compress"},{"location":"api/internal/compression/#fdtdx.interfaces.modules.CompressionModule.decompress","text":"decompress ( values : dict [ str , Array ], state : RecordingState , key : Array , ) -> dict [ str , jax . Array ] Decompress field values back to their original form. Parameters: values ( dict [ str , Array ] ) \u2013 Dictionary mapping field names to their compressed values. state ( RecordingState ) \u2013 Current recording state. key ( Array ) \u2013 Random key for stochastic operations. Returns: dict [ str , Array ] \u2013 dict[str, jax.Array]: Dictionary mapping field names to their decompressed values. Source code in src/fdtdx/interfaces/modules.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @abstractmethod def decompress ( self , values : dict [ str , jax . Array ], state : RecordingState , key : jax . Array , ) -> dict [ str , jax . Array ]: \"\"\"Decompress field values back to their original form. Args: values (dict[str, jax.Array]): Dictionary mapping field names to their compressed values. state (RecordingState): Current recording state. key (jax.Array): Random key for stochastic operations. Returns: dict[str, jax.Array]: Dictionary mapping field names to their decompressed values. \"\"\" del ( values , state , key , ) raise NotImplementedError ()","title":"decompress"},{"location":"api/internal/compression/#fdtdx.interfaces.modules.CompressionModule.init_shapes","text":"init_shapes ( input_shape_dtypes : dict [ str , ShapeDtypeStruct ], ) -> tuple [ Self , dict [ str , jax . ShapeDtypeStruct ], dict [ str , jax . ShapeDtypeStruct ], ] Initialize shapes and sizes for the compression module. Parameters: input_shape_dtypes ( dict [ str , ShapeDtypeStruct ] ) \u2013 Dictionary mapping field names to their input shapes/dtypes. Returns: tuple [ Self , dict [ str , ShapeDtypeStruct ], dict [ str , ShapeDtypeStruct ]] \u2013 tuple[Self, dict[str, jax.ShapeDtypeStruct], dict[str, jax.ShapeDtypeStruct]]: Tuple containing: - Self: Updated instance of the compression module - Dictionary mapping field names to their output shapes/dtypes - Dictionary mapping field names to their state shapes/dtypes Source code in src/fdtdx/interfaces/modules.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @abstractmethod def init_shapes ( self , input_shape_dtypes : dict [ str , jax . ShapeDtypeStruct ], ) -> tuple [ Self , dict [ str , jax . ShapeDtypeStruct ], # data dict [ str , jax . ShapeDtypeStruct ], # state shapes/dtypes ]: \"\"\"Initialize shapes and sizes for the compression module. Args: input_shape_dtypes (dict[str, jax.ShapeDtypeStruct]): Dictionary mapping field names to their input shapes/dtypes. Returns: tuple[Self, dict[str, jax.ShapeDtypeStruct], dict[str, jax.ShapeDtypeStruct]]: Tuple containing: - Self: Updated instance of the compression module - Dictionary mapping field names to their output shapes/dtypes - Dictionary mapping field names to their state shapes/dtypes \"\"\" del input_shape_dtypes raise NotImplementedError ()","title":"init_shapes"},{"location":"api/internal/compression/#fdtdx.interfaces.time_filter.TimeStepFilter","text":"Bases: TreeClass , ABC Abstract base class for filtering and processing time steps in FDTD simulations. This class provides an interface for filters that process simulation data at specific time steps. Implementations can perform operations like downsampling, collation, or other temporal processing of field data.","title":"TimeStepFilter"},{"location":"api/internal/compression/#fdtdx.interfaces.time_filter.TimeStepFilter.compress","text":"compress ( values : dict [ str , Array ], state : RecordingState , time_idx : Array , key : Array , ) -> tuple [ dict [ str , jax . Array ], RecordingState ] Compress field values at a given time step. Parameters: values ( dict [ str , Array ] ) \u2013 Dictionary mapping field names to their values. state ( RecordingState ) \u2013 Current recording state. time_idx ( Array ) \u2013 Current time step index. key ( Array ) \u2013 Random key for stochastic operations. Returns: tuple [ dict [ str , Array ], RecordingState ] \u2013 tuple[dict[str, jax.Array], RecordingState]: Tuple containing: - Dictionary of compressed field values - Updated recording state Source code in src/fdtdx/interfaces/time_filter.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @abstractmethod def compress ( self , values : dict [ str , jax . Array ], state : RecordingState , time_idx : jax . Array , # scalar key : jax . Array , ) -> tuple [ dict [ str , jax . Array ], RecordingState , # updated recording state ]: \"\"\"Compress field values at a given time step. Args: values (dict[str, jax.Array]): Dictionary mapping field names to their values. state (RecordingState): Current recording state. time_idx (jax.Array): Current time step index. key (jax.Array): Random key for stochastic operations. Returns: tuple[dict[str, jax.Array], RecordingState]: Tuple containing: - Dictionary of compressed field values - Updated recording state \"\"\" del values , state , time_idx , key raise NotImplementedError ()","title":"compress"},{"location":"api/internal/compression/#fdtdx.interfaces.time_filter.TimeStepFilter.decompress","text":"decompress ( values : list [ dict [ str , Array ]], state : RecordingState , arr_indices : Array , time_idx : Array , key : Array , ) -> dict [ str , jax . Array ] Decompress field values to reconstruct data for a time step. Parameters: values ( list [ dict [ str , Array ]] ) \u2013 List of dictionaries containing array values needed for reconstruction. state ( RecordingState ) \u2013 Current recording state. arr_indices ( Array ) \u2013 Array indices needed for reconstruction. time_idx ( Array ) \u2013 Time step index to reconstruct. scalar value. key ( Array ) \u2013 Random key for stochastic operations. Returns: dict [ str , Array ] \u2013 dict[str, jax.Array]: Dictionary of reconstructed field values. Source code in src/fdtdx/interfaces/time_filter.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 @abstractmethod def decompress ( self , values : list [ dict [ str , jax . Array ]], # array values requested above state : RecordingState , arr_indices : jax . Array , time_idx : jax . Array , # scalar key : jax . Array , ) -> dict [ str , jax . Array ]: \"\"\"Decompress field values to reconstruct data for a time step. Args: values (list[dict[str, jax.Array]]): List of dictionaries containing array values needed for reconstruction. state (RecordingState): Current recording state. arr_indices (jax.Array): Array indices needed for reconstruction. time_idx (jax.Array): Time step index to reconstruct. scalar value. key (jax.Array): Random key for stochastic operations. Returns: dict[str, jax.Array]: Dictionary of reconstructed field values. \"\"\" del values , state , arr_indices , time_idx , key raise NotImplementedError ()","title":"decompress"},{"location":"api/internal/compression/#fdtdx.interfaces.time_filter.TimeStepFilter.indices_to_decompress","text":"indices_to_decompress ( time_idx : Array ) -> jax . Array Get array indices needed to reconstruct data for a given time step. Parameters: time_idx ( Array ) \u2013 Time step index to reconstruct. Returns: Array \u2013 jax.Array: Array of indices needed to reconstruct the data for this time step. Source code in src/fdtdx/interfaces/time_filter.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 @abstractmethod def indices_to_decompress ( self , time_idx : jax . Array , # scalar ) -> jax . Array : # 1d-list of array indices necessary to reconstruct \"\"\"Get array indices needed to reconstruct data for a given time step. Args: time_idx (jax.Array): Time step index to reconstruct. Returns: jax.Array: Array of indices needed to reconstruct the data for this time step. \"\"\" del time_idx raise NotImplementedError ()","title":"indices_to_decompress"},{"location":"api/internal/compression/#fdtdx.interfaces.time_filter.TimeStepFilter.init_shapes","text":"init_shapes ( input_shape_dtypes : dict [ str , ShapeDtypeStruct ], time_steps_max : int , ) -> tuple [ Self , int , dict [ str , jax . ShapeDtypeStruct ], dict [ str , jax . ShapeDtypeStruct ], ] Initialize shapes and sizes for the time step filter. Parameters: input_shape_dtypes ( dict [ str , ShapeDtypeStruct ] ) \u2013 Dictionary mapping field names to their shape/dtype information. time_steps_max ( int ) \u2013 Maximum number of time steps in the simulation. Returns: tuple [ Self , int , dict [ str , ShapeDtypeStruct ], dict [ str , ShapeDtypeStruct ]] \u2013 tuple[Self, int, dict[str, jax.ShapeDtypeStruct], dict[str, jax.ShapeDtypeStruct]]: A tuple containing: - Updated filter instance - Size of array for storing filtered data - Dictionary of data shapes/dtypes - Dictionary of state shapes/dtypes Source code in src/fdtdx/interfaces/time_filter.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @abstractmethod def init_shapes ( self , input_shape_dtypes : dict [ str , jax . ShapeDtypeStruct ], time_steps_max : int , # maximum number of time steps ) -> tuple [ Self , int , # array size (number of latent time steps) dict [ str , jax . ShapeDtypeStruct ], # data dict [ str , jax . ShapeDtypeStruct ], # state shapes ]: \"\"\"Initialize shapes and sizes for the time step filter. Args: input_shape_dtypes (dict[str, jax.ShapeDtypeStruct]): Dictionary mapping field names to their shape/dtype information. time_steps_max (int): Maximum number of time steps in the simulation. Returns: tuple[Self, int, dict[str, jax.ShapeDtypeStruct], dict[str, jax.ShapeDtypeStruct]]: A tuple containing: - Updated filter instance - Size of array for storing filtered data - Dictionary of data shapes/dtypes - Dictionary of state shapes/dtypes \"\"\" del input_shape_dtypes , time_steps_max raise NotImplementedError ()","title":"init_shapes"},{"location":"api/internal/compression/#fdtdx.interfaces.time_filter.TimeStepFilter.time_to_array_index","text":"time_to_array_index ( time_idx : int ) -> int Convert a time step index to its corresponding array index. Parameters: time_idx ( int ) \u2013 Time step index to convert. Returns: int ( int ) \u2013 The corresponding array index if the time step is not filtered, or -1 if the time step is filtered out. Source code in src/fdtdx/interfaces/time_filter.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @abstractmethod def time_to_array_index ( self , time_idx : int , # scalar ) -> int : # array index if not filtered, else -1 \"\"\"Convert a time step index to its corresponding array index. Args: time_idx (int): Time step index to convert. Returns: int: The corresponding array index if the time step is not filtered, or -1 if the time step is filtered out. \"\"\" del time_idx raise NotImplementedError ()","title":"time_to_array_index"},{"location":"api/internal/detector/","text":"Detector Base Class fdtdx.objects.detectors.detector.Detector Bases: SimulationObject , ABC Base class for electromagnetic field detectors in FDTD simulations. This class provides core functionality for recording and analyzing electromagnetic field data during FDTD simulations. It supports flexible timing control, data collection intervals, and visualization of results. Attributes: dtype ( dtype ) \u2013 Data type for detector arrays, defaults to float32. exact_interpolation ( bool ) \u2013 Whether to use exact field interpolation. Defaults to True. inverse ( bool ) \u2013 Whether to record fields in inverse time order. Defaults to false. switch ( OnOffSwitch ) \u2013 This switch controls the time steps that the detector is on, i.e. records data. Defaults to all time steps. plot ( bool ) \u2013 Whether to generate plots of recorded data. Defaults to true. if_inverse_plot_backwards ( bool ) \u2013 Plot inverse data in reverse time order. num_video_workers ( int | None ) \u2013 Number of workers for video generation. If None (default), then no multiprocessing is used. Note that the combination of multiprocessing and matplotlib is known to produce problems and can cause the entire system to freeze. It does make the video generation much faster though. color ( tuple [ float , float , float ] | None ) \u2013 RGB color for plotting. Defaults to light green. plot_interpolation ( str ) \u2013 Interpolation method for plots. Defualts to \"gaussian\". plot_dpi ( int | None ) \u2013 DPI resolution for plots. Defaults to None. num_time_steps_recorded property num_time_steps_recorded : int Gets the total number of time steps that will be recorded. Returns: int ( int ) \u2013 Number of time steps where detector will record data. Raises: Exception \u2013 If detector is not yet initialized. draw_plot draw_plot ( state : dict [ str , ndarray ], progress : Progress | None = None , ) -> dict [ str , Figure | str ] Generates plots or videos from recorded detector data. Creates visualizations based on dimensionality of recorded data and detector configuration. Supports 1D line plots, 2D heatmaps, and video generation for time-varying data. Parameters: state ( dict [ str , ndarray ] ) \u2013 Dictionary containing recorded field data arrays. progress ( Progress | None , default: None ) \u2013 Optional progress bar for video generation. Returns: dict [ str , Figure | str ] \u2013 dict[str, Figure | str]: Dictionary mapping plot names to either matplotlib Figure objects or paths to generated video files. Source code in src/fdtdx/objects/detectors/detector.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 def draw_plot ( self , state : dict [ str , np . ndarray ], progress : Progress | None = None , ) -> dict [ str , Figure | str ]: \"\"\"Generates plots or videos from recorded detector data. Creates visualizations based on dimensionality of recorded data and detector configuration. Supports 1D line plots, 2D heatmaps, and video generation for time-varying data. Args: state (dict[str, np.ndarray]): Dictionary containing recorded field data arrays. progress (Progress | None, optional): Optional progress bar for video generation. Returns: dict[str, Figure | str]: Dictionary mapping plot names to either matplotlib Figure objects or paths to generated video files. \"\"\" squeezed_arrs = {} squeezed_ndim = None for k , v in state . items (): v_squeezed = v . squeeze () if self . inverse and self . if_inverse_plot_backwards and self . num_time_steps_recorded > 1 : squeezed_arrs [ k ] = v_squeezed [:: - 1 , ... ] else : squeezed_arrs [ k ] = v_squeezed if squeezed_ndim is None : squeezed_ndim = len ( v_squeezed . shape ) else : if len ( v_squeezed . shape ) != squeezed_ndim : raise Exception ( \"Cannot plot multiple arrays with different ndim\" ) if squeezed_ndim is None : raise Exception ( f \"empty state: { state } \" ) figs = {} if squeezed_ndim == 1 and self . num_time_steps_recorded > 1 : # do line plot time_steps = np . where ( np . asarray ( self . _is_on_at_time_step_arr ))[ 0 ] time_steps = time_steps * self . _config . time_step_duration for k , v in squeezed_arrs . items (): fig = plot_line_over_time ( arr = v , time_steps = time_steps . tolist (), metric_name = f \" { self . name } : { k } \" ) figs [ k ] = fig elif squeezed_ndim == 1 and self . num_time_steps_recorded == 1 : SCALE = 10 xlabel = None if self . grid_shape [ 0 ] > 1 and self . grid_shape [ 1 ] <= 1 and self . grid_shape [ 2 ] <= 1 : xlabel = \"X axis (\u03bcm)\" elif self . grid_shape [ 0 ] <= 1 and self . grid_shape [ 1 ] > 1 and self . grid_shape [ 2 ] <= 1 : xlabel = \"Y axis (\u03bcm)\" elif self . grid_shape [ 0 ] <= 1 and self . grid_shape [ 1 ] <= 1 and self . grid_shape [ 2 ] > 1 : xlabel = \"Z axis (\u03bcm)\" assert xlabel is not None , \"This should never happen\" for k , v in squeezed_arrs . items (): spatial_axis = np . arange ( len ( v )) / SCALE fig = plot_line_over_time ( arr = v , time_steps = spatial_axis , metric_name = f \" { self . name } : { k } \" , xlabel = xlabel ) figs [ k ] = fig elif squeezed_ndim == 2 and self . num_time_steps_recorded > 1 : # multiple time steps, 1d spatial data - visualize as 2D waterfall plot time_steps = np . where ( np . asarray ( self . _is_on_at_time_step_arr ))[ 0 ] time_steps = time_steps * self . _config . time_step_duration # Determine spatial axis based on which dimension has size > 1 SCALE = 10 # \u03bcm per grid point for k , v in squeezed_arrs . items (): # Determine which dimension is spatial (not time) spatial_dim = 1 if v . shape [ 1 ] > 1 else 0 if spatial_dim == 0 : # Transpose if needed so time is always first dimension v = v . T # Create spatial axis in \u03bcm spatial_points = np . arange ( v . shape [ 1 ]) / SCALE fig = plot_waterfall_over_time ( arr = v , time_steps = time_steps , spatial_steps = spatial_points , metric_name = f \" { self . name } : { k } \" , spatial_unit = \"\u03bcm\" , ) figs [ k ] = fig elif squeezed_ndim == 2 and self . num_time_steps_recorded == 1 : # single time step, 2d-plot # TODO: if all ([ x in squeezed_arrs . keys () for x in [ \"XY Plane\" , \"XZ Plane\" , \"YZ Plane\" ]]): fig = plot_2d_from_slices ( xy_slice = squeezed_arrs [ \"XY Plane\" ], xz_slice = squeezed_arrs [ \"XZ Plane\" ], yz_slice = squeezed_arrs [ \"YZ Plane\" ], resolutions = ( self . _config . resolution , self . _config . resolution , self . _config . resolution , ), plot_dpi = self . plot_dpi , plot_interpolation = self . plot_interpolation , ) figs [ \"sliced_plot\" ] = fig else : raise Exception ( f \"Cannot plot { squeezed_arrs . keys () } \" ) elif squeezed_ndim == 3 and self . num_time_steps_recorded > 1 : # multiple time steps, 2d-plots if all ([ x in squeezed_arrs . keys () for x in [ \"XY Plane\" , \"XZ Plane\" , \"YZ Plane\" ]]): path = generate_video_from_slices ( plt_fn = plot_from_slices , xy_slice = squeezed_arrs [ \"XY Plane\" ], xz_slice = squeezed_arrs [ \"XZ Plane\" ], yz_slice = squeezed_arrs [ \"YZ Plane\" ], progress = progress , num_worker = self . num_video_workers , resolutions = ( self . _config . resolution , self . _config . resolution , self . _config . resolution , ), plot_dpi = self . plot_dpi , plot_interpolation = self . plot_interpolation , ) figs [ \"sliced_video\" ] = path else : raise Exception ( f \"Cannot plot { squeezed_arrs . keys () } . \" f \"Consider setting plot=False for Object { self . name } ( { self . __class__ =} )\" ) elif squeezed_ndim == 3 and self . num_time_steps_recorded == 1 : # single step, 3d-plot. # TODO: do as mean over planes for k , v in squeezed_arrs . items (): xy_slice = squeezed_arrs [ k ] . mean ( axis = 0 ) xz_slice = squeezed_arrs [ k ] . mean ( axis = 1 ) yz_slice = squeezed_arrs [ k ] . mean ( axis = 2 ) fig = plot_2d_from_slices ( xy_slice = xy_slice , xz_slice = xz_slice , yz_slice = yz_slice , resolutions = ( self . _config . resolution , self . _config . resolution , self . _config . resolution , ), plot_dpi = self . plot_dpi , plot_interpolation = self . plot_interpolation , ) figs [ k ] = fig elif squeezed_ndim == 4 and self . num_time_steps_recorded > 1 : # video with 3d-volume in each time step. plot as slices for k , v in squeezed_arrs . items (): xy_slice = squeezed_arrs [ k ] . mean ( axis = 1 ) xz_slice = squeezed_arrs [ k ] . mean ( axis = 2 ) yz_slice = squeezed_arrs [ k ] . mean ( axis = 3 ) path = generate_video_from_slices ( plt_fn = plot_from_slices , xy_slice = xy_slice , xz_slice = xz_slice , yz_slice = yz_slice , progress = progress , num_worker = self . num_video_workers , resolutions = ( self . _config . resolution , self . _config . resolution , self . _config . resolution , ), plot_dpi = self . plot_dpi , plot_interpolation = self . plot_interpolation , ) figs [ k ] = path else : raise Exception ( \"Cannot plot detector with more than three dimensions\" ) return figs update abstractmethod update ( time_step : Array , E : Array , H : Array , state : DetectorState , inv_permittivity : Array , inv_permeability : Array | float , ) -> DetectorState Updates detector state with current field values. Parameters: time_step ( Array ) \u2013 Current simulation time step. E ( Array ) \u2013 Electric field array. H ( Array ) \u2013 Magnetic field array. state ( DetectorState ) \u2013 Current detector state. inv_permittivity ( Array ) \u2013 Inverse permittivity array. inv_permeability ( Array | float ) \u2013 Inverse permeability array. Returns: DetectorState ( DetectorState ) \u2013 Updated detector state. Source code in src/fdtdx/objects/detectors/detector.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 @abstractmethod def update ( self , time_step : jax . Array , E : jax . Array , H : jax . Array , state : DetectorState , inv_permittivity : jax . Array , inv_permeability : jax . Array | float , ) -> DetectorState : \"\"\"Updates detector state with current field values. Args: time_step (jax.Array): Current simulation time step. E (jax.Array): Electric field array. H (jax.Array): Magnetic field array. state (DetectorState): Current detector state. inv_permittivity (jax.Array): Inverse permittivity array. inv_permeability (jax.Array | float): Inverse permeability array. Returns: DetectorState: Updated detector state. \"\"\" del ( time_step , E , H , state , inv_permittivity , inv_permeability , ) raise NotImplementedError ()","title":"Detector Base Class"},{"location":"api/internal/detector/#detector-base-class","text":"","title":"Detector Base Class"},{"location":"api/internal/detector/#fdtdx.objects.detectors.detector.Detector","text":"Bases: SimulationObject , ABC Base class for electromagnetic field detectors in FDTD simulations. This class provides core functionality for recording and analyzing electromagnetic field data during FDTD simulations. It supports flexible timing control, data collection intervals, and visualization of results. Attributes: dtype ( dtype ) \u2013 Data type for detector arrays, defaults to float32. exact_interpolation ( bool ) \u2013 Whether to use exact field interpolation. Defaults to True. inverse ( bool ) \u2013 Whether to record fields in inverse time order. Defaults to false. switch ( OnOffSwitch ) \u2013 This switch controls the time steps that the detector is on, i.e. records data. Defaults to all time steps. plot ( bool ) \u2013 Whether to generate plots of recorded data. Defaults to true. if_inverse_plot_backwards ( bool ) \u2013 Plot inverse data in reverse time order. num_video_workers ( int | None ) \u2013 Number of workers for video generation. If None (default), then no multiprocessing is used. Note that the combination of multiprocessing and matplotlib is known to produce problems and can cause the entire system to freeze. It does make the video generation much faster though. color ( tuple [ float , float , float ] | None ) \u2013 RGB color for plotting. Defaults to light green. plot_interpolation ( str ) \u2013 Interpolation method for plots. Defualts to \"gaussian\". plot_dpi ( int | None ) \u2013 DPI resolution for plots. Defaults to None.","title":"Detector"},{"location":"api/internal/detector/#fdtdx.objects.detectors.detector.Detector.num_time_steps_recorded","text":"num_time_steps_recorded : int Gets the total number of time steps that will be recorded. Returns: int ( int ) \u2013 Number of time steps where detector will record data. Raises: Exception \u2013 If detector is not yet initialized.","title":"num_time_steps_recorded"},{"location":"api/internal/detector/#fdtdx.objects.detectors.detector.Detector.draw_plot","text":"draw_plot ( state : dict [ str , ndarray ], progress : Progress | None = None , ) -> dict [ str , Figure | str ] Generates plots or videos from recorded detector data. Creates visualizations based on dimensionality of recorded data and detector configuration. Supports 1D line plots, 2D heatmaps, and video generation for time-varying data. Parameters: state ( dict [ str , ndarray ] ) \u2013 Dictionary containing recorded field data arrays. progress ( Progress | None , default: None ) \u2013 Optional progress bar for video generation. Returns: dict [ str , Figure | str ] \u2013 dict[str, Figure | str]: Dictionary mapping plot names to either matplotlib Figure objects or paths to generated video files. Source code in src/fdtdx/objects/detectors/detector.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 def draw_plot ( self , state : dict [ str , np . ndarray ], progress : Progress | None = None , ) -> dict [ str , Figure | str ]: \"\"\"Generates plots or videos from recorded detector data. Creates visualizations based on dimensionality of recorded data and detector configuration. Supports 1D line plots, 2D heatmaps, and video generation for time-varying data. Args: state (dict[str, np.ndarray]): Dictionary containing recorded field data arrays. progress (Progress | None, optional): Optional progress bar for video generation. Returns: dict[str, Figure | str]: Dictionary mapping plot names to either matplotlib Figure objects or paths to generated video files. \"\"\" squeezed_arrs = {} squeezed_ndim = None for k , v in state . items (): v_squeezed = v . squeeze () if self . inverse and self . if_inverse_plot_backwards and self . num_time_steps_recorded > 1 : squeezed_arrs [ k ] = v_squeezed [:: - 1 , ... ] else : squeezed_arrs [ k ] = v_squeezed if squeezed_ndim is None : squeezed_ndim = len ( v_squeezed . shape ) else : if len ( v_squeezed . shape ) != squeezed_ndim : raise Exception ( \"Cannot plot multiple arrays with different ndim\" ) if squeezed_ndim is None : raise Exception ( f \"empty state: { state } \" ) figs = {} if squeezed_ndim == 1 and self . num_time_steps_recorded > 1 : # do line plot time_steps = np . where ( np . asarray ( self . _is_on_at_time_step_arr ))[ 0 ] time_steps = time_steps * self . _config . time_step_duration for k , v in squeezed_arrs . items (): fig = plot_line_over_time ( arr = v , time_steps = time_steps . tolist (), metric_name = f \" { self . name } : { k } \" ) figs [ k ] = fig elif squeezed_ndim == 1 and self . num_time_steps_recorded == 1 : SCALE = 10 xlabel = None if self . grid_shape [ 0 ] > 1 and self . grid_shape [ 1 ] <= 1 and self . grid_shape [ 2 ] <= 1 : xlabel = \"X axis (\u03bcm)\" elif self . grid_shape [ 0 ] <= 1 and self . grid_shape [ 1 ] > 1 and self . grid_shape [ 2 ] <= 1 : xlabel = \"Y axis (\u03bcm)\" elif self . grid_shape [ 0 ] <= 1 and self . grid_shape [ 1 ] <= 1 and self . grid_shape [ 2 ] > 1 : xlabel = \"Z axis (\u03bcm)\" assert xlabel is not None , \"This should never happen\" for k , v in squeezed_arrs . items (): spatial_axis = np . arange ( len ( v )) / SCALE fig = plot_line_over_time ( arr = v , time_steps = spatial_axis , metric_name = f \" { self . name } : { k } \" , xlabel = xlabel ) figs [ k ] = fig elif squeezed_ndim == 2 and self . num_time_steps_recorded > 1 : # multiple time steps, 1d spatial data - visualize as 2D waterfall plot time_steps = np . where ( np . asarray ( self . _is_on_at_time_step_arr ))[ 0 ] time_steps = time_steps * self . _config . time_step_duration # Determine spatial axis based on which dimension has size > 1 SCALE = 10 # \u03bcm per grid point for k , v in squeezed_arrs . items (): # Determine which dimension is spatial (not time) spatial_dim = 1 if v . shape [ 1 ] > 1 else 0 if spatial_dim == 0 : # Transpose if needed so time is always first dimension v = v . T # Create spatial axis in \u03bcm spatial_points = np . arange ( v . shape [ 1 ]) / SCALE fig = plot_waterfall_over_time ( arr = v , time_steps = time_steps , spatial_steps = spatial_points , metric_name = f \" { self . name } : { k } \" , spatial_unit = \"\u03bcm\" , ) figs [ k ] = fig elif squeezed_ndim == 2 and self . num_time_steps_recorded == 1 : # single time step, 2d-plot # TODO: if all ([ x in squeezed_arrs . keys () for x in [ \"XY Plane\" , \"XZ Plane\" , \"YZ Plane\" ]]): fig = plot_2d_from_slices ( xy_slice = squeezed_arrs [ \"XY Plane\" ], xz_slice = squeezed_arrs [ \"XZ Plane\" ], yz_slice = squeezed_arrs [ \"YZ Plane\" ], resolutions = ( self . _config . resolution , self . _config . resolution , self . _config . resolution , ), plot_dpi = self . plot_dpi , plot_interpolation = self . plot_interpolation , ) figs [ \"sliced_plot\" ] = fig else : raise Exception ( f \"Cannot plot { squeezed_arrs . keys () } \" ) elif squeezed_ndim == 3 and self . num_time_steps_recorded > 1 : # multiple time steps, 2d-plots if all ([ x in squeezed_arrs . keys () for x in [ \"XY Plane\" , \"XZ Plane\" , \"YZ Plane\" ]]): path = generate_video_from_slices ( plt_fn = plot_from_slices , xy_slice = squeezed_arrs [ \"XY Plane\" ], xz_slice = squeezed_arrs [ \"XZ Plane\" ], yz_slice = squeezed_arrs [ \"YZ Plane\" ], progress = progress , num_worker = self . num_video_workers , resolutions = ( self . _config . resolution , self . _config . resolution , self . _config . resolution , ), plot_dpi = self . plot_dpi , plot_interpolation = self . plot_interpolation , ) figs [ \"sliced_video\" ] = path else : raise Exception ( f \"Cannot plot { squeezed_arrs . keys () } . \" f \"Consider setting plot=False for Object { self . name } ( { self . __class__ =} )\" ) elif squeezed_ndim == 3 and self . num_time_steps_recorded == 1 : # single step, 3d-plot. # TODO: do as mean over planes for k , v in squeezed_arrs . items (): xy_slice = squeezed_arrs [ k ] . mean ( axis = 0 ) xz_slice = squeezed_arrs [ k ] . mean ( axis = 1 ) yz_slice = squeezed_arrs [ k ] . mean ( axis = 2 ) fig = plot_2d_from_slices ( xy_slice = xy_slice , xz_slice = xz_slice , yz_slice = yz_slice , resolutions = ( self . _config . resolution , self . _config . resolution , self . _config . resolution , ), plot_dpi = self . plot_dpi , plot_interpolation = self . plot_interpolation , ) figs [ k ] = fig elif squeezed_ndim == 4 and self . num_time_steps_recorded > 1 : # video with 3d-volume in each time step. plot as slices for k , v in squeezed_arrs . items (): xy_slice = squeezed_arrs [ k ] . mean ( axis = 1 ) xz_slice = squeezed_arrs [ k ] . mean ( axis = 2 ) yz_slice = squeezed_arrs [ k ] . mean ( axis = 3 ) path = generate_video_from_slices ( plt_fn = plot_from_slices , xy_slice = xy_slice , xz_slice = xz_slice , yz_slice = yz_slice , progress = progress , num_worker = self . num_video_workers , resolutions = ( self . _config . resolution , self . _config . resolution , self . _config . resolution , ), plot_dpi = self . plot_dpi , plot_interpolation = self . plot_interpolation , ) figs [ k ] = path else : raise Exception ( \"Cannot plot detector with more than three dimensions\" ) return figs","title":"draw_plot"},{"location":"api/internal/detector/#fdtdx.objects.detectors.detector.Detector.update","text":"update ( time_step : Array , E : Array , H : Array , state : DetectorState , inv_permittivity : Array , inv_permeability : Array | float , ) -> DetectorState Updates detector state with current field values. Parameters: time_step ( Array ) \u2013 Current simulation time step. E ( Array ) \u2013 Electric field array. H ( Array ) \u2013 Magnetic field array. state ( DetectorState ) \u2013 Current detector state. inv_permittivity ( Array ) \u2013 Inverse permittivity array. inv_permeability ( Array | float ) \u2013 Inverse permeability array. Returns: DetectorState ( DetectorState ) \u2013 Updated detector state. Source code in src/fdtdx/objects/detectors/detector.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 @abstractmethod def update ( self , time_step : jax . Array , E : jax . Array , H : jax . Array , state : DetectorState , inv_permittivity : jax . Array , inv_permeability : jax . Array | float , ) -> DetectorState : \"\"\"Updates detector state with current field values. Args: time_step (jax.Array): Current simulation time step. E (jax.Array): Electric field array. H (jax.Array): Magnetic field array. state (DetectorState): Current detector state. inv_permittivity (jax.Array): Inverse permittivity array. inv_permeability (jax.Array | float): Inverse permeability array. Returns: DetectorState: Updated detector state. \"\"\" del ( time_step , E , H , state , inv_permittivity , inv_permeability , ) raise NotImplementedError ()","title":"update"},{"location":"api/internal/objects/","text":"Object Base Classes fdtdx.objects.object.OrderableObject Bases: SimulationObject fdtdx.objects.static_material.static.StaticMultiMaterialObject Bases: OrderableObject , ABC get_material_mapping abstractmethod get_material_mapping () -> jax . Array Returns an array, which represents the material index at every voxel. Specifically, it returns the index of the ordered material list. Returns: Array \u2013 jax.Array: Index array Source code in src/fdtdx/objects/static_material/static.py 33 34 35 36 37 38 39 40 41 42 43 @abstractmethod def get_material_mapping ( self , ) -> jax . Array : \"\"\"Returns an array, which represents the material index at every voxel. Specifically, it returns the index of the ordered material list. Returns: jax.Array: Index array \"\"\" raise NotImplementedError () get_voxel_mask_for_shape abstractmethod get_voxel_mask_for_shape () -> jax . Array Get a binary mask of the objects shape. Everything voxel not in the mask, will not be updated by this object. For example, can be used to approximate a round shape. The mask is calculated in device voxel size, not in simulation voxels. Returns: Array \u2013 jax.Array: Binary mask representing the voxels occupied by the object Source code in src/fdtdx/objects/static_material/static.py 22 23 24 25 26 27 28 29 30 31 @abstractmethod def get_voxel_mask_for_shape ( self ) -> jax . Array : \"\"\"Get a binary mask of the objects shape. Everything voxel not in the mask, will not be updated by this object. For example, can be used to approximate a round shape. The mask is calculated in device voxel size, not in simulation voxels. Returns: jax.Array: Binary mask representing the voxels occupied by the object \"\"\" raise NotImplementedError ()","title":"Object Base Classes"},{"location":"api/internal/objects/#object-base-classes","text":"","title":"Object Base Classes"},{"location":"api/internal/objects/#fdtdx.objects.object.OrderableObject","text":"Bases: SimulationObject","title":"OrderableObject"},{"location":"api/internal/objects/#fdtdx.objects.static_material.static.StaticMultiMaterialObject","text":"Bases: OrderableObject , ABC","title":"StaticMultiMaterialObject"},{"location":"api/internal/objects/#fdtdx.objects.static_material.static.StaticMultiMaterialObject.get_material_mapping","text":"get_material_mapping () -> jax . Array Returns an array, which represents the material index at every voxel. Specifically, it returns the index of the ordered material list. Returns: Array \u2013 jax.Array: Index array Source code in src/fdtdx/objects/static_material/static.py 33 34 35 36 37 38 39 40 41 42 43 @abstractmethod def get_material_mapping ( self , ) -> jax . Array : \"\"\"Returns an array, which represents the material index at every voxel. Specifically, it returns the index of the ordered material list. Returns: jax.Array: Index array \"\"\" raise NotImplementedError ()","title":"get_material_mapping"},{"location":"api/internal/objects/#fdtdx.objects.static_material.static.StaticMultiMaterialObject.get_voxel_mask_for_shape","text":"get_voxel_mask_for_shape () -> jax . Array Get a binary mask of the objects shape. Everything voxel not in the mask, will not be updated by this object. For example, can be used to approximate a round shape. The mask is calculated in device voxel size, not in simulation voxels. Returns: Array \u2013 jax.Array: Binary mask representing the voxels occupied by the object Source code in src/fdtdx/objects/static_material/static.py 22 23 24 25 26 27 28 29 30 31 @abstractmethod def get_voxel_mask_for_shape ( self ) -> jax . Array : \"\"\"Get a binary mask of the objects shape. Everything voxel not in the mask, will not be updated by this object. For example, can be used to approximate a round shape. The mask is calculated in device voxel size, not in simulation voxels. Returns: jax.Array: Binary mask representing the voxels occupied by the object \"\"\" raise NotImplementedError ()","title":"get_voxel_mask_for_shape"},{"location":"api/internal/sources/","text":"Source Base Classes fdtdx.objects.sources.source.Source Bases: SimulationObject , ABC update_E abstractmethod update_E ( E : Array , inv_permittivities : Array , inv_permeabilities : Array | float , time_step : Array , inverse : bool , ) -> jax . Array Update the electric field component. Parameters: E ( Array ) \u2013 Current electric field array. inv_permittivities ( Array ) \u2013 Inverse permittivity values. inv_permeabilities ( Array | float ) \u2013 Inverse permeability values. time_step ( Array ) \u2013 Current simulation time step. inverse ( bool ) \u2013 Whether to perform inverse update for backpropagation. Returns: Array \u2013 jax.Array: Updated electric field array. Source code in src/fdtdx/objects/sources/source.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 @abstractmethod def update_E ( self , E : jax . Array , inv_permittivities : jax . Array , inv_permeabilities : jax . Array | float , time_step : jax . Array , inverse : bool , ) -> jax . Array : \"\"\"Update the electric field component. Args: E (jax.Array): Current electric field array. inv_permittivities (jax.Array): Inverse permittivity values. inv_permeabilities (jax.Array | float): Inverse permeability values. time_step (jax.Array): Current simulation time step. inverse (bool): Whether to perform inverse update for backpropagation. Returns: jax.Array: Updated electric field array. \"\"\" raise NotImplementedError () update_H abstractmethod update_H ( H : Array , inv_permittivities : Array , inv_permeabilities : Array | float , time_step : Array , inverse : bool , ) -> jax . Array Update the magnetic field component. Parameters: H ( Array ) \u2013 Current magnetic field array. inv_permittivities ( Array ) \u2013 Inverse permittivity values. inv_permeabilities ( Array | float ) \u2013 Inverse permeability values. time_step ( Array ) \u2013 Current simulation time step. inverse ( bool ) \u2013 Whether to perform inverse update for backpropagation. Returns: Array \u2013 jax.Array: Updated magnetic field array. Source code in src/fdtdx/objects/sources/source.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @abstractmethod def update_H ( self , H : jax . Array , inv_permittivities : jax . Array , inv_permeabilities : jax . Array | float , time_step : jax . Array , inverse : bool , ) -> jax . Array : \"\"\"Update the magnetic field component. Args: H (jax.Array): Current magnetic field array. inv_permittivities (jax.Array): Inverse permittivity values. inv_permeabilities (jax.Array | float): Inverse permeability values. time_step (jax.Array): Current simulation time step. inverse (bool): Whether to perform inverse update for backpropagation. Returns: jax.Array: Updated magnetic field array. \"\"\" raise NotImplementedError () fdtdx.objects.sources.source.DirectionalPlaneSourceBase Bases: Source , ABC Base class for directional plane wave sources. Implements common functionality for plane wave sources that propagate in a specific direction. Provides methods for calculating wave vectors and orthogonal field components. Attributes: direction ( Literal ['+', '-'] ) \u2013 Direction of propagation ('+' or '-' along propagation axis). fdtdx.objects.sources.tfsf.TFSFPlaneSource Bases: DirectionalPlaneSourceBase , ABC Total-Field/Scattered-Field (TFSF) implementation of a source. The boundary between the scattered field and total field is at a positive offset of 0.25 in the yee grid in the axis of propagation. azimuth_radians property azimuth_radians : float Convert azimuth angle from degrees to radians. Returns: float ( float ) \u2013 Azimuth angle in radians. elevation_radians property elevation_radians : float Convert elevation angle from degrees to radians. Returns: float ( float ) \u2013 Elevation angle in radians. max_angle_random_offset_radians property max_angle_random_offset_radians : float Convert maximum random angle offset from degrees to radians. Returns: float ( float ) \u2013 Maximum random angle offset in radians. max_horizontal_offset_grid property max_horizontal_offset_grid : float Convert maximum horizontal offset from physical units to grid points. Returns: float ( float ) \u2013 Maximum horizontal offset in grid points. max_vertical_offset_grid property max_vertical_offset_grid : float Convert maximum vertical offset from physical units to grid points. Returns: float ( float ) \u2013 Maximum vertical offset in grid points. fdtdx.objects.sources.linear_polarization.LinearlyPolarizedPlaneSource Bases: TFSFPlaneSource , ABC fdtdx.objects.sources.profile.TemporalProfile Bases: TreeClass , ABC Base class for temporal profiles of sources. This class defines how the source amplitude varies in time. get_amplitude abstractmethod get_amplitude ( time : Array , period : float , phase_shift : float = 0.0 ) -> jax . Array Calculate the temporal amplitude at given time points. Parameters: time ( Array ) \u2013 Time points to evaluate amplitude at period ( float ) \u2013 Period of the carrier wave (1/frequency) phase_shift ( float , default: 0.0 ) \u2013 Phase shift of the carrier wave Returns: Array \u2013 jax.Array: Amplitude values at the given time points Source code in src/fdtdx/objects/sources/profile.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @abstractmethod def get_amplitude ( self , time : jax . Array , period : float , phase_shift : float = 0.0 , ) -> jax . Array : \"\"\"Calculate the temporal amplitude at given time points. Args: time (jax.Array): Time points to evaluate amplitude at period (float): Period of the carrier wave (1/frequency) phase_shift (float): Phase shift of the carrier wave Returns: jax.Array: Amplitude values at the given time points \"\"\" raise NotImplementedError ()","title":"Source Base Classes"},{"location":"api/internal/sources/#source-base-classes","text":"","title":"Source Base Classes"},{"location":"api/internal/sources/#fdtdx.objects.sources.source.Source","text":"Bases: SimulationObject , ABC","title":"Source"},{"location":"api/internal/sources/#fdtdx.objects.sources.source.Source.update_E","text":"update_E ( E : Array , inv_permittivities : Array , inv_permeabilities : Array | float , time_step : Array , inverse : bool , ) -> jax . Array Update the electric field component. Parameters: E ( Array ) \u2013 Current electric field array. inv_permittivities ( Array ) \u2013 Inverse permittivity values. inv_permeabilities ( Array | float ) \u2013 Inverse permeability values. time_step ( Array ) \u2013 Current simulation time step. inverse ( bool ) \u2013 Whether to perform inverse update for backpropagation. Returns: Array \u2013 jax.Array: Updated electric field array. Source code in src/fdtdx/objects/sources/source.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 @abstractmethod def update_E ( self , E : jax . Array , inv_permittivities : jax . Array , inv_permeabilities : jax . Array | float , time_step : jax . Array , inverse : bool , ) -> jax . Array : \"\"\"Update the electric field component. Args: E (jax.Array): Current electric field array. inv_permittivities (jax.Array): Inverse permittivity values. inv_permeabilities (jax.Array | float): Inverse permeability values. time_step (jax.Array): Current simulation time step. inverse (bool): Whether to perform inverse update for backpropagation. Returns: jax.Array: Updated electric field array. \"\"\" raise NotImplementedError ()","title":"update_E"},{"location":"api/internal/sources/#fdtdx.objects.sources.source.Source.update_H","text":"update_H ( H : Array , inv_permittivities : Array , inv_permeabilities : Array | float , time_step : Array , inverse : bool , ) -> jax . Array Update the magnetic field component. Parameters: H ( Array ) \u2013 Current magnetic field array. inv_permittivities ( Array ) \u2013 Inverse permittivity values. inv_permeabilities ( Array | float ) \u2013 Inverse permeability values. time_step ( Array ) \u2013 Current simulation time step. inverse ( bool ) \u2013 Whether to perform inverse update for backpropagation. Returns: Array \u2013 jax.Array: Updated magnetic field array. Source code in src/fdtdx/objects/sources/source.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 @abstractmethod def update_H ( self , H : jax . Array , inv_permittivities : jax . Array , inv_permeabilities : jax . Array | float , time_step : jax . Array , inverse : bool , ) -> jax . Array : \"\"\"Update the magnetic field component. Args: H (jax.Array): Current magnetic field array. inv_permittivities (jax.Array): Inverse permittivity values. inv_permeabilities (jax.Array | float): Inverse permeability values. time_step (jax.Array): Current simulation time step. inverse (bool): Whether to perform inverse update for backpropagation. Returns: jax.Array: Updated magnetic field array. \"\"\" raise NotImplementedError ()","title":"update_H"},{"location":"api/internal/sources/#fdtdx.objects.sources.source.DirectionalPlaneSourceBase","text":"Bases: Source , ABC Base class for directional plane wave sources. Implements common functionality for plane wave sources that propagate in a specific direction. Provides methods for calculating wave vectors and orthogonal field components. Attributes: direction ( Literal ['+', '-'] ) \u2013 Direction of propagation ('+' or '-' along propagation axis).","title":"DirectionalPlaneSourceBase"},{"location":"api/internal/sources/#fdtdx.objects.sources.tfsf.TFSFPlaneSource","text":"Bases: DirectionalPlaneSourceBase , ABC Total-Field/Scattered-Field (TFSF) implementation of a source. The boundary between the scattered field and total field is at a positive offset of 0.25 in the yee grid in the axis of propagation.","title":"TFSFPlaneSource"},{"location":"api/internal/sources/#fdtdx.objects.sources.tfsf.TFSFPlaneSource.azimuth_radians","text":"azimuth_radians : float Convert azimuth angle from degrees to radians. Returns: float ( float ) \u2013 Azimuth angle in radians.","title":"azimuth_radians"},{"location":"api/internal/sources/#fdtdx.objects.sources.tfsf.TFSFPlaneSource.elevation_radians","text":"elevation_radians : float Convert elevation angle from degrees to radians. Returns: float ( float ) \u2013 Elevation angle in radians.","title":"elevation_radians"},{"location":"api/internal/sources/#fdtdx.objects.sources.tfsf.TFSFPlaneSource.max_angle_random_offset_radians","text":"max_angle_random_offset_radians : float Convert maximum random angle offset from degrees to radians. Returns: float ( float ) \u2013 Maximum random angle offset in radians.","title":"max_angle_random_offset_radians"},{"location":"api/internal/sources/#fdtdx.objects.sources.tfsf.TFSFPlaneSource.max_horizontal_offset_grid","text":"max_horizontal_offset_grid : float Convert maximum horizontal offset from physical units to grid points. Returns: float ( float ) \u2013 Maximum horizontal offset in grid points.","title":"max_horizontal_offset_grid"},{"location":"api/internal/sources/#fdtdx.objects.sources.tfsf.TFSFPlaneSource.max_vertical_offset_grid","text":"max_vertical_offset_grid : float Convert maximum vertical offset from physical units to grid points. Returns: float ( float ) \u2013 Maximum vertical offset in grid points.","title":"max_vertical_offset_grid"},{"location":"api/internal/sources/#fdtdx.objects.sources.linear_polarization.LinearlyPolarizedPlaneSource","text":"Bases: TFSFPlaneSource , ABC","title":"LinearlyPolarizedPlaneSource"},{"location":"api/internal/sources/#fdtdx.objects.sources.profile.TemporalProfile","text":"Bases: TreeClass , ABC Base class for temporal profiles of sources. This class defines how the source amplitude varies in time.","title":"TemporalProfile"},{"location":"api/internal/sources/#fdtdx.objects.sources.profile.TemporalProfile.get_amplitude","text":"get_amplitude ( time : Array , period : float , phase_shift : float = 0.0 ) -> jax . Array Calculate the temporal amplitude at given time points. Parameters: time ( Array ) \u2013 Time points to evaluate amplitude at period ( float ) \u2013 Period of the carrier wave (1/frequency) phase_shift ( float , default: 0.0 ) \u2013 Phase shift of the carrier wave Returns: Array \u2013 jax.Array: Amplitude values at the given time points Source code in src/fdtdx/objects/sources/profile.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @abstractmethod def get_amplitude ( self , time : jax . Array , period : float , phase_shift : float = 0.0 , ) -> jax . Array : \"\"\"Calculate the temporal amplitude at given time points. Args: time (jax.Array): Time points to evaluate amplitude at period (float): Period of the carrier wave (1/frequency) phase_shift (float): Phase shift of the carrier wave Returns: jax.Array: Amplitude values at the given time points \"\"\" raise NotImplementedError ()","title":"get_amplitude"},{"location":"api/internal/transformation/","text":"Parameter Transformation Base Classes fdtdx.objects.device.parameters.transform.ParameterTransformation Bases: TreeClass , ABC fdtdx.objects.device.parameters.transform.SameShapeTypeParameterTransform Bases: ParameterTransformation , ABC","title":"Parameter Transformation Base Classes"},{"location":"api/internal/transformation/#parameter-transformation-base-classes","text":"","title":"Parameter Transformation Base Classes"},{"location":"api/internal/transformation/#fdtdx.objects.device.parameters.transform.ParameterTransformation","text":"Bases: TreeClass , ABC","title":"ParameterTransformation"},{"location":"api/internal/transformation/#fdtdx.objects.device.parameters.transform.SameShapeTypeParameterTransform","text":"Bases: ParameterTransformation , ABC","title":"SameShapeTypeParameterTransform"},{"location":"api/public/ArrayContainer/","text":"fdtdx.ArrayContainer Bases: TreeClass Container for simulation field arrays and states. This class holds the electromagnetic field arrays and various state information needed during FDTD simulation. It includes the E and H fields, material properties, and states for boundaries, detectors and recordings. Attributes: E ( Array ) \u2013 Electric field array. H ( Array ) \u2013 Magnetic field array. inv_permittivities ( Array ) \u2013 Inverse permittivity values array. inv_permeabilities ( Array | float ) \u2013 Inverse permeability values array. boundary_states ( dict [ str , BaseBoundaryState ] ) \u2013 Dictionary mapping boundary names to their states. detector_states ( dict [ str , DetectorState ] ) \u2013 Dictionary mapping detector names to their states. recording_state ( RecordingState | None ) \u2013 Optional state for recording simulation data. electric_conductivity ( Array | None ) \u2013 field for electric conductivity terms. Defaults to None. magnetic_conductivity ( Array | None ) \u2013 field for magnetic conductivity terms. Defaults to None.","title":"fdtdx.ArrayContainer"},{"location":"api/public/ArrayContainer/#fdtdxarraycontainer","text":"","title":"fdtdx.ArrayContainer"},{"location":"api/public/ArrayContainer/#fdtdx.ArrayContainer","text":"Bases: TreeClass Container for simulation field arrays and states. This class holds the electromagnetic field arrays and various state information needed during FDTD simulation. It includes the E and H fields, material properties, and states for boundaries, detectors and recordings. Attributes: E ( Array ) \u2013 Electric field array. H ( Array ) \u2013 Magnetic field array. inv_permittivities ( Array ) \u2013 Inverse permittivity values array. inv_permeabilities ( Array | float ) \u2013 Inverse permeability values array. boundary_states ( dict [ str , BaseBoundaryState ] ) \u2013 Dictionary mapping boundary names to their states. detector_states ( dict [ str , DetectorState ] ) \u2013 Dictionary mapping detector names to their states. recording_state ( RecordingState | None ) \u2013 Optional state for recording simulation data. electric_conductivity ( Array | None ) \u2013 field for electric conductivity terms. Defaults to None. magnetic_conductivity ( Array | None ) \u2013 field for magnetic conductivity terms. Defaults to None.","title":"ArrayContainer"},{"location":"api/public/BinaryMedianFilterModule/","text":"fdtdx.BinaryMedianFilterModule Bases: SameShapeTypeParameterTransform Performs 3D binary median filtering on the design. Applies a 3D median filter to smooth and clean up binary material distributions. This helps remove small features and noise while preserving larger structures. Attributes: padding_cfg ( PaddingConfig ) \u2013 Configuration for padding behavior at boundaries. kernel_sizes ( tuple [ int , int , int ] ) \u2013 3-tuple of kernel sizes for each dimension. num_repeats ( int ) \u2013 Number of times to apply the filter consecutively. Defaults to one.","title":"fdtdx.BinaryMedianFilterModule"},{"location":"api/public/BinaryMedianFilterModule/#fdtdxbinarymedianfiltermodule","text":"","title":"fdtdx.BinaryMedianFilterModule"},{"location":"api/public/BinaryMedianFilterModule/#fdtdx.BinaryMedianFilterModule","text":"Bases: SameShapeTypeParameterTransform Performs 3D binary median filtering on the design. Applies a 3D median filter to smooth and clean up binary material distributions. This helps remove small features and noise while preserving larger structures. Attributes: padding_cfg ( PaddingConfig ) \u2013 Configuration for padding behavior at boundaries. kernel_sizes ( tuple [ int , int , int ] ) \u2013 3-tuple of kernel sizes for each dimension. num_repeats ( int ) \u2013 Number of times to apply the filter consecutively. Defaults to one.","title":"BinaryMedianFilterModule"},{"location":"api/public/BoundaryConfig/","text":"fdtdx.BoundaryConfig Bases: TreeClass Configuration class for boundary conditions. This class stores parameters for boundary conditions in all six directions (min/max x/y/z). Supports both PML and periodic boundaries. For PML, the parameters control the absorption properties and physical size of the PML regions. Attributes: boundary_type_minx ( str ) \u2013 Boundary type at minimum x (\"pml\" or \"periodic\"). Default \"pml\". boundary_type_maxx ( str ) \u2013 Boundary type at maximum x (\"pml\" or \"periodic\"). Default \"pml\". boundary_type_miny ( str ) \u2013 Boundary type at minimum y (\"pml\" or \"periodic\"). Default \"pml\". boundary_type_maxy ( str ) \u2013 Boundary type at maximum y (\"pml\" or \"periodic\"). Default \"pml\". boundary_type_minz ( str ) \u2013 Boundary type at minimum z (\"pml\" or \"periodic\"). Default \"pml\". boundary_type_maxz ( str ) \u2013 Boundary type at maximum z (\"pml\" or \"periodic\"). Default \"pml\". thickness_grid_minx ( int ) \u2013 Number of grid cells for PML at minimum x boundary. Default 10. thickness_grid_maxx ( int ) \u2013 Number of grid cells for PML at maximum x boundary. Default 10. thickness_grid_miny ( int ) \u2013 Number of grid cells for PML at minimum y boundary. Default 10. thickness_grid_maxy ( int ) \u2013 Number of grid cells for PML at maximum y boundary. Default 10. thickness_grid_minz ( int ) \u2013 Number of grid cells for PML at minimum z boundary. Default 10. thickness_grid_maxz ( int ) \u2013 Number of grid cells for PML at maximum z boundary. Default 10. kappa_start_minx ( float ) \u2013 Initial kappa value at min x boundary. Default 1.0. kappa_end_minx ( float ) \u2013 Final kappa value at min x boundary. Default 1.5. kappa_start_maxx ( float ) \u2013 Initial kappa value at max x boundary. Default 1.0. kappa_end_maxx ( float ) \u2013 Final kappa value at max x boundary. Default 1.5. kappa_start_miny ( float ) \u2013 Initial kappa value at min y boundary. Default 1.0. kappa_end_miny ( float ) \u2013 Final kappa value at min y boundary. Default 1.5. kappa_start_maxy ( float ) \u2013 Initial kappa value at max y boundary. Default 1.0. kappa_end_maxy ( float ) \u2013 Final kappa value at max y boundary. Default 1.5. kappa_start_minz ( float ) \u2013 Initial kappa value at min z boundary. Default 1.0. kappa_end_minz ( float ) \u2013 Final kappa value at min z boundary. Default 1.5. kappa_start_maxz ( float ) \u2013 Initial kappa value at max z boundary. Default 1.0. kappa_end_maxz ( float ) \u2013 Final kappa value at max z boundary. Default 1.5. from_uniform_bound classmethod from_uniform_bound ( thickness : int = 10 , boundary_type : str = \"pml\" , kappa_start : float = 1 , kappa_end : float = 1.5 , ) -> BoundaryConfig Creates a BoundaryConfig with uniform parameters for all boundaries. Parameters: thickness ( int , default: 10 ) \u2013 Grid thickness to use for all PML boundaries. Defaults to 10. boundary_type ( str , default: 'pml' ) \u2013 Type of boundary to use (\"pml\" or \"periodic\"). Defaults to \"pml\". kappa_start ( float , default: 1 ) \u2013 Initial kappa value for all boundaries. Defaults to 1.0. kappa_end ( float , default: 1.5 ) \u2013 Final kappa value for all boundaries. Defaults to 1.5. Returns: BoundaryConfig ( BoundaryConfig ) \u2013 New config object with uniform parameters Source code in src/fdtdx/objects/boundaries/initialization.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 @classmethod def from_uniform_bound ( cls , thickness : int = 10 , boundary_type : str = \"pml\" , kappa_start : float = 1 , kappa_end : float = 1.5 , ) -> \"BoundaryConfig\" : \"\"\"Creates a BoundaryConfig with uniform parameters for all boundaries. Args: thickness (int, optional): Grid thickness to use for all PML boundaries. Defaults to 10. boundary_type (str, optional): Type of boundary to use (\"pml\" or \"periodic\"). Defaults to \"pml\". kappa_start (float, optional): Initial kappa value for all boundaries. Defaults to 1.0. kappa_end (float, optional): Final kappa value for all boundaries. Defaults to 1.5. Returns: BoundaryConfig: New config object with uniform parameters \"\"\" return cls ( boundary_type_minx = boundary_type , boundary_type_maxx = boundary_type , boundary_type_miny = boundary_type , boundary_type_maxy = boundary_type , boundary_type_minz = boundary_type , boundary_type_maxz = boundary_type , thickness_grid_minx = thickness , thickness_grid_maxx = thickness , thickness_grid_miny = thickness , thickness_grid_maxy = thickness , thickness_grid_minz = thickness , thickness_grid_maxz = thickness , kappa_start_minx = kappa_start , kappa_end_minx = kappa_end , kappa_start_maxx = kappa_start , kappa_end_maxx = kappa_end , kappa_start_miny = kappa_start , kappa_end_miny = kappa_end , kappa_start_maxy = kappa_start , kappa_end_maxy = kappa_end , kappa_start_minz = kappa_start , kappa_end_minz = kappa_end , kappa_start_maxz = kappa_start , kappa_end_maxz = kappa_end , ) get_dict get_dict () -> dict [ str , int ] Gets a dictionary mapping boundary names to their grid thicknesses. Returns: dict [ str , int ] \u2013 dict[str, int]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective grid thickness values. Source code in src/fdtdx/objects/boundaries/initialization.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def get_dict ( self ) -> dict [ str , int ]: \"\"\"Gets a dictionary mapping boundary names to their grid thicknesses. Returns: dict[str, int]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective grid thickness values. \"\"\" return { \"min_x\" : self . thickness_grid_minx , \"max_x\" : self . thickness_grid_maxx , \"min_y\" : self . thickness_grid_miny , \"max_y\" : self . thickness_grid_maxy , \"min_z\" : self . thickness_grid_minz , \"max_z\" : self . thickness_grid_maxz , } get_inside_boundary_slice get_inside_boundary_slice () -> tuple [ slice , slice , slice ] Gets slice objects for the non-PML interior region of the simulation volume. Returns: tuple [ slice , slice , slice ] \u2013 tuple[slice, slice, slice]: Three slice objects for indexing the x, y, z dimensions respectively, excluding the PML boundary regions. Source code in src/fdtdx/objects/boundaries/initialization.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def get_inside_boundary_slice ( self ) -> tuple [ slice , slice , slice ]: \"\"\"Gets slice objects for the non-PML interior region of the simulation volume. Returns: tuple[slice, slice, slice]: Three slice objects for indexing the x, y, z dimensions respectively, excluding the PML boundary regions. \"\"\" return ( slice ( self . thickness_grid_minx + 1 if self . boundary_type_minx == \"pml\" else 0 , - self . thickness_grid_maxx - 1 if self . boundary_type_maxx == \"pml\" else None , ), slice ( self . thickness_grid_miny + 1 if self . boundary_type_miny == \"pml\" else 0 , - self . thickness_grid_maxy - 1 if self . boundary_type_maxy == \"pml\" else None , ), slice ( self . thickness_grid_minz + 1 if self . boundary_type_minz == \"pml\" else 0 , - self . thickness_grid_maxz - 1 if self . boundary_type_maxz == \"pml\" else None , ), ) get_kappa_dict get_kappa_dict ( prop : Literal [ \"kappa_start\" , \"kappa_end\" ], ) -> dict [ str , float ] Gets a dictionary mapping boundary names to their kappa values. Parameters: prop ( Literal ['kappa_start', 'kappa_end'] ) \u2013 Which kappa property to get, either \"kappa_start\" or \"kappa_end\". Returns: dict [ str , float ] \u2013 dict[str, float]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective kappa values. Raises: Exception \u2013 If prop is not \"kappa_start\" or \"kappa_end\" Source code in src/fdtdx/objects/boundaries/initialization.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def get_kappa_dict ( self , prop : Literal [ \"kappa_start\" , \"kappa_end\" ], ) -> dict [ str , float ]: \"\"\"Gets a dictionary mapping boundary names to their kappa values. Args: prop (Literal[\"kappa_start\", \"kappa_end\"]): Which kappa property to get, either \"kappa_start\" or \"kappa_end\". Returns: dict[str, float]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective kappa values. Raises: Exception: If prop is not \"kappa_start\" or \"kappa_end\" \"\"\" if prop == \"kappa_start\" : return { \"min_x\" : self . kappa_start_minx , \"max_x\" : self . kappa_start_maxx , \"min_y\" : self . kappa_start_miny , \"max_y\" : self . kappa_start_maxy , \"min_z\" : self . kappa_start_minz , \"max_z\" : self . kappa_start_maxz , } elif prop == \"kappa_end\" : return { \"min_x\" : self . kappa_end_minx , \"max_x\" : self . kappa_end_maxx , \"min_y\" : self . kappa_end_miny , \"max_y\" : self . kappa_end_maxy , \"min_z\" : self . kappa_end_minz , \"max_z\" : self . kappa_end_maxz , } else : raise Exception ( f \"Unknown: { prop =} \" ) get_type_dict get_type_dict () -> dict [ str , str ] Gets a dictionary mapping boundary names to their boundary types. Returns: dict [ str , str ] \u2013 dict[str, str]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective boundary types (\"pml\" or \"periodic\"). Source code in src/fdtdx/objects/boundaries/initialization.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def get_type_dict ( self ) -> dict [ str , str ]: \"\"\"Gets a dictionary mapping boundary names to their boundary types. Returns: dict[str, str]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective boundary types (\"pml\" or \"periodic\"). \"\"\" return { \"min_x\" : self . boundary_type_minx , \"max_x\" : self . boundary_type_maxx , \"min_y\" : self . boundary_type_miny , \"max_y\" : self . boundary_type_maxy , \"min_z\" : self . boundary_type_minz , \"max_z\" : self . boundary_type_maxz , }","title":"fdtdx.BoundaryConfig"},{"location":"api/public/BoundaryConfig/#fdtdxboundaryconfig","text":"","title":"fdtdx.BoundaryConfig"},{"location":"api/public/BoundaryConfig/#fdtdx.BoundaryConfig","text":"Bases: TreeClass Configuration class for boundary conditions. This class stores parameters for boundary conditions in all six directions (min/max x/y/z). Supports both PML and periodic boundaries. For PML, the parameters control the absorption properties and physical size of the PML regions. Attributes: boundary_type_minx ( str ) \u2013 Boundary type at minimum x (\"pml\" or \"periodic\"). Default \"pml\". boundary_type_maxx ( str ) \u2013 Boundary type at maximum x (\"pml\" or \"periodic\"). Default \"pml\". boundary_type_miny ( str ) \u2013 Boundary type at minimum y (\"pml\" or \"periodic\"). Default \"pml\". boundary_type_maxy ( str ) \u2013 Boundary type at maximum y (\"pml\" or \"periodic\"). Default \"pml\". boundary_type_minz ( str ) \u2013 Boundary type at minimum z (\"pml\" or \"periodic\"). Default \"pml\". boundary_type_maxz ( str ) \u2013 Boundary type at maximum z (\"pml\" or \"periodic\"). Default \"pml\". thickness_grid_minx ( int ) \u2013 Number of grid cells for PML at minimum x boundary. Default 10. thickness_grid_maxx ( int ) \u2013 Number of grid cells for PML at maximum x boundary. Default 10. thickness_grid_miny ( int ) \u2013 Number of grid cells for PML at minimum y boundary. Default 10. thickness_grid_maxy ( int ) \u2013 Number of grid cells for PML at maximum y boundary. Default 10. thickness_grid_minz ( int ) \u2013 Number of grid cells for PML at minimum z boundary. Default 10. thickness_grid_maxz ( int ) \u2013 Number of grid cells for PML at maximum z boundary. Default 10. kappa_start_minx ( float ) \u2013 Initial kappa value at min x boundary. Default 1.0. kappa_end_minx ( float ) \u2013 Final kappa value at min x boundary. Default 1.5. kappa_start_maxx ( float ) \u2013 Initial kappa value at max x boundary. Default 1.0. kappa_end_maxx ( float ) \u2013 Final kappa value at max x boundary. Default 1.5. kappa_start_miny ( float ) \u2013 Initial kappa value at min y boundary. Default 1.0. kappa_end_miny ( float ) \u2013 Final kappa value at min y boundary. Default 1.5. kappa_start_maxy ( float ) \u2013 Initial kappa value at max y boundary. Default 1.0. kappa_end_maxy ( float ) \u2013 Final kappa value at max y boundary. Default 1.5. kappa_start_minz ( float ) \u2013 Initial kappa value at min z boundary. Default 1.0. kappa_end_minz ( float ) \u2013 Final kappa value at min z boundary. Default 1.5. kappa_start_maxz ( float ) \u2013 Initial kappa value at max z boundary. Default 1.0. kappa_end_maxz ( float ) \u2013 Final kappa value at max z boundary. Default 1.5.","title":"BoundaryConfig"},{"location":"api/public/BoundaryConfig/#fdtdx.BoundaryConfig.from_uniform_bound","text":"from_uniform_bound ( thickness : int = 10 , boundary_type : str = \"pml\" , kappa_start : float = 1 , kappa_end : float = 1.5 , ) -> BoundaryConfig Creates a BoundaryConfig with uniform parameters for all boundaries. Parameters: thickness ( int , default: 10 ) \u2013 Grid thickness to use for all PML boundaries. Defaults to 10. boundary_type ( str , default: 'pml' ) \u2013 Type of boundary to use (\"pml\" or \"periodic\"). Defaults to \"pml\". kappa_start ( float , default: 1 ) \u2013 Initial kappa value for all boundaries. Defaults to 1.0. kappa_end ( float , default: 1.5 ) \u2013 Final kappa value for all boundaries. Defaults to 1.5. Returns: BoundaryConfig ( BoundaryConfig ) \u2013 New config object with uniform parameters Source code in src/fdtdx/objects/boundaries/initialization.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 @classmethod def from_uniform_bound ( cls , thickness : int = 10 , boundary_type : str = \"pml\" , kappa_start : float = 1 , kappa_end : float = 1.5 , ) -> \"BoundaryConfig\" : \"\"\"Creates a BoundaryConfig with uniform parameters for all boundaries. Args: thickness (int, optional): Grid thickness to use for all PML boundaries. Defaults to 10. boundary_type (str, optional): Type of boundary to use (\"pml\" or \"periodic\"). Defaults to \"pml\". kappa_start (float, optional): Initial kappa value for all boundaries. Defaults to 1.0. kappa_end (float, optional): Final kappa value for all boundaries. Defaults to 1.5. Returns: BoundaryConfig: New config object with uniform parameters \"\"\" return cls ( boundary_type_minx = boundary_type , boundary_type_maxx = boundary_type , boundary_type_miny = boundary_type , boundary_type_maxy = boundary_type , boundary_type_minz = boundary_type , boundary_type_maxz = boundary_type , thickness_grid_minx = thickness , thickness_grid_maxx = thickness , thickness_grid_miny = thickness , thickness_grid_maxy = thickness , thickness_grid_minz = thickness , thickness_grid_maxz = thickness , kappa_start_minx = kappa_start , kappa_end_minx = kappa_end , kappa_start_maxx = kappa_start , kappa_end_maxx = kappa_end , kappa_start_miny = kappa_start , kappa_end_miny = kappa_end , kappa_start_maxy = kappa_start , kappa_end_maxy = kappa_end , kappa_start_minz = kappa_start , kappa_end_minz = kappa_end , kappa_start_maxz = kappa_start , kappa_end_maxz = kappa_end , )","title":"from_uniform_bound"},{"location":"api/public/BoundaryConfig/#fdtdx.BoundaryConfig.get_dict","text":"get_dict () -> dict [ str , int ] Gets a dictionary mapping boundary names to their grid thicknesses. Returns: dict [ str , int ] \u2013 dict[str, int]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective grid thickness values. Source code in src/fdtdx/objects/boundaries/initialization.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def get_dict ( self ) -> dict [ str , int ]: \"\"\"Gets a dictionary mapping boundary names to their grid thicknesses. Returns: dict[str, int]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective grid thickness values. \"\"\" return { \"min_x\" : self . thickness_grid_minx , \"max_x\" : self . thickness_grid_maxx , \"min_y\" : self . thickness_grid_miny , \"max_y\" : self . thickness_grid_maxy , \"min_z\" : self . thickness_grid_minz , \"max_z\" : self . thickness_grid_maxz , }","title":"get_dict"},{"location":"api/public/BoundaryConfig/#fdtdx.BoundaryConfig.get_inside_boundary_slice","text":"get_inside_boundary_slice () -> tuple [ slice , slice , slice ] Gets slice objects for the non-PML interior region of the simulation volume. Returns: tuple [ slice , slice , slice ] \u2013 tuple[slice, slice, slice]: Three slice objects for indexing the x, y, z dimensions respectively, excluding the PML boundary regions. Source code in src/fdtdx/objects/boundaries/initialization.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def get_inside_boundary_slice ( self ) -> tuple [ slice , slice , slice ]: \"\"\"Gets slice objects for the non-PML interior region of the simulation volume. Returns: tuple[slice, slice, slice]: Three slice objects for indexing the x, y, z dimensions respectively, excluding the PML boundary regions. \"\"\" return ( slice ( self . thickness_grid_minx + 1 if self . boundary_type_minx == \"pml\" else 0 , - self . thickness_grid_maxx - 1 if self . boundary_type_maxx == \"pml\" else None , ), slice ( self . thickness_grid_miny + 1 if self . boundary_type_miny == \"pml\" else 0 , - self . thickness_grid_maxy - 1 if self . boundary_type_maxy == \"pml\" else None , ), slice ( self . thickness_grid_minz + 1 if self . boundary_type_minz == \"pml\" else 0 , - self . thickness_grid_maxz - 1 if self . boundary_type_maxz == \"pml\" else None , ), )","title":"get_inside_boundary_slice"},{"location":"api/public/BoundaryConfig/#fdtdx.BoundaryConfig.get_kappa_dict","text":"get_kappa_dict ( prop : Literal [ \"kappa_start\" , \"kappa_end\" ], ) -> dict [ str , float ] Gets a dictionary mapping boundary names to their kappa values. Parameters: prop ( Literal ['kappa_start', 'kappa_end'] ) \u2013 Which kappa property to get, either \"kappa_start\" or \"kappa_end\". Returns: dict [ str , float ] \u2013 dict[str, float]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective kappa values. Raises: Exception \u2013 If prop is not \"kappa_start\" or \"kappa_end\" Source code in src/fdtdx/objects/boundaries/initialization.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def get_kappa_dict ( self , prop : Literal [ \"kappa_start\" , \"kappa_end\" ], ) -> dict [ str , float ]: \"\"\"Gets a dictionary mapping boundary names to their kappa values. Args: prop (Literal[\"kappa_start\", \"kappa_end\"]): Which kappa property to get, either \"kappa_start\" or \"kappa_end\". Returns: dict[str, float]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective kappa values. Raises: Exception: If prop is not \"kappa_start\" or \"kappa_end\" \"\"\" if prop == \"kappa_start\" : return { \"min_x\" : self . kappa_start_minx , \"max_x\" : self . kappa_start_maxx , \"min_y\" : self . kappa_start_miny , \"max_y\" : self . kappa_start_maxy , \"min_z\" : self . kappa_start_minz , \"max_z\" : self . kappa_start_maxz , } elif prop == \"kappa_end\" : return { \"min_x\" : self . kappa_end_minx , \"max_x\" : self . kappa_end_maxx , \"min_y\" : self . kappa_end_miny , \"max_y\" : self . kappa_end_maxy , \"min_z\" : self . kappa_end_minz , \"max_z\" : self . kappa_end_maxz , } else : raise Exception ( f \"Unknown: { prop =} \" )","title":"get_kappa_dict"},{"location":"api/public/BoundaryConfig/#fdtdx.BoundaryConfig.get_type_dict","text":"get_type_dict () -> dict [ str , str ] Gets a dictionary mapping boundary names to their boundary types. Returns: dict [ str , str ] \u2013 dict[str, str]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective boundary types (\"pml\" or \"periodic\"). Source code in src/fdtdx/objects/boundaries/initialization.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def get_type_dict ( self ) -> dict [ str , str ]: \"\"\"Gets a dictionary mapping boundary names to their boundary types. Returns: dict[str, str]: Dictionary with keys 'min_x', 'max_x', 'min_y', 'max_y', 'min_z', 'max_z' mapping to their respective boundary types (\"pml\" or \"periodic\"). \"\"\" return { \"min_x\" : self . boundary_type_minx , \"max_x\" : self . boundary_type_maxx , \"min_y\" : self . boundary_type_miny , \"max_y\" : self . boundary_type_maxy , \"min_z\" : self . boundary_type_minz , \"max_z\" : self . boundary_type_maxz , }","title":"get_type_dict"},{"location":"api/public/BrushConstraint2D/","text":"fdtdx.BrushConstraint2D Bases: ParameterTransformation Applies 2D brush-based constraints to ensure minimum feature sizes. Implements the brush-based constraint method described in: https://pubs.acs.org/doi/10.1021/acsphotonics.2c00313 This ensures minimum feature sizes and connectivity in 2D designs by using morphological operations with a brush kernel. Attributes: brush ( Array ) \u2013 Array defining the brush kernel for morphological operations. axis ( int ) \u2013 Axis along which to apply the 2D constraint (perpendicular plane). background_material ( str | None ) \u2013 Name of the background material in the material dictionary of the device. If None, the material with the lowest permittivity is used. Defaults to None.","title":"fdtdx.BrushConstraint2D"},{"location":"api/public/BrushConstraint2D/#fdtdxbrushconstraint2d","text":"","title":"fdtdx.BrushConstraint2D"},{"location":"api/public/BrushConstraint2D/#fdtdx.BrushConstraint2D","text":"Bases: ParameterTransformation Applies 2D brush-based constraints to ensure minimum feature sizes. Implements the brush-based constraint method described in: https://pubs.acs.org/doi/10.1021/acsphotonics.2c00313 This ensures minimum feature sizes and connectivity in 2D designs by using morphological operations with a brush kernel. Attributes: brush ( Array ) \u2013 Array defining the brush kernel for morphological operations. axis ( int ) \u2013 Axis along which to apply the 2D constraint (perpendicular plane). background_material ( str | None ) \u2013 Name of the background material in the material dictionary of the device. If None, the material with the lowest permittivity is used. Defaults to None.","title":"BrushConstraint2D"},{"location":"api/public/ClosestIndex/","text":"fdtdx.ClosestIndex Bases: ParameterTransformation Maps continuous latent values to nearest allowed material indices. For each input value, finds the index of the closest allowed inverse permittivity value. Uses straight-through gradient estimation to maintain differentiability. If mapping_from_inverse_permittivities is set to False (default), then the transform only quantizes the latent parameters to the closest integer value.","title":"fdtdx.ClosestIndex"},{"location":"api/public/ClosestIndex/#fdtdxclosestindex","text":"","title":"fdtdx.ClosestIndex"},{"location":"api/public/ClosestIndex/#fdtdx.ClosestIndex","text":"Bases: ParameterTransformation Maps continuous latent values to nearest allowed material indices. For each input value, finds the index of the closest allowed inverse permittivity value. Uses straight-through gradient estimation to maintain differentiability. If mapping_from_inverse_permittivities is set to False (default), then the transform only quantizes the latent parameters to the closest integer value.","title":"ClosestIndex"},{"location":"api/public/ConnectHolesAndStructures/","text":"fdtdx.ConnectHolesAndStructures Bases: SameShapeTypeParameterTransform Connects floating polymer regions and ensures air holes connect to outside. This constraint module ensures physical realizability of designs by: 1. Either connecting floating polymer regions to the substrate or removing them 2. Ensuring all air holes are connected to the outside (no trapped air) The bottom (lower z) is treated as the substrate reference. Attributes: fill_material ( str | None ) \u2013 Name of material to use for filling gaps when connecting regions. Required when working with more than 2 materials. Defaults to None. background_material ( str | None ) \u2013 Name of the background material. If none, the material with the lowest permittivity is used. Defaults to None.","title":"fdtdx.ConnectHolesAndStructures"},{"location":"api/public/ConnectHolesAndStructures/#fdtdxconnectholesandstructures","text":"","title":"fdtdx.ConnectHolesAndStructures"},{"location":"api/public/ConnectHolesAndStructures/#fdtdx.ConnectHolesAndStructures","text":"Bases: SameShapeTypeParameterTransform Connects floating polymer regions and ensures air holes connect to outside. This constraint module ensures physical realizability of designs by: 1. Either connecting floating polymer regions to the substrate or removing them 2. Ensuring all air holes are connected to the outside (no trapped air) The bottom (lower z) is treated as the substrate reference. Attributes: fill_material ( str | None ) \u2013 Name of material to use for filling gaps when connecting regions. Required when working with more than 2 materials. Defaults to None. background_material ( str | None ) \u2013 Name of the background material. If none, the material with the lowest permittivity is used. Defaults to None.","title":"ConnectHolesAndStructures"},{"location":"api/public/Cylinder/","text":"fdtdx.Cylinder Bases: StaticMultiMaterialObject A cylindrical optical fiber with configurable properties. This class represents a cylindrical fiber with customizable radius, material, and orientation. The fiber can be positioned along any of the three principal axes. Attributes: radius ( float ) \u2013 The radius of the fiber in meter. axis ( int ) \u2013 The principal axis along which the fiber extends (0=x, 1=y, 2=z). material_name ( str ) \u2013 Name of the material in the materials dictionary to be used for the object. horizontal_axis property horizontal_axis : int Gets the horizontal axis perpendicular to the fiber axis. Returns: int ( int ) \u2013 The index of the horizontal axis (0=x or 1=y). vertical_axis property vertical_axis : int Gets the vertical axis perpendicular to the fiber axis. Returns: int ( int ) \u2013 The index of the vertical axis (1=y or 2=z).","title":"fdtdx.Cylinder"},{"location":"api/public/Cylinder/#fdtdxcylinder","text":"","title":"fdtdx.Cylinder"},{"location":"api/public/Cylinder/#fdtdx.Cylinder","text":"Bases: StaticMultiMaterialObject A cylindrical optical fiber with configurable properties. This class represents a cylindrical fiber with customizable radius, material, and orientation. The fiber can be positioned along any of the three principal axes. Attributes: radius ( float ) \u2013 The radius of the fiber in meter. axis ( int ) \u2013 The principal axis along which the fiber extends (0=x, 1=y, 2=z). material_name ( str ) \u2013 Name of the material in the materials dictionary to be used for the object.","title":"Cylinder"},{"location":"api/public/Cylinder/#fdtdx.Cylinder.horizontal_axis","text":"horizontal_axis : int Gets the horizontal axis perpendicular to the fiber axis. Returns: int ( int ) \u2013 The index of the horizontal axis (0=x or 1=y).","title":"horizontal_axis"},{"location":"api/public/Cylinder/#fdtdx.Cylinder.vertical_axis","text":"vertical_axis : int Gets the vertical axis perpendicular to the fiber axis. Returns: int ( int ) \u2013 The index of the vertical axis (1=y or 2=z).","title":"vertical_axis"},{"location":"api/public/Device/","text":"fdtdx.Device Bases: OrderableObject , ABC Abstract base class for devices with optimizable permittivity distributions. This class defines the common interface and functionality for both discrete and continuous devices that can be optimized through gradient-based methods. Attributes: materials ( dict [ str , Material ] ) \u2013 Dictionary of materials to be used in the device. param_transforms ( Sequence [ ParameterTransformation ] ) \u2013 A Sequence of parameter transformation to be applied to the parameters when mapping them to simulation materials. color ( tuple [ float , float , float ] | None ) \u2013 Color of the object when plotted. Defaults to Pink. partial_voxel_grid_shape ( PartialGridShape3D ) \u2013 Size of the material voxels used within the device in metrical units (meter). Note that this is independent of the simulation voxel size. Defaults to undefined shape. For all three axes, either the voxel grid or real shape needs to be defined. partial_voxel_real_shape ( PartialRealShape3D ) \u2013 Size of the material voxels used within the device in simulation voxels. Defaults to undefined shape. For all three axes, either the voxel grid or real shape needs to be defined. matrix_voxel_grid_shape property matrix_voxel_grid_shape : tuple [ int , int , int ] Calculate the shape of the voxel matrix in grid coordinates. Returns: tuple [ int , int , int ] \u2013 tuple[int, int, int]: Tuple of (x,y,z) dimensions representing how many voxels fit in each direction of the grid shape when divided by the single voxel shape. single_voxel_grid_shape property single_voxel_grid_shape : tuple [ int , int , int ] Get the shape of a single voxel in grid coordinates. Returns: tuple [ int , int , int ] \u2013 tuple[int, int, int]: Tuple of (x,y,z) dimensions for one voxel. single_voxel_real_shape property single_voxel_real_shape : tuple [ float , float , float ] Calculate the shape of a single voxel in real (physical) coordinates. Returns: tuple [ float , float , float ] \u2013 tuple[float, float, float]: Tuple of (x,y,z) dimensions in real units, computed by multiplying the grid shape by the simulation resolution.","title":"fdtdx.Device"},{"location":"api/public/Device/#fdtdxdevice","text":"","title":"fdtdx.Device"},{"location":"api/public/Device/#fdtdx.Device","text":"Bases: OrderableObject , ABC Abstract base class for devices with optimizable permittivity distributions. This class defines the common interface and functionality for both discrete and continuous devices that can be optimized through gradient-based methods. Attributes: materials ( dict [ str , Material ] ) \u2013 Dictionary of materials to be used in the device. param_transforms ( Sequence [ ParameterTransformation ] ) \u2013 A Sequence of parameter transformation to be applied to the parameters when mapping them to simulation materials. color ( tuple [ float , float , float ] | None ) \u2013 Color of the object when plotted. Defaults to Pink. partial_voxel_grid_shape ( PartialGridShape3D ) \u2013 Size of the material voxels used within the device in metrical units (meter). Note that this is independent of the simulation voxel size. Defaults to undefined shape. For all three axes, either the voxel grid or real shape needs to be defined. partial_voxel_real_shape ( PartialRealShape3D ) \u2013 Size of the material voxels used within the device in simulation voxels. Defaults to undefined shape. For all three axes, either the voxel grid or real shape needs to be defined.","title":"Device"},{"location":"api/public/Device/#fdtdx.Device.matrix_voxel_grid_shape","text":"matrix_voxel_grid_shape : tuple [ int , int , int ] Calculate the shape of the voxel matrix in grid coordinates. Returns: tuple [ int , int , int ] \u2013 tuple[int, int, int]: Tuple of (x,y,z) dimensions representing how many voxels fit in each direction of the grid shape when divided by the single voxel shape.","title":"matrix_voxel_grid_shape"},{"location":"api/public/Device/#fdtdx.Device.single_voxel_grid_shape","text":"single_voxel_grid_shape : tuple [ int , int , int ] Get the shape of a single voxel in grid coordinates. Returns: tuple [ int , int , int ] \u2013 tuple[int, int, int]: Tuple of (x,y,z) dimensions for one voxel.","title":"single_voxel_grid_shape"},{"location":"api/public/Device/#fdtdx.Device.single_voxel_real_shape","text":"single_voxel_real_shape : tuple [ float , float , float ] Calculate the shape of a single voxel in real (physical) coordinates. Returns: tuple [ float , float , float ] \u2013 tuple[float, float, float]: Tuple of (x,y,z) dimensions in real units, computed by multiplying the grid shape by the simulation resolution.","title":"single_voxel_real_shape"},{"location":"api/public/DiagonalSymmetry2D/","text":"fdtdx.DiagonalSymmetry2D Bases: SameShapeTypeParameterTransform Enforce symmetries by effectively havling the parameter space. The symmetry is transposing by rotating the image and taking the mean of original and transpose. Attributes: min_min_to_max_max ( bool ) \u2013 if true, the symmetry axes is from (x_min, y_min) to (x_max, y_max). If false, the other diagonal is used.","title":"fdtdx.DiagonalSymmetry2D"},{"location":"api/public/DiagonalSymmetry2D/#fdtdxdiagonalsymmetry2d","text":"","title":"fdtdx.DiagonalSymmetry2D"},{"location":"api/public/DiagonalSymmetry2D/#fdtdx.DiagonalSymmetry2D","text":"Bases: SameShapeTypeParameterTransform Enforce symmetries by effectively havling the parameter space. The symmetry is transposing by rotating the image and taking the mean of original and transpose. Attributes: min_min_to_max_max ( bool ) \u2013 if true, the symmetry axes is from (x_min, y_min) to (x_max, y_max). If false, the other diagonal is used.","title":"DiagonalSymmetry2D"},{"location":"api/public/DtypeConversion/","text":"fdtdx.DtypeConversion Bases: CompressionModule Compression module that converts data types of field values. This module changes the data type of field values while preserving their shape, useful for reducing memory usage or meeting precision requirements. Attributes: dtype ( dtype ) \u2013 Target data type for conversion. exclude_filter ( Sequence [ str ] ) \u2013 List of field names to exclude from conversion.","title":"fdtdx.DtypeConversion"},{"location":"api/public/DtypeConversion/#fdtdxdtypeconversion","text":"","title":"fdtdx.DtypeConversion"},{"location":"api/public/DtypeConversion/#fdtdx.DtypeConversion","text":"Bases: CompressionModule Compression module that converts data types of field values. This module changes the data type of field values while preserving their shape, useful for reducing memory usage or meeting precision requirements. Attributes: dtype ( dtype ) \u2013 Target data type for conversion. exclude_filter ( Sequence [ str ] ) \u2013 List of field names to exclude from conversion.","title":"DtypeConversion"},{"location":"api/public/EnergyDetector/","text":"fdtdx.EnergyDetector Bases: Detector Detector for measuring electromagnetic energy distribution. This detector computes and records the electromagnetic energy density at specified points in the simulation volume. It can operate in different modes to either record full 3D data, 2D slices, or reduced volume measurements. Attributes: as_slices ( bool ) \u2013 If True, returns energy measurements as 2D slices through the volume. Defaults to False. reduce_volume ( bool ) \u2013 If True, reduces the volume data to a single energy value. Defaults to False. x_slice ( float | None ) \u2013 real-world positions for slice extraction. Defaults to None. y_slice ( float | None ) \u2013 real-world positions for slice extraction. Defaults to None. z_slice ( float | None ) \u2013 real-world positions for slice extraction. Defaults to None. aggregate ( str | None ) \u2013 If \"mean\", aggregates slices by averaging instead of using position. If None, mean is used. Defaults to None.","title":"fdtdx.EnergyDetector"},{"location":"api/public/EnergyDetector/#fdtdxenergydetector","text":"","title":"fdtdx.EnergyDetector"},{"location":"api/public/EnergyDetector/#fdtdx.EnergyDetector","text":"Bases: Detector Detector for measuring electromagnetic energy distribution. This detector computes and records the electromagnetic energy density at specified points in the simulation volume. It can operate in different modes to either record full 3D data, 2D slices, or reduced volume measurements. Attributes: as_slices ( bool ) \u2013 If True, returns energy measurements as 2D slices through the volume. Defaults to False. reduce_volume ( bool ) \u2013 If True, reduces the volume data to a single energy value. Defaults to False. x_slice ( float | None ) \u2013 real-world positions for slice extraction. Defaults to None. y_slice ( float | None ) \u2013 real-world positions for slice extraction. Defaults to None. z_slice ( float | None ) \u2013 real-world positions for slice extraction. Defaults to None. aggregate ( str | None ) \u2013 If \"mean\", aggregates slices by averaging instead of using position. If None, mean is used. Defaults to None.","title":"EnergyDetector"},{"location":"api/public/ExtrudedPolygon/","text":"fdtdx.ExtrudedPolygon Bases: StaticMultiMaterialObject A polygon object specified by a list of vertices. The coordinate system has its origin at the lower left of the bounding box of the polygon. Attributes: material_name ( str ) \u2013 Name of the material in the materials dictionary to be used for the object axis ( int ) \u2013 The extrusion axis. vertices ( ndarray ) \u2013 numpy array of shape (N, 2) specifying the position of vertices in metrical units (meter). horizontal_axis property horizontal_axis : int Gets the horizontal axis perpendicular to the fiber axis. Returns: int ( int ) \u2013 The index of the horizontal axis (0=x or 1=y). vertical_axis property vertical_axis : int Gets the vertical axis perpendicular to the fiber axis. Returns: int ( int ) \u2013 The index of the vertical axis (1=y or 2=z).","title":"fdtdx.ExtrudedPolygon"},{"location":"api/public/ExtrudedPolygon/#fdtdxextrudedpolygon","text":"","title":"fdtdx.ExtrudedPolygon"},{"location":"api/public/ExtrudedPolygon/#fdtdx.ExtrudedPolygon","text":"Bases: StaticMultiMaterialObject A polygon object specified by a list of vertices. The coordinate system has its origin at the lower left of the bounding box of the polygon. Attributes: material_name ( str ) \u2013 Name of the material in the materials dictionary to be used for the object axis ( int ) \u2013 The extrusion axis. vertices ( ndarray ) \u2013 numpy array of shape (N, 2) specifying the position of vertices in metrical units (meter).","title":"ExtrudedPolygon"},{"location":"api/public/ExtrudedPolygon/#fdtdx.ExtrudedPolygon.horizontal_axis","text":"horizontal_axis : int Gets the horizontal axis perpendicular to the fiber axis. Returns: int ( int ) \u2013 The index of the horizontal axis (0=x or 1=y).","title":"horizontal_axis"},{"location":"api/public/ExtrudedPolygon/#fdtdx.ExtrudedPolygon.vertical_axis","text":"vertical_axis : int Gets the vertical axis perpendicular to the fiber axis. Returns: int ( int ) \u2013 The index of the vertical axis (1=y or 2=z).","title":"vertical_axis"},{"location":"api/public/FieldDetector/","text":"fdtdx.FieldDetector Bases: Detector Detector for measuring field components of electromagnetic fields in the time domain. Attributes: reduce_volume ( bool ) \u2013 If True, reduces the volume of recorded data. Defaults to False. components ( Sequence [ Literal ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']] ) \u2013 Sequence of field components to measure. Can include any of: \"Ex\", \"Ey\", \"Ez\", \"Hx\", \"Hy\", \"Hz\". Defaults to (\"Ex\", \"Ey\", \"Ez\", \"Hx\", \"Hy\", \"Hz\").","title":"fdtdx.FieldDetector"},{"location":"api/public/FieldDetector/#fdtdxfielddetector","text":"","title":"fdtdx.FieldDetector"},{"location":"api/public/FieldDetector/#fdtdx.FieldDetector","text":"Bases: Detector Detector for measuring field components of electromagnetic fields in the time domain. Attributes: reduce_volume ( bool ) \u2013 If True, reduces the volume of recorded data. Defaults to False. components ( Sequence [ Literal ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']] ) \u2013 Sequence of field components to measure. Can include any of: \"Ex\", \"Ey\", \"Ez\", \"Hx\", \"Hy\", \"Hz\". Defaults to (\"Ex\", \"Ey\", \"Ez\", \"Hx\", \"Hy\", \"Hz\").","title":"FieldDetector"},{"location":"api/public/GaussianPlaneSource/","text":"fdtdx.GaussianPlaneSource Bases: LinearlyPolarizedPlaneSource","title":"fdtdx.GaussianPlaneSource"},{"location":"api/public/GaussianPlaneSource/#fdtdxgaussianplanesource","text":"","title":"fdtdx.GaussianPlaneSource"},{"location":"api/public/GaussianPlaneSource/#fdtdx.GaussianPlaneSource","text":"Bases: LinearlyPolarizedPlaneSource","title":"GaussianPlaneSource"},{"location":"api/public/GaussianPulseProfile/","text":"fdtdx.GaussianPulseProfile Bases: TemporalProfile Gaussian pulse temporal profile with carrier wave.","title":"fdtdx.GaussianPulseProfile"},{"location":"api/public/GaussianPulseProfile/#fdtdxgaussianpulseprofile","text":"","title":"fdtdx.GaussianPulseProfile"},{"location":"api/public/GaussianPulseProfile/#fdtdx.GaussianPulseProfile","text":"Bases: TemporalProfile Gaussian pulse temporal profile with carrier wave.","title":"GaussianPulseProfile"},{"location":"api/public/GaussianSmoothing2D/","text":"fdtdx.GaussianSmoothing2D Bases: SameShapeTypeParameterTransform Applies Gaussian smoothing to 2D parameter arrays. This transform convolves the input with a 2D Gaussian kernel, which helps reduce noise and smooth the data. Attributes: std_discrete ( int ) \u2013 Integer specifying the standard deviation of the Gaussian kernel in discrete units.","title":"fdtdx.GaussianSmoothing2D"},{"location":"api/public/GaussianSmoothing2D/#fdtdxgaussiansmoothing2d","text":"","title":"fdtdx.GaussianSmoothing2D"},{"location":"api/public/GaussianSmoothing2D/#fdtdx.GaussianSmoothing2D","text":"Bases: SameShapeTypeParameterTransform Applies Gaussian smoothing to 2D parameter arrays. This transform convolves the input with a 2D Gaussian kernel, which helps reduce noise and smooth the data. Attributes: std_discrete ( int ) \u2013 Integer specifying the standard deviation of the Gaussian kernel in discrete units.","title":"GaussianSmoothing2D"},{"location":"api/public/GradientConfig/","text":"fdtdx.GradientConfig Bases: TreeClass Configuration for gradient computation in simulations. This class handles settings for automatic differentiation, supporting either invertible differentiation with a recorder or checkpointing-based differentiation. Attributes: method ( Literal ['reversible', 'checkpointed'] ) \u2013 Method for gradient computation. Can be either \"reversible\" when using the time reversible autodiff, or \"checkpointed\" for the exact checkpointing algorithm. recorder ( Recorder | None ) \u2013 Optional recorder for invertible differentiation. Needs to be provided for reversible autodiff. Defaults to None num_checkpoints ( int | None ) \u2013 Optional number of checkpoints for checkpointing-based differentiation. Needs to be provided for checkpointing gradient computation. Defaults to None.","title":"fdtdx.GradientConfig"},{"location":"api/public/GradientConfig/#fdtdxgradientconfig","text":"","title":"fdtdx.GradientConfig"},{"location":"api/public/GradientConfig/#fdtdx.GradientConfig","text":"Bases: TreeClass Configuration for gradient computation in simulations. This class handles settings for automatic differentiation, supporting either invertible differentiation with a recorder or checkpointing-based differentiation. Attributes: method ( Literal ['reversible', 'checkpointed'] ) \u2013 Method for gradient computation. Can be either \"reversible\" when using the time reversible autodiff, or \"checkpointed\" for the exact checkpointing algorithm. recorder ( Recorder | None ) \u2013 Optional recorder for invertible differentiation. Needs to be provided for reversible autodiff. Defaults to None num_checkpoints ( int | None ) \u2013 Optional number of checkpoints for checkpointing-based differentiation. Needs to be provided for checkpointing gradient computation. Defaults to None.","title":"GradientConfig"},{"location":"api/public/GridCoordinateConstraint/","text":"fdtdx.GridCoordinateConstraint dataclass GridCoordinateConstraint ( * , object : SimulationObject , axes : tuple [ int , ... ], sides : tuple [ Literal [ \"+\" , \"-\" ], ... ], coordinates : tuple [ int , ... ] ) Constrains an object's position to specific grid coordinates. Forces specific sides of an object to align with given grid coordinates. Used for precise positioning in the discretized simulation space. Attributes: object ( SimulationObject ) \u2013 The object to position axes ( tuple [ int , ...] ) \u2013 Which axes to constrain sides ( tuple [ Literal ['+', '-'], ...] ) \u2013 Which side of each axis ('+' or '-') coordinates ( tuple [ int , ...] ) \u2013 Grid coordinates to align with","title":"fdtdx.GridCoordinateConstraint"},{"location":"api/public/GridCoordinateConstraint/#fdtdxgridcoordinateconstraint","text":"","title":"fdtdx.GridCoordinateConstraint"},{"location":"api/public/GridCoordinateConstraint/#fdtdx.GridCoordinateConstraint","text":"GridCoordinateConstraint ( * , object : SimulationObject , axes : tuple [ int , ... ], sides : tuple [ Literal [ \"+\" , \"-\" ], ... ], coordinates : tuple [ int , ... ] ) Constrains an object's position to specific grid coordinates. Forces specific sides of an object to align with given grid coordinates. Used for precise positioning in the discretized simulation space. Attributes: object ( SimulationObject ) \u2013 The object to position axes ( tuple [ int , ...] ) \u2013 Which axes to constrain sides ( tuple [ Literal ['+', '-'], ...] ) \u2013 Which side of each axis ('+' or '-') coordinates ( tuple [ int , ...] ) \u2013 Grid coordinates to align with","title":"GridCoordinateConstraint"},{"location":"api/public/LinearReconstructEveryK/","text":"fdtdx.LinearReconstructEveryK Bases: TimeStepFilter Time step filter that performs linear reconstruction between sampled steps. This filter saves field values every k time steps and uses linear interpolation to reconstruct values at intermediate time steps. Attributes: k ( int ) \u2013 Number of time steps between saved values. start_recording_after ( int ) \u2013 Time step to start recording from. Defaults to zero.","title":"fdtdx.LinearReconstructEveryK"},{"location":"api/public/LinearReconstructEveryK/#fdtdxlinearreconstructeveryk","text":"","title":"fdtdx.LinearReconstructEveryK"},{"location":"api/public/LinearReconstructEveryK/#fdtdx.LinearReconstructEveryK","text":"Bases: TimeStepFilter Time step filter that performs linear reconstruction between sampled steps. This filter saves field values every k time steps and uses linear interpolation to reconstruct values at intermediate time steps. Attributes: k ( int ) \u2013 Number of time steps between saved values. start_recording_after ( int ) \u2013 Time step to start recording from. Defaults to zero.","title":"LinearReconstructEveryK"},{"location":"api/public/Logger/","text":"fdtdx.Logger Logger ( experiment_name : str , name : str | None = None ) Logger for managing experiment outputs and visualization. Handles experiment logging, metrics tracking, and visualization of simulation results. Creates a working directory structure, initializes logging, and provides methods for saving figures, metrics, and device parameters. Parameters: experiment_name ( str ) \u2013 Name of the experiment. This is the naming of the parent directory where the experiment will be saved. name ( str | None , default: None ) \u2013 Optional specific name for the working directory. If None, uses timestamp. Source code in src/fdtdx/utils/logger.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def __init__ ( self , experiment_name : str , name : str | None = None ): sns . set_theme ( context = \"paper\" , style = \"white\" , palette = \"colorblind\" ) self . cwd = init_working_directory ( experiment_name , wd_name = name ) self . console = Console () self . progress = Progress ( SpinnerColumn (), * Progress . get_default_columns (), TimeElapsedColumn (), console = self . console , ) . __enter__ () atexit . register ( self . progress . stop ) logger . remove () logger . add ( self . console . print , level = \"TRACE\" , format = _log_formatter , colorize = True , ) logger . add ( self . cwd / \"logs.log\" , level = \"TRACE\" , format = \"{time:DD.MM.YYYY HH:mm:ss:ssss} | {level} - {message} \" , ) logger . info ( f \"Starting experiment { experiment_name } in { self . cwd } \" ) snapshot_python_files ( self . cwd / \"code\" ) self . fieldnames = None self . writer = None self . csvfile = open ( self . cwd / \"metrics.csv\" , \"w\" , newline = \"\" ) self . last_indices : dict [ str , jax . Array | None ] = defaultdict ( lambda : None ) atexit . register ( self . csvfile . close ) params_dir property params_dir : Path Directory for storing parameter files. Returns: Path ( Path ) \u2013 Directory for parameter file outputs stl_dir property stl_dir : Path Directory for storing STL files. Returns: Path ( Path ) \u2013 Directory for STL file outputs log_detectors log_detectors ( iter_idx : int , objects : ObjectContainer , detector_states : dict [ str , DetectorState ], exclude : Sequence [ str ] = [], ) Log detector states and generate visualization plots. Creates plots for each detector's state and saves them to the detector's output directory. Handles both figure outputs and other detector-specific file formats. Parameters: iter_idx ( int ) \u2013 Current iteration index objects ( ObjectContainer ) \u2013 Container with simulation objects detector_states ( dict [ str , DetectorState ] ) \u2013 Dictionary mapping detector names to their states exclude ( Sequence [ str ] , default: [] ) \u2013 List of detector names to exclude from logging Source code in src/fdtdx/utils/logger.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def log_detectors ( self , iter_idx : int , objects : ObjectContainer , detector_states : dict [ str , DetectorState ], exclude : Sequence [ str ] = [], ): \"\"\"Log detector states and generate visualization plots. Creates plots for each detector's state and saves them to the detector's output directory. Handles both figure outputs and other detector-specific file formats. Args: iter_idx (int): Current iteration index objects (ObjectContainer): Container with simulation objects detector_states (dict[str, DetectorState]): Dictionary mapping detector names to their states exclude (Sequence[str], optional): List of detector names to exclude from logging \"\"\" for detector in [ d for d in objects . detectors if d . name not in exclude ]: cur_state = jax . device_get ( detector_states [ detector . name ]) cur_state = cast_floating_to_numpy ( cur_state , float ) if not detector . plot : continue figure_dict = detector . draw_plot ( state = cur_state , progress = self . progress , ) detector_dir = self . cwd / \"detectors\" / detector . name detector_dir . mkdir ( parents = True , exist_ok = True ) for k , v in figure_dict . items (): if isinstance ( v , Figure ): self . savefig ( detector_dir , f \" { detector . name } _ { k } _ { iter_idx } .png\" , v , dpi = detector . plot_dpi , # type: ignore ) elif isinstance ( v , str ): shutil . copy ( v , detector_dir / f \" { detector . name } _ { k } _ { iter_idx }{ Path ( v ) . suffix } \" , ) else : raise Exception ( f \"invalid detector output for plotting: { k } , { v } \" ) log_params log_params ( iter_idx : int , params : ParameterContainer , objects : ObjectContainer , export_figure : bool = False , export_stl : bool = False , export_background_stl : bool = False , ** transformation_kwargs ) -> int Log parameter states and export device visualizations. Saves device parameters and optionally exports visualizations as figures or STL files. Tracks changes in device voxels between iterations. Parameters: iter_idx ( int ) \u2013 Current iteration index params ( ParameterContainer ) \u2013 Container with device parameters objects ( ObjectContainer ) \u2013 Container with simulation objects export_figure ( bool , default: False ) \u2013 Whether to export index matrix figures export_stl ( bool , default: False ) \u2013 Whether to export device geometry as STL export_background_stl ( bool , default: False ) \u2013 Whether to export air regions as STL **transformation_kwargs \u2013 keyword arguments passed to the parameter transformation Returns: int ( int ) \u2013 Number of voxels that changed since last iteration Source code in src/fdtdx/utils/logger.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def log_params ( self , iter_idx : int , params : ParameterContainer , objects : ObjectContainer , export_figure : bool = False , export_stl : bool = False , export_background_stl : bool = False , ** transformation_kwargs , ) -> int : \"\"\"Log parameter states and export device visualizations. Saves device parameters and optionally exports visualizations as figures or STL files. Tracks changes in device voxels between iterations. Args: iter_idx (int): Current iteration index params (ParameterContainer): Container with device parameters objects (ObjectContainer): Container with simulation objects export_figure (bool, optional): Whether to export index matrix figures export_stl (bool, optional): Whether to export device geometry as STL export_background_stl (bool, optional): Whether to export air regions as STL **transformation_kwargs: keyword arguments passed to the parameter transformation Returns: int: Number of voxels that changed since last iteration \"\"\" changed_voxels = 0 for device in objects . devices : device_params = params [ device . name ] indices = device ( device_params , ** transformation_kwargs ) # raw parameters and indices if isinstance ( device_params , dict ): for k , v in device_params . items (): jnp . save ( self . params_dir / f \"params_ { iter_idx } _ { device . name } _ { k } .npy\" , v ) else : jnp . save ( self . params_dir / f \"params_ { iter_idx } _ { device . name } .npy\" , device_params ) jnp . save ( self . params_dir / f \"matrix_ { iter_idx } _ { device . name } .npy\" , indices ) has_previous = self . last_indices [ device . name ] is not None cur_changed_voxels = 0 if has_previous : last_device_indices = self . last_indices [ device . name ] cur_changed_voxels = int ( jnp . sum ( indices != last_device_indices )) changed_voxels += cur_changed_voxels self . last_indices [ device . name ] = indices if cur_changed_voxels == 0 and has_previous : continue if export_stl : background_name = get_background_material_name ( device . materials ) ordered_name_list = compute_ordered_names ( device . materials ) background_idx = ordered_name_list . index ( background_name ) for idx in range ( len ( device . materials )): if idx == background_idx and not export_background_stl : continue name = ordered_name_list [ idx ] export_stl_fn ( matrix = np . round ( indices ) == idx , stl_filename = self . stl_dir / f \"matrix_ { iter_idx } _ { device . name } _ { name } .stl\" , voxel_grid_size = device . single_voxel_grid_shape , ) if len ( device . materials ) > 2 : export_stl_fn ( matrix = np . round ( indices ) != background_idx , stl_filename = self . stl_dir / f \"matrix_ { iter_idx } _ { device . name } _non_air.stl\" , voxel_grid_size = device . single_voxel_grid_shape , ) # image of indices if export_figure : fig = device_matrix_index_figure ( device_matrix_indices = indices , material = device . materials , parameter_type = device . output_type , ) self . savefig ( self . cwd / \"device\" , f \"matrix_indices_ { iter_idx } _ { device . name } .png\" , fig , ) return changed_voxels savefig savefig ( directory : Path , filename : str , fig : Figure , dpi : int = 300 , ) Save a matplotlib figure to file. Creates a figures subdirectory if needed and saves the figure with specified settings. Parameters: directory ( Path ) \u2013 Base directory to save in filename ( str ) \u2013 Name for the figure file fig ( Figure ) \u2013 Matplotlib figure to save dpi ( int , default: 300 ) \u2013 Resolution in dots per inch. Defaults to 300. Source code in src/fdtdx/utils/logger.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def savefig ( self , directory : Path , filename : str , fig : Figure , dpi : int = 300 ): \"\"\"Save a matplotlib figure to file. Creates a figures subdirectory if needed and saves the figure with specified settings. Args: directory (Path): Base directory to save in filename (str): Name for the figure file fig (Figure): Matplotlib figure to save dpi (int, optional): Resolution in dots per inch. Defaults to 300. \"\"\" figure_directory = directory / \"figures\" figure_directory . mkdir ( parents = True , exist_ok = True ) fig . savefig ( directory / \"figures\" / filename , dpi = dpi , bbox_inches = \"tight\" ) plt . close ( fig ) write write ( stats : dict , do_print : bool = True ) Write statistics to CSV file and optionally print them. Records metrics in a CSV file and optionally displays them in a formatted table. Automatically initializes CSV headers on first write. Parameters: stats ( dict ) \u2013 Dictionary of statistics to record do_print ( bool , default: True ) \u2013 Whether to print stats to console. Defaults to true. Source code in src/fdtdx/utils/logger.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def write ( self , stats : dict , do_print : bool = True ): \"\"\"Write statistics to CSV file and optionally print them. Records metrics in a CSV file and optionally displays them in a formatted table. Automatically initializes CSV headers on first write. Args: stats (dict): Dictionary of statistics to record do_print (bool, optional): Whether to print stats to console. Defaults to true. \"\"\" stats = { k : v . item () if isinstance ( v , jax . Array ) else v for k , v in stats . items () if isinstance ( v , ( int , float )) or ( isinstance ( v , jax . Array ) and v . size == 1 ) } if self . fieldnames is None : self . fieldnames = list ( stats . keys ()) self . writer = csv . DictWriter ( self . csvfile , fieldnames = self . fieldnames ) self . writer . writeheader () assert self . writer is not None self . writer . writerow ( stats ) self . csvfile . flush () if do_print : table = Table ( box = None ) for k , v in stats . items (): table . add_column ( k ) table . add_column ( str ( v )) self . console . print ( table )","title":"fdtdx.Logger"},{"location":"api/public/Logger/#fdtdxlogger","text":"","title":"fdtdx.Logger"},{"location":"api/public/Logger/#fdtdx.Logger","text":"Logger ( experiment_name : str , name : str | None = None ) Logger for managing experiment outputs and visualization. Handles experiment logging, metrics tracking, and visualization of simulation results. Creates a working directory structure, initializes logging, and provides methods for saving figures, metrics, and device parameters. Parameters: experiment_name ( str ) \u2013 Name of the experiment. This is the naming of the parent directory where the experiment will be saved. name ( str | None , default: None ) \u2013 Optional specific name for the working directory. If None, uses timestamp. Source code in src/fdtdx/utils/logger.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def __init__ ( self , experiment_name : str , name : str | None = None ): sns . set_theme ( context = \"paper\" , style = \"white\" , palette = \"colorblind\" ) self . cwd = init_working_directory ( experiment_name , wd_name = name ) self . console = Console () self . progress = Progress ( SpinnerColumn (), * Progress . get_default_columns (), TimeElapsedColumn (), console = self . console , ) . __enter__ () atexit . register ( self . progress . stop ) logger . remove () logger . add ( self . console . print , level = \"TRACE\" , format = _log_formatter , colorize = True , ) logger . add ( self . cwd / \"logs.log\" , level = \"TRACE\" , format = \"{time:DD.MM.YYYY HH:mm:ss:ssss} | {level} - {message} \" , ) logger . info ( f \"Starting experiment { experiment_name } in { self . cwd } \" ) snapshot_python_files ( self . cwd / \"code\" ) self . fieldnames = None self . writer = None self . csvfile = open ( self . cwd / \"metrics.csv\" , \"w\" , newline = \"\" ) self . last_indices : dict [ str , jax . Array | None ] = defaultdict ( lambda : None ) atexit . register ( self . csvfile . close )","title":"Logger"},{"location":"api/public/Logger/#fdtdx.Logger.params_dir","text":"params_dir : Path Directory for storing parameter files. Returns: Path ( Path ) \u2013 Directory for parameter file outputs","title":"params_dir"},{"location":"api/public/Logger/#fdtdx.Logger.stl_dir","text":"stl_dir : Path Directory for storing STL files. Returns: Path ( Path ) \u2013 Directory for STL file outputs","title":"stl_dir"},{"location":"api/public/Logger/#fdtdx.Logger.log_detectors","text":"log_detectors ( iter_idx : int , objects : ObjectContainer , detector_states : dict [ str , DetectorState ], exclude : Sequence [ str ] = [], ) Log detector states and generate visualization plots. Creates plots for each detector's state and saves them to the detector's output directory. Handles both figure outputs and other detector-specific file formats. Parameters: iter_idx ( int ) \u2013 Current iteration index objects ( ObjectContainer ) \u2013 Container with simulation objects detector_states ( dict [ str , DetectorState ] ) \u2013 Dictionary mapping detector names to their states exclude ( Sequence [ str ] , default: [] ) \u2013 List of detector names to exclude from logging Source code in src/fdtdx/utils/logger.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def log_detectors ( self , iter_idx : int , objects : ObjectContainer , detector_states : dict [ str , DetectorState ], exclude : Sequence [ str ] = [], ): \"\"\"Log detector states and generate visualization plots. Creates plots for each detector's state and saves them to the detector's output directory. Handles both figure outputs and other detector-specific file formats. Args: iter_idx (int): Current iteration index objects (ObjectContainer): Container with simulation objects detector_states (dict[str, DetectorState]): Dictionary mapping detector names to their states exclude (Sequence[str], optional): List of detector names to exclude from logging \"\"\" for detector in [ d for d in objects . detectors if d . name not in exclude ]: cur_state = jax . device_get ( detector_states [ detector . name ]) cur_state = cast_floating_to_numpy ( cur_state , float ) if not detector . plot : continue figure_dict = detector . draw_plot ( state = cur_state , progress = self . progress , ) detector_dir = self . cwd / \"detectors\" / detector . name detector_dir . mkdir ( parents = True , exist_ok = True ) for k , v in figure_dict . items (): if isinstance ( v , Figure ): self . savefig ( detector_dir , f \" { detector . name } _ { k } _ { iter_idx } .png\" , v , dpi = detector . plot_dpi , # type: ignore ) elif isinstance ( v , str ): shutil . copy ( v , detector_dir / f \" { detector . name } _ { k } _ { iter_idx }{ Path ( v ) . suffix } \" , ) else : raise Exception ( f \"invalid detector output for plotting: { k } , { v } \" )","title":"log_detectors"},{"location":"api/public/Logger/#fdtdx.Logger.log_params","text":"log_params ( iter_idx : int , params : ParameterContainer , objects : ObjectContainer , export_figure : bool = False , export_stl : bool = False , export_background_stl : bool = False , ** transformation_kwargs ) -> int Log parameter states and export device visualizations. Saves device parameters and optionally exports visualizations as figures or STL files. Tracks changes in device voxels between iterations. Parameters: iter_idx ( int ) \u2013 Current iteration index params ( ParameterContainer ) \u2013 Container with device parameters objects ( ObjectContainer ) \u2013 Container with simulation objects export_figure ( bool , default: False ) \u2013 Whether to export index matrix figures export_stl ( bool , default: False ) \u2013 Whether to export device geometry as STL export_background_stl ( bool , default: False ) \u2013 Whether to export air regions as STL **transformation_kwargs \u2013 keyword arguments passed to the parameter transformation Returns: int ( int ) \u2013 Number of voxels that changed since last iteration Source code in src/fdtdx/utils/logger.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def log_params ( self , iter_idx : int , params : ParameterContainer , objects : ObjectContainer , export_figure : bool = False , export_stl : bool = False , export_background_stl : bool = False , ** transformation_kwargs , ) -> int : \"\"\"Log parameter states and export device visualizations. Saves device parameters and optionally exports visualizations as figures or STL files. Tracks changes in device voxels between iterations. Args: iter_idx (int): Current iteration index params (ParameterContainer): Container with device parameters objects (ObjectContainer): Container with simulation objects export_figure (bool, optional): Whether to export index matrix figures export_stl (bool, optional): Whether to export device geometry as STL export_background_stl (bool, optional): Whether to export air regions as STL **transformation_kwargs: keyword arguments passed to the parameter transformation Returns: int: Number of voxels that changed since last iteration \"\"\" changed_voxels = 0 for device in objects . devices : device_params = params [ device . name ] indices = device ( device_params , ** transformation_kwargs ) # raw parameters and indices if isinstance ( device_params , dict ): for k , v in device_params . items (): jnp . save ( self . params_dir / f \"params_ { iter_idx } _ { device . name } _ { k } .npy\" , v ) else : jnp . save ( self . params_dir / f \"params_ { iter_idx } _ { device . name } .npy\" , device_params ) jnp . save ( self . params_dir / f \"matrix_ { iter_idx } _ { device . name } .npy\" , indices ) has_previous = self . last_indices [ device . name ] is not None cur_changed_voxels = 0 if has_previous : last_device_indices = self . last_indices [ device . name ] cur_changed_voxels = int ( jnp . sum ( indices != last_device_indices )) changed_voxels += cur_changed_voxels self . last_indices [ device . name ] = indices if cur_changed_voxels == 0 and has_previous : continue if export_stl : background_name = get_background_material_name ( device . materials ) ordered_name_list = compute_ordered_names ( device . materials ) background_idx = ordered_name_list . index ( background_name ) for idx in range ( len ( device . materials )): if idx == background_idx and not export_background_stl : continue name = ordered_name_list [ idx ] export_stl_fn ( matrix = np . round ( indices ) == idx , stl_filename = self . stl_dir / f \"matrix_ { iter_idx } _ { device . name } _ { name } .stl\" , voxel_grid_size = device . single_voxel_grid_shape , ) if len ( device . materials ) > 2 : export_stl_fn ( matrix = np . round ( indices ) != background_idx , stl_filename = self . stl_dir / f \"matrix_ { iter_idx } _ { device . name } _non_air.stl\" , voxel_grid_size = device . single_voxel_grid_shape , ) # image of indices if export_figure : fig = device_matrix_index_figure ( device_matrix_indices = indices , material = device . materials , parameter_type = device . output_type , ) self . savefig ( self . cwd / \"device\" , f \"matrix_indices_ { iter_idx } _ { device . name } .png\" , fig , ) return changed_voxels","title":"log_params"},{"location":"api/public/Logger/#fdtdx.Logger.savefig","text":"savefig ( directory : Path , filename : str , fig : Figure , dpi : int = 300 , ) Save a matplotlib figure to file. Creates a figures subdirectory if needed and saves the figure with specified settings. Parameters: directory ( Path ) \u2013 Base directory to save in filename ( str ) \u2013 Name for the figure file fig ( Figure ) \u2013 Matplotlib figure to save dpi ( int , default: 300 ) \u2013 Resolution in dots per inch. Defaults to 300. Source code in src/fdtdx/utils/logger.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def savefig ( self , directory : Path , filename : str , fig : Figure , dpi : int = 300 ): \"\"\"Save a matplotlib figure to file. Creates a figures subdirectory if needed and saves the figure with specified settings. Args: directory (Path): Base directory to save in filename (str): Name for the figure file fig (Figure): Matplotlib figure to save dpi (int, optional): Resolution in dots per inch. Defaults to 300. \"\"\" figure_directory = directory / \"figures\" figure_directory . mkdir ( parents = True , exist_ok = True ) fig . savefig ( directory / \"figures\" / filename , dpi = dpi , bbox_inches = \"tight\" ) plt . close ( fig )","title":"savefig"},{"location":"api/public/Logger/#fdtdx.Logger.write","text":"write ( stats : dict , do_print : bool = True ) Write statistics to CSV file and optionally print them. Records metrics in a CSV file and optionally displays them in a formatted table. Automatically initializes CSV headers on first write. Parameters: stats ( dict ) \u2013 Dictionary of statistics to record do_print ( bool , default: True ) \u2013 Whether to print stats to console. Defaults to true. Source code in src/fdtdx/utils/logger.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def write ( self , stats : dict , do_print : bool = True ): \"\"\"Write statistics to CSV file and optionally print them. Records metrics in a CSV file and optionally displays them in a formatted table. Automatically initializes CSV headers on first write. Args: stats (dict): Dictionary of statistics to record do_print (bool, optional): Whether to print stats to console. Defaults to true. \"\"\" stats = { k : v . item () if isinstance ( v , jax . Array ) else v for k , v in stats . items () if isinstance ( v , ( int , float )) or ( isinstance ( v , jax . Array ) and v . size == 1 ) } if self . fieldnames is None : self . fieldnames = list ( stats . keys ()) self . writer = csv . DictWriter ( self . csvfile , fieldnames = self . fieldnames ) self . writer . writeheader () assert self . writer is not None self . writer . writerow ( stats ) self . csvfile . flush () if do_print : table = Table ( box = None ) for k , v in stats . items (): table . add_column ( k ) table . add_column ( str ( v )) self . console . print ( table )","title":"write"},{"location":"api/public/Material/","text":"fdtdx.Material Bases: TreeClass Represents an electromagnetic material with specific electrical and magnetic properties. This class stores the fundamental electromagnetic properties of a material for use in electromagnetic simulations. Attributes: permittivity ( float ) \u2013 The relative permittivity (dielectric constant) of the material, which describes how the electric field is affected by the material. Higher values indicate greater electric polarization in response to an applied electric field. Defaults to 1.0. permeability ( float ) \u2013 The relative permeability of the material, which describes how the magnetic field is affected by the material. Higher values indicate greater magnetic response to an applied magnetic field. Defaults to 1.0 (non-magnetic material). electric_conductivity ( float ) \u2013 The electrical conductivity of the material in siemens per meter (S/m), which describes how easily electric current can flow through it. Higher values indicate materials that conduct electricity more easily. Defaults to 0.0 (perfect insulator). magnetic_conductivity ( float ) \u2013 The magnetic conductivity, or magnetic loss of the material. This is an artificial parameter for numerical applications and does not represent an actual physical unit, even though often described in Ohm/m. The naming can be misleading, because it does not actually describe a conductivity, but rather an \"equivalent magnetic loss parameter\". Defaults to 0.0.","title":"fdtdx.Material"},{"location":"api/public/Material/#fdtdxmaterial","text":"","title":"fdtdx.Material"},{"location":"api/public/Material/#fdtdx.Material","text":"Bases: TreeClass Represents an electromagnetic material with specific electrical and magnetic properties. This class stores the fundamental electromagnetic properties of a material for use in electromagnetic simulations. Attributes: permittivity ( float ) \u2013 The relative permittivity (dielectric constant) of the material, which describes how the electric field is affected by the material. Higher values indicate greater electric polarization in response to an applied electric field. Defaults to 1.0. permeability ( float ) \u2013 The relative permeability of the material, which describes how the magnetic field is affected by the material. Higher values indicate greater magnetic response to an applied magnetic field. Defaults to 1.0 (non-magnetic material). electric_conductivity ( float ) \u2013 The electrical conductivity of the material in siemens per meter (S/m), which describes how easily electric current can flow through it. Higher values indicate materials that conduct electricity more easily. Defaults to 0.0 (perfect insulator). magnetic_conductivity ( float ) \u2013 The magnetic conductivity, or magnetic loss of the material. This is an artificial parameter for numerical applications and does not represent an actual physical unit, even though often described in Ohm/m. The naming can be misleading, because it does not actually describe a conductivity, but rather an \"equivalent magnetic loss parameter\". Defaults to 0.0.","title":"Material"},{"location":"api/public/ModeOverlapDetector/","text":"fdtdx.ModeOverlapDetector Bases: PhasorDetector Detector for measuring the overlap of a waveguide mode with the simulation fields. This detector computes the overlap of a mode with the phasor fields at a specified frequency, enabling frequency-domain analysis of the electromagnetic fields. The mode overlap is calculated by integrating the cross product of the mode fields with the simulation fields over a cross-sectional plane. This is useful for analyzing waveguide coupling efficiency, transmission coefficients, and modal decomposition of electromagnetic fields. Attributes: direction ( Literal ['+', '-'] ) \u2013 Direction of mode propagation, either \"+\" (forward) or \"-\" (backward). Determines which direction along the waveguide axis the mode is assumed to propagate. mode_index ( int ) \u2013 Index of the waveguide mode to use for overlap calculation. Defaults to 0 (fundamental mode). Higher indices correspond to higher-order modes. filter_pol ( Literal ['te', 'tm'] | None ) \u2013 Optional polarization filter for the mode calculation. Can be \"te\" (transverse electric), \"tm\" (transverse magnetic), or None (no filtering). When specified, only modes of the given polarization type are considered. Defaults to None. components ( Sequence [ Literal ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']] ) \u2013 Cannot be specified here since the detector needs all components. plot ( bool ) \u2013 Cannot be specified here since plotting a single scalar is useless.","title":"fdtdx.ModeOverlapDetector"},{"location":"api/public/ModeOverlapDetector/#fdtdxmodeoverlapdetector","text":"","title":"fdtdx.ModeOverlapDetector"},{"location":"api/public/ModeOverlapDetector/#fdtdx.ModeOverlapDetector","text":"Bases: PhasorDetector Detector for measuring the overlap of a waveguide mode with the simulation fields. This detector computes the overlap of a mode with the phasor fields at a specified frequency, enabling frequency-domain analysis of the electromagnetic fields. The mode overlap is calculated by integrating the cross product of the mode fields with the simulation fields over a cross-sectional plane. This is useful for analyzing waveguide coupling efficiency, transmission coefficients, and modal decomposition of electromagnetic fields. Attributes: direction ( Literal ['+', '-'] ) \u2013 Direction of mode propagation, either \"+\" (forward) or \"-\" (backward). Determines which direction along the waveguide axis the mode is assumed to propagate. mode_index ( int ) \u2013 Index of the waveguide mode to use for overlap calculation. Defaults to 0 (fundamental mode). Higher indices correspond to higher-order modes. filter_pol ( Literal ['te', 'tm'] | None ) \u2013 Optional polarization filter for the mode calculation. Can be \"te\" (transverse electric), \"tm\" (transverse magnetic), or None (no filtering). When specified, only modes of the given polarization type are considered. Defaults to None. components ( Sequence [ Literal ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']] ) \u2013 Cannot be specified here since the detector needs all components. plot ( bool ) \u2013 Cannot be specified here since plotting a single scalar is useless.","title":"ModeOverlapDetector"},{"location":"api/public/ModePlaneSource/","text":"fdtdx.ModePlaneSource Bases: TFSFPlaneSource","title":"fdtdx.ModePlaneSource"},{"location":"api/public/ModePlaneSource/#fdtdxmodeplanesource","text":"","title":"fdtdx.ModePlaneSource"},{"location":"api/public/ModePlaneSource/#fdtdx.ModePlaneSource","text":"Bases: TFSFPlaneSource","title":"ModePlaneSource"},{"location":"api/public/ObjectContainer/","text":"fdtdx.ObjectContainer Bases: TreeClass Container for managing simulation objects and their relationships. This class provides a structured way to organize and access different types of simulation objects like sources, detectors, PML/periodic boundaries and devices. It maintains object lists and provides filtered access to specific object types. Attributes: object_list ( list [ SimulationObject ] ) \u2013 List of all simulation objects in the container. volume_idx ( int ) \u2013 Index of the volume object in the object list.","title":"fdtdx.ObjectContainer"},{"location":"api/public/ObjectContainer/#fdtdxobjectcontainer","text":"","title":"fdtdx.ObjectContainer"},{"location":"api/public/ObjectContainer/#fdtdx.ObjectContainer","text":"Bases: TreeClass Container for managing simulation objects and their relationships. This class provides a structured way to organize and access different types of simulation objects like sources, detectors, PML/periodic boundaries and devices. It maintains object lists and provides filtered access to specific object types. Attributes: object_list ( list [ SimulationObject ] ) \u2013 List of all simulation objects in the container. volume_idx ( int ) \u2013 Index of the volume object in the object list.","title":"ObjectContainer"},{"location":"api/public/ParameterTransformation/","text":"fdtdx.ParameterTransformation Bases: TreeClass , ABC","title":"fdtdx.ParameterTransformation"},{"location":"api/public/ParameterTransformation/#fdtdxparametertransformation","text":"","title":"fdtdx.ParameterTransformation"},{"location":"api/public/ParameterTransformation/#fdtdx.ParameterTransformation","text":"Bases: TreeClass , ABC","title":"ParameterTransformation"},{"location":"api/public/PerfectlyMatchedLayer/","text":"fdtdx.PerfectlyMatchedLayer Bases: BaseBoundary Implements a Convolutional Perfectly Matched Layer (CPML) boundary condition. The CPML absorbs outgoing electromagnetic waves with minimal reflection by using a complex coordinate stretching approach. This implementation supports arbitrary axis orientation and both positive/negative directions. Attributes: axis ( int ) \u2013 Principal axis for PML (0=x, 1=y, 2=z) direction ( Literal ['+', '-'] ) \u2013 Direction along axis (\"+\" or \"-\") alpha ( float ) \u2013 Loss parameter for complex frequency shifting. Defaults to 1e-8. kappa_start ( float ) \u2013 Initial kappa stretching coefficient. Defaults to 1.0. kappa_end ( float ) \u2013 Final kappa stretching coefficient. Defaults to 1.5. color ( tuple [ float , float , float ] | None ) \u2013 RGB color tuple for visualization. defualts to dark grey. descriptive_name property descriptive_name : str Gets a human-readable name describing this PML boundary's location. Returns: str ( str ) \u2013 Description like \"min_x\" or \"max_z\" indicating position thickness property thickness : int Gets the thickness of the PML layer in grid points. Returns: int ( int ) \u2013 Number of grid points in the PML along its axis","title":"fdtdx.PerfectlyMatchedLayer"},{"location":"api/public/PerfectlyMatchedLayer/#fdtdxperfectlymatchedlayer","text":"","title":"fdtdx.PerfectlyMatchedLayer"},{"location":"api/public/PerfectlyMatchedLayer/#fdtdx.PerfectlyMatchedLayer","text":"Bases: BaseBoundary Implements a Convolutional Perfectly Matched Layer (CPML) boundary condition. The CPML absorbs outgoing electromagnetic waves with minimal reflection by using a complex coordinate stretching approach. This implementation supports arbitrary axis orientation and both positive/negative directions. Attributes: axis ( int ) \u2013 Principal axis for PML (0=x, 1=y, 2=z) direction ( Literal ['+', '-'] ) \u2013 Direction along axis (\"+\" or \"-\") alpha ( float ) \u2013 Loss parameter for complex frequency shifting. Defaults to 1e-8. kappa_start ( float ) \u2013 Initial kappa stretching coefficient. Defaults to 1.0. kappa_end ( float ) \u2013 Final kappa stretching coefficient. Defaults to 1.5. color ( tuple [ float , float , float ] | None ) \u2013 RGB color tuple for visualization. defualts to dark grey.","title":"PerfectlyMatchedLayer"},{"location":"api/public/PerfectlyMatchedLayer/#fdtdx.PerfectlyMatchedLayer.descriptive_name","text":"descriptive_name : str Gets a human-readable name describing this PML boundary's location. Returns: str ( str ) \u2013 Description like \"min_x\" or \"max_z\" indicating position","title":"descriptive_name"},{"location":"api/public/PerfectlyMatchedLayer/#fdtdx.PerfectlyMatchedLayer.thickness","text":"thickness : int Gets the thickness of the PML layer in grid points. Returns: int ( int ) \u2013 Number of grid points in the PML along its axis","title":"thickness"},{"location":"api/public/PeriodicBoundary/","text":"fdtdx.PeriodicBoundary Bases: BaseBoundary Implements periodic boundary conditions. The periodic boundary connects opposite sides of the simulation domain, making waves that exit one side reenter from the opposite side. Attributes: axis ( int ) \u2013 Principal axis for periodicity (0=x, 1=y, 2=z) direction ( Literal ['+', '-'] ) \u2013 Direction along axis (\"+\" or \"-\") color ( tuple [ float , float , float ] | None ) \u2013 RGB color tuple for visualization. Defaults to light blue. descriptive_name property descriptive_name : str Gets a human-readable name describing this periodic boundary's location. Returns: str ( str ) \u2013 Description like \"min_x\" or \"max_z\" indicating position thickness property thickness : int Gets the thickness of the periodic boundary layer in grid points. Returns: int ( int ) \u2013 Number of grid points in the boundary layer (always 1 for periodic)","title":"fdtdx.PeriodicBoundary"},{"location":"api/public/PeriodicBoundary/#fdtdxperiodicboundary","text":"","title":"fdtdx.PeriodicBoundary"},{"location":"api/public/PeriodicBoundary/#fdtdx.PeriodicBoundary","text":"Bases: BaseBoundary Implements periodic boundary conditions. The periodic boundary connects opposite sides of the simulation domain, making waves that exit one side reenter from the opposite side. Attributes: axis ( int ) \u2013 Principal axis for periodicity (0=x, 1=y, 2=z) direction ( Literal ['+', '-'] ) \u2013 Direction along axis (\"+\" or \"-\") color ( tuple [ float , float , float ] | None ) \u2013 RGB color tuple for visualization. Defaults to light blue.","title":"PeriodicBoundary"},{"location":"api/public/PeriodicBoundary/#fdtdx.PeriodicBoundary.descriptive_name","text":"descriptive_name : str Gets a human-readable name describing this periodic boundary's location. Returns: str ( str ) \u2013 Description like \"min_x\" or \"max_z\" indicating position","title":"descriptive_name"},{"location":"api/public/PeriodicBoundary/#fdtdx.PeriodicBoundary.thickness","text":"thickness : int Gets the thickness of the periodic boundary layer in grid points. Returns: int ( int ) \u2013 Number of grid points in the boundary layer (always 1 for periodic)","title":"thickness"},{"location":"api/public/PhasorDetector/","text":"fdtdx.PhasorDetector Bases: Detector Detector for measuring frequency components of electromagnetic fields using an efficient Phasor Implementation. This detector computes complex phasor representations of the field components at specified frequencies, enabling frequency-domain analysis of the electromagnetic fields. The amplitude and phase of the original phase can be reconstructed using jnp.abs(phasor) and jnp.angle(phasor). The reconstruction itself can then be achieved using amplitude * jnp.cos(2 * jnp.pi * freq * t + phase). Attributes: wave_characters ( Sequence [ WaveCharacter ] ) \u2013 WaveCharacters to analyze. reduce_volume ( bool ) \u2013 If True, reduces the volume of recorded data. Defaults to False. components ( Sequence [ Literal ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']] ) \u2013 Sequence of field components to measure. Can include any of: \"Ex\", \"Ey\", \"Ez\", \"Hx\", \"Hy\", \"Hz\". dtype ( dtype ) \u2013 data type of the saved fields. Defaults to jnp.complex64 plot ( bool ) \u2013 Wether to plot the measured data. Defaults to False.","title":"fdtdx.PhasorDetector"},{"location":"api/public/PhasorDetector/#fdtdxphasordetector","text":"","title":"fdtdx.PhasorDetector"},{"location":"api/public/PhasorDetector/#fdtdx.PhasorDetector","text":"Bases: Detector Detector for measuring frequency components of electromagnetic fields using an efficient Phasor Implementation. This detector computes complex phasor representations of the field components at specified frequencies, enabling frequency-domain analysis of the electromagnetic fields. The amplitude and phase of the original phase can be reconstructed using jnp.abs(phasor) and jnp.angle(phasor). The reconstruction itself can then be achieved using amplitude * jnp.cos(2 * jnp.pi * freq * t + phase). Attributes: wave_characters ( Sequence [ WaveCharacter ] ) \u2013 WaveCharacters to analyze. reduce_volume ( bool ) \u2013 If True, reduces the volume of recorded data. Defaults to False. components ( Sequence [ Literal ['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']] ) \u2013 Sequence of field components to measure. Can include any of: \"Ex\", \"Ey\", \"Ez\", \"Hx\", \"Hy\", \"Hz\". dtype ( dtype ) \u2013 data type of the saved fields. Defaults to jnp.complex64 plot ( bool ) \u2013 Wether to plot the measured data. Defaults to False.","title":"PhasorDetector"},{"location":"api/public/PillarDiscretization/","text":"fdtdx.PillarDiscretization Bases: ParameterTransformation Constraint module for mapping pillar structures to allowed configurations. Maps arbitrary pillar structures to the nearest allowed configurations based on material constraints and geometry requirements. Ensures structures meet fabrication rules like single polymer columns and no trapped air holes. Attributes: axis ( int ) \u2013 Axis along which to enforce pillar constraints (0=x, 1=y, 2=z). single_polymer_columns ( bool ) \u2013 If True, restrict to single polymer columns. distance_metric ( Literal ['euclidean', 'permittivity_differences_plus_average_permittivity'] ) \u2013 Method to compute distances between material distributions: - \"euclidean\": Standard Euclidean distance between permittivity values. - \"permittivity_differences_plus_average_permittivity\": Weighted combination of permittivity differences and average permittivity values, optimized for material distribution comparisons. Defaults to \"permittivity_differences_plus_average_permittivity\". background_material ( str | None ) \u2013 Name of the background material in the materials dictionary of the corresponding device. If None, the material with lowest permittivity is used. Defaults to None.","title":"fdtdx.PillarDiscretization"},{"location":"api/public/PillarDiscretization/#fdtdxpillardiscretization","text":"","title":"fdtdx.PillarDiscretization"},{"location":"api/public/PillarDiscretization/#fdtdx.PillarDiscretization","text":"Bases: ParameterTransformation Constraint module for mapping pillar structures to allowed configurations. Maps arbitrary pillar structures to the nearest allowed configurations based on material constraints and geometry requirements. Ensures structures meet fabrication rules like single polymer columns and no trapped air holes. Attributes: axis ( int ) \u2013 Axis along which to enforce pillar constraints (0=x, 1=y, 2=z). single_polymer_columns ( bool ) \u2013 If True, restrict to single polymer columns. distance_metric ( Literal ['euclidean', 'permittivity_differences_plus_average_permittivity'] ) \u2013 Method to compute distances between material distributions: - \"euclidean\": Standard Euclidean distance between permittivity values. - \"permittivity_differences_plus_average_permittivity\": Weighted combination of permittivity differences and average permittivity values, optimized for material distribution comparisons. Defaults to \"permittivity_differences_plus_average_permittivity\". background_material ( str | None ) \u2013 Name of the background material in the materials dictionary of the corresponding device. If None, the material with lowest permittivity is used. Defaults to None.","title":"PillarDiscretization"},{"location":"api/public/PositionConstraint/","text":"fdtdx.PositionConstraint dataclass PositionConstraint ( * , object : SimulationObject , other_object : SimulationObject , axes : tuple [ int , ... ], object_positions : tuple [ float , ... ], other_object_positions : tuple [ float , ... ], margins : tuple [ float , ... ], grid_margins : tuple [ int , ... ] ) Defines a positional relationship between two simulation objects. A constraint that positions one object relative to another, with optional margins and offsets. Used to specify how objects should be placed in the simulation volume relative to each other. Attributes: object ( SimulationObject ) \u2013 The \"child\" object whose position is being adjusted other_object ( SimulationObject ) \u2013 The \"parent\" object that serves as reference axes ( tuple [ int , ...] ) \u2013 Which axes (x,y,z) this constraint applies to object_positions ( tuple [ float , ...] ) \u2013 Relative positions on child object (-1 to 1) other_object_positions ( tuple [ float , ...] ) \u2013 Relative positions on parent object (-1 to 1) margins ( tuple [ float , ...] ) \u2013 Optional real-space margins between objects grid_margins ( tuple [ int , ...] ) \u2013 Optional grid-space margins between objects","title":"fdtdx.PositionConstraint"},{"location":"api/public/PositionConstraint/#fdtdxpositionconstraint","text":"","title":"fdtdx.PositionConstraint"},{"location":"api/public/PositionConstraint/#fdtdx.PositionConstraint","text":"PositionConstraint ( * , object : SimulationObject , other_object : SimulationObject , axes : tuple [ int , ... ], object_positions : tuple [ float , ... ], other_object_positions : tuple [ float , ... ], margins : tuple [ float , ... ], grid_margins : tuple [ int , ... ] ) Defines a positional relationship between two simulation objects. A constraint that positions one object relative to another, with optional margins and offsets. Used to specify how objects should be placed in the simulation volume relative to each other. Attributes: object ( SimulationObject ) \u2013 The \"child\" object whose position is being adjusted other_object ( SimulationObject ) \u2013 The \"parent\" object that serves as reference axes ( tuple [ int , ...] ) \u2013 Which axes (x,y,z) this constraint applies to object_positions ( tuple [ float , ...] ) \u2013 Relative positions on child object (-1 to 1) other_object_positions ( tuple [ float , ...] ) \u2013 Relative positions on parent object (-1 to 1) margins ( tuple [ float , ...] ) \u2013 Optional real-space margins between objects grid_margins ( tuple [ int , ...] ) \u2013 Optional grid-space margins between objects","title":"PositionConstraint"},{"location":"api/public/PoyntingFluxDetector/","text":"fdtdx.PoyntingFluxDetector Bases: Detector Detector for measuring Poynting flux in electromagnetic simulations. This detector computes the Poynting flux (power flow) through a specified surface in the simulation volume. It can measure flux in either positive or negative direction along the propagation axis, and optionally reduce measurements to a single value by summing over the detection surface. Attributes: direction ( Literal ['+', '-'] ) \u2013 Direction of flux measurement, either \"+\" for positive or \"-\" for negative along the propagation axis. reduce_volume ( bool ) \u2013 If True, reduces measurements to a single value by summing over the detection surface. If False, maintains spatial distribution. Defaults to True. fixed_propagation_axis ( int | None ) \u2013 By default, the propagation axis for calculating the poynting flux is the axis, where the detector has a grid shape of 1. If the detector has a shape of 1 in more than one axes or a different axis should be used, then this attribute can/has to be set. Defaults to None. keep_all_components ( bool ) \u2013 By default, only the poynting flux component for the propagation axis is returned (scalar). If true, all three vector components are returned. Defaults to False. propagation_axis property propagation_axis : int Determines the axis along which Poynting flux is measured. The propagation axis is identified as the dimension with size 1 in the detector's grid shape, representing a plane perpendicular to the flux measurement direction. Returns: int ( int ) \u2013 Index of the propagation axis (0 for x, 1 for y, 2 for z) Raises: Exception \u2013 If detector shape does not have exactly one dimension of size 1","title":"fdtdx.PoyntingFluxDetector"},{"location":"api/public/PoyntingFluxDetector/#fdtdxpoyntingfluxdetector","text":"","title":"fdtdx.PoyntingFluxDetector"},{"location":"api/public/PoyntingFluxDetector/#fdtdx.PoyntingFluxDetector","text":"Bases: Detector Detector for measuring Poynting flux in electromagnetic simulations. This detector computes the Poynting flux (power flow) through a specified surface in the simulation volume. It can measure flux in either positive or negative direction along the propagation axis, and optionally reduce measurements to a single value by summing over the detection surface. Attributes: direction ( Literal ['+', '-'] ) \u2013 Direction of flux measurement, either \"+\" for positive or \"-\" for negative along the propagation axis. reduce_volume ( bool ) \u2013 If True, reduces measurements to a single value by summing over the detection surface. If False, maintains spatial distribution. Defaults to True. fixed_propagation_axis ( int | None ) \u2013 By default, the propagation axis for calculating the poynting flux is the axis, where the detector has a grid shape of 1. If the detector has a shape of 1 in more than one axes or a different axis should be used, then this attribute can/has to be set. Defaults to None. keep_all_components ( bool ) \u2013 By default, only the poynting flux component for the propagation axis is returned (scalar). If true, all three vector components are returned. Defaults to False.","title":"PoyntingFluxDetector"},{"location":"api/public/PoyntingFluxDetector/#fdtdx.PoyntingFluxDetector.propagation_axis","text":"propagation_axis : int Determines the axis along which Poynting flux is measured. The propagation axis is identified as the dimension with size 1 in the detector's grid shape, representing a plane perpendicular to the flux measurement direction. Returns: int ( int ) \u2013 Index of the propagation axis (0 for x, 1 for y, 2 for z) Raises: Exception \u2013 If detector shape does not have exactly one dimension of size 1","title":"propagation_axis"},{"location":"api/public/RealCoordinateConstraint/","text":"fdtdx.RealCoordinateConstraint dataclass RealCoordinateConstraint ( * , object : SimulationObject , axes : tuple [ int , ... ], sides : tuple [ Literal [ \"+\" , \"-\" ], ... ], coordinates : tuple [ float , ... ] ) Constrains an object's position to specific real-space coordinates. Forces specific sides of an object to align with given real-space coordinates. Used for precise positioning in physical units. Attributes: object ( SimulationObject ) \u2013 The object to position axes ( tuple [ int , ...] ) \u2013 Which axes to constrain sides ( tuple [ Literal ['+', '-'], ...] ) \u2013 Which side of each axis ('+' or '-') coordinates ( tuple [ float , ...] ) \u2013 Real-space coordinates to align with","title":"fdtdx.RealCoordinateConstraint"},{"location":"api/public/RealCoordinateConstraint/#fdtdxrealcoordinateconstraint","text":"","title":"fdtdx.RealCoordinateConstraint"},{"location":"api/public/RealCoordinateConstraint/#fdtdx.RealCoordinateConstraint","text":"RealCoordinateConstraint ( * , object : SimulationObject , axes : tuple [ int , ... ], sides : tuple [ Literal [ \"+\" , \"-\" ], ... ], coordinates : tuple [ float , ... ] ) Constrains an object's position to specific real-space coordinates. Forces specific sides of an object to align with given real-space coordinates. Used for precise positioning in physical units. Attributes: object ( SimulationObject ) \u2013 The object to position axes ( tuple [ int , ...] ) \u2013 Which axes to constrain sides ( tuple [ Literal ['+', '-'], ...] ) \u2013 Which side of each axis ('+' or '-') coordinates ( tuple [ float , ...] ) \u2013 Real-space coordinates to align with","title":"RealCoordinateConstraint"},{"location":"api/public/Recorder/","text":"fdtdx.Recorder Bases: TreeClass Records and compresses simulation data over time using a sequence of processing modules. The Recorder manages a pipeline of modules that process simulation data at each timestep. It supports both compression modules that reduce data size and time filters that control when data is recorded. The recorder handles initialization, compression and decompression of simulation data through its module pipeline. Attributes: modules ( Sequence [ CompressionModule | TimeStepFilter ] ) \u2013 Sequence of processing modules to apply to the simulation data. Can be either CompressionModule for data reduction or TimeStepFilter for controlling recording frequency.","title":"fdtdx.Recorder"},{"location":"api/public/Recorder/#fdtdxrecorder","text":"","title":"fdtdx.Recorder"},{"location":"api/public/Recorder/#fdtdx.Recorder","text":"Bases: TreeClass Records and compresses simulation data over time using a sequence of processing modules. The Recorder manages a pipeline of modules that process simulation data at each timestep. It supports both compression modules that reduce data size and time filters that control when data is recorded. The recorder handles initialization, compression and decompression of simulation data through its module pipeline. Attributes: modules ( Sequence [ CompressionModule | TimeStepFilter ] ) \u2013 Sequence of processing modules to apply to the simulation data. Can be either CompressionModule for data reduction or TimeStepFilter for controlling recording frequency.","title":"Recorder"},{"location":"api/public/RecordingState/","text":"fdtdx.RecordingState Bases: TreeClass Container for simulation recording state data. Holds field data and state information for FDTD simulations. Attributes: data ( dict [ str , Array ] ) \u2013 Dictionary mapping field names to their array values. state ( dict [ str , Array ] ) \u2013 Dictionary mapping state variable names to their array values.","title":"fdtdx.RecordingState"},{"location":"api/public/RecordingState/#fdtdxrecordingstate","text":"","title":"fdtdx.RecordingState"},{"location":"api/public/RecordingState/#fdtdx.RecordingState","text":"Bases: TreeClass Container for simulation recording state data. Holds field data and state information for FDTD simulations. Attributes: data ( dict [ str , Array ] ) \u2013 Dictionary mapping field names to their array values. state ( dict [ str , Array ] ) \u2013 Dictionary mapping state variable names to their array values.","title":"RecordingState"},{"location":"api/public/RemoveFloatingMaterial/","text":"fdtdx.RemoveFloatingMaterial Bases: SameShapeTypeParameterTransform Finds all material that floats in the air and sets their permittivity to air. This constraint module identifies regions of material that are not connected to any substrate or boundary and converts them to air. This helps ensure physically realizable designs by eliminating floating/disconnected material regions. The module only works with binary material systems (2 permittivities) where one material represents air. Attributes: background_material ( str | None ) \u2013 Name of the background material. If none, the material with the lowest permittivity is used. Defaults to None.","title":"fdtdx.RemoveFloatingMaterial"},{"location":"api/public/RemoveFloatingMaterial/#fdtdxremovefloatingmaterial","text":"","title":"fdtdx.RemoveFloatingMaterial"},{"location":"api/public/RemoveFloatingMaterial/#fdtdx.RemoveFloatingMaterial","text":"Bases: SameShapeTypeParameterTransform Finds all material that floats in the air and sets their permittivity to air. This constraint module identifies regions of material that are not connected to any substrate or boundary and converts them to air. This helps ensure physically realizable designs by eliminating floating/disconnected material regions. The module only works with binary material systems (2 permittivities) where one material represents air. Attributes: background_material ( str | None ) \u2013 Name of the background material. If none, the material with the lowest permittivity is used. Defaults to None.","title":"RemoveFloatingMaterial"},{"location":"api/public/SimulationConfig/","text":"fdtdx.SimulationConfig Bases: TreeClass Configuration settings for FDTD simulations. This class contains all the parameters needed to configure and run an FDTD simulation, including spatial and temporal discretization, hardware backend, and gradient computation settings. Attributes: time ( float ) \u2013 Total simulation time in seconds. resolution ( float ) \u2013 Spatial resolution of the simulation grid in meters. backend ( BackendOption ) \u2013 Computation backend ('gpu', 'tpu', 'cpu' or 'METAL'). Defaults to \"gpu\". dtype ( dtype ) \u2013 Data type for numerical computations. Defaults to jnp.float32. courant_factor ( float ) \u2013 Safety factor for the Courant condition (default: 0.99). gradient_config ( GradientConfig | None ) \u2013 Optional configuration for gradient computation. courant_number property courant_number : float Calculate the Courant number for the simulation. The Courant number is a dimensionless quantity that determines stability of the FDTD simulation. It represents the ratio of the physical propagation speed to the numerical propagation speed. Returns: float ( float ) \u2013 The Courant number, scaled by the courant_factor and normalized for 3D simulations. invertible_optimization property invertible_optimization : bool Check if invertible optimization is enabled. Invertible optimization uses time-reversibility of Maxwell's equations to compute gradients with reduced memory requirements compared to checkpointing-based methods. Returns: bool ( bool ) \u2013 True if gradient computation uses invertible differentiation (recorder is specified), False otherwise. max_travel_distance property max_travel_distance : float Calculate the maximum distance light can travel during the simulation. This represents the theoretical maximum distance that light could travel through the simulation volume, useful for determining if the simulation time is sufficient for light to traverse the entire domain. Returns: float ( float ) \u2013 Maximum travel distance in meters, based on the speed of light and total simulation time. only_forward property only_forward : bool Check if the simulation is forward-only (no gradient computation). Forward-only simulations don't compute gradients and are used when only the forward propagation of electromagnetic fields is needed, without optimization. Returns: bool ( bool ) \u2013 True if no gradient configuration is specified, False otherwise. time_step_duration property time_step_duration : float Calculate the duration of a single time step. The time step duration is determined by the Courant condition to ensure numerical stability. It depends on the spatial resolution and the speed of light. Returns: float ( float ) \u2013 Time step duration in seconds, calculated using the Courant condition and spatial resolution. time_steps_total property time_steps_total : int Calculate the total number of time steps for the simulation. Determines how many discrete time steps are needed to simulate the specified total simulation time, based on the time step duration. Returns: int ( int ) \u2013 Total number of time steps needed to reach the specified simulation time.","title":"fdtdx.SimulationConfig"},{"location":"api/public/SimulationConfig/#fdtdxsimulationconfig","text":"","title":"fdtdx.SimulationConfig"},{"location":"api/public/SimulationConfig/#fdtdx.SimulationConfig","text":"Bases: TreeClass Configuration settings for FDTD simulations. This class contains all the parameters needed to configure and run an FDTD simulation, including spatial and temporal discretization, hardware backend, and gradient computation settings. Attributes: time ( float ) \u2013 Total simulation time in seconds. resolution ( float ) \u2013 Spatial resolution of the simulation grid in meters. backend ( BackendOption ) \u2013 Computation backend ('gpu', 'tpu', 'cpu' or 'METAL'). Defaults to \"gpu\". dtype ( dtype ) \u2013 Data type for numerical computations. Defaults to jnp.float32. courant_factor ( float ) \u2013 Safety factor for the Courant condition (default: 0.99). gradient_config ( GradientConfig | None ) \u2013 Optional configuration for gradient computation.","title":"SimulationConfig"},{"location":"api/public/SimulationConfig/#fdtdx.SimulationConfig.courant_number","text":"courant_number : float Calculate the Courant number for the simulation. The Courant number is a dimensionless quantity that determines stability of the FDTD simulation. It represents the ratio of the physical propagation speed to the numerical propagation speed. Returns: float ( float ) \u2013 The Courant number, scaled by the courant_factor and normalized for 3D simulations.","title":"courant_number"},{"location":"api/public/SimulationConfig/#fdtdx.SimulationConfig.invertible_optimization","text":"invertible_optimization : bool Check if invertible optimization is enabled. Invertible optimization uses time-reversibility of Maxwell's equations to compute gradients with reduced memory requirements compared to checkpointing-based methods. Returns: bool ( bool ) \u2013 True if gradient computation uses invertible differentiation (recorder is specified), False otherwise.","title":"invertible_optimization"},{"location":"api/public/SimulationConfig/#fdtdx.SimulationConfig.max_travel_distance","text":"max_travel_distance : float Calculate the maximum distance light can travel during the simulation. This represents the theoretical maximum distance that light could travel through the simulation volume, useful for determining if the simulation time is sufficient for light to traverse the entire domain. Returns: float ( float ) \u2013 Maximum travel distance in meters, based on the speed of light and total simulation time.","title":"max_travel_distance"},{"location":"api/public/SimulationConfig/#fdtdx.SimulationConfig.only_forward","text":"only_forward : bool Check if the simulation is forward-only (no gradient computation). Forward-only simulations don't compute gradients and are used when only the forward propagation of electromagnetic fields is needed, without optimization. Returns: bool ( bool ) \u2013 True if no gradient configuration is specified, False otherwise.","title":"only_forward"},{"location":"api/public/SimulationConfig/#fdtdx.SimulationConfig.time_step_duration","text":"time_step_duration : float Calculate the duration of a single time step. The time step duration is determined by the Courant condition to ensure numerical stability. It depends on the spatial resolution and the speed of light. Returns: float ( float ) \u2013 Time step duration in seconds, calculated using the Courant condition and spatial resolution.","title":"time_step_duration"},{"location":"api/public/SimulationConfig/#fdtdx.SimulationConfig.time_steps_total","text":"time_steps_total : int Calculate the total number of time steps for the simulation. Determines how many discrete time steps are needed to simulate the specified total simulation time, based on the time step duration. Returns: int ( int ) \u2013 Total number of time steps needed to reach the specified simulation time.","title":"time_steps_total"},{"location":"api/public/SimulationObject/","text":"fdtdx.SimulationObject Bases: TreeClass , ABC Abstract base class for objects in a 3D simulation environment. This class provides the foundation for simulation objects with spatial properties and positioning capabilities in both real and grid coordinate systems. It supports random positioning offsets. Attributes: partial_real_shape ( PartialRealShape3D ) \u2013 The object's shape in real-world coordinates. Defaults to UNDEFINED_SHAPE_3D if not specified. partial_grid_shape ( PartialGridShape3D ) \u2013 The object's shape in grid coordinates. Defaults to UNDEFINED_SHAPE_3D if not specified. color ( tuple [ float , float , float ] | None ) \u2013 RGB color values for the object, where each component is in the interval [0, 1]. None indicates no color is specified. Defaults to None. name ( str ) \u2013 Unique identifier for the object. Automatically enforced to be unique through the UniqueName validator. The user can also set a name manually. max_random_real_offsets ( tuple [ float , float , float ] ) \u2013 Maximum random offset values that can be applied to the object's position in real coordinates for each axis (x, y, z). Defaults to (0, 0, 0) for no random offset. max_random_grid_offsets ( tuple [ int , int , int ] ) \u2013 Maximum random offset values that can be applied to the object's position in grid coordinates for each axis (x, y, z). Defaults to (0, 0, 0) for no random offset. Note This is an abstract base class and cannot be instantiated directly. extend_to extend_to ( other : SimulationObject | None , axis : int , direction : Literal [ \"+\" , \"-\" ], other_position : float | None = None , offset : float = 0 , grid_offset : int = 0 , ) -> SizeExtensionConstraint Creates a SizeExtensionConstraint that extends this object along a specified axis until it reaches another object or the simulation boundary. The extension can be in either positive or negative direction. Parameters: other ( SimulationObject | None ) \u2013 Target object to extend to, or None to extend to simulation boundary axis ( int ) \u2013 Which axis to extend along (0, 1, or 2) direction ( Literal ['+', '-'] ) \u2013 Direction to extend in ('+' or '-') other_position ( float | None , default: None ) \u2013 Relative position on target object (-1 to 1) to extend to. If None, defaults to the corresponding side (-1 for '+' direction, 1 for '-' direction). Defaults to None. offset ( float , default: 0 ) \u2013 Additional offset in meters to apply after extension. Ignored when extending to simulation boundary. Defaults to zero. grid_offset ( int , default: 0 ) \u2013 Additional offset in Yee-grid voxels to apply after extension. Ignored when extending to simulation boundary. Defaults to zero. Returns: SizeExtensionConstraint ( SizeExtensionConstraint ) \u2013 Constraint defining how the object extends Source code in src/fdtdx/objects/object.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 def extend_to ( self , other : \"SimulationObject | None\" , axis : int , direction : Literal [ \"+\" , \"-\" ], other_position : float | None = None , offset : float = 0 , grid_offset : int = 0 , ) -> SizeExtensionConstraint : \"\"\"Creates a SizeExtensionConstraint that extends this object along a specified axis until it reaches another object or the simulation boundary. The extension can be in either positive or negative direction. Args: other (SimulationObject | None): Target object to extend to, or None to extend to simulation boundary axis (int): Which axis to extend along (0, 1, or 2) direction (Literal[\"+\", \"-\"]): Direction to extend in ('+' or '-') other_position (float | None, optional): Relative position on target object (-1 to 1) to extend to. If None, defaults to the corresponding side (-1 for '+' direction, 1 for '-' direction). Defaults to None. offset (float, optional): Additional offset in meters to apply after extension. Ignored when extending to simulation boundary. Defaults to zero. grid_offset (int, optional): Additional offset in Yee-grid voxels to apply after extension. Ignored when extending to simulation boundary. Defaults to zero. Returns: SizeExtensionConstraint: Constraint defining how the object extends \"\"\" # default: extend to corresponding side if other_position is None : other_position = - 1 if direction == \"+\" else 1 if other is None : if offset != 0 or grid_offset != 0 : raise Exception ( \"Cannot use offset when extending object to infinity\" ) return SizeExtensionConstraint ( object = self , other_object = other , axis = axis , direction = direction , other_position = other_position , offset = offset , grid_offset = grid_offset , ) face_to_face_negative_direction face_to_face_negative_direction ( other : SimulationObject , axes : tuple [ int , ... ] | int , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint Creates a PositionConstraint that places this object facing another object in the negative direction of specified axes. The objects will touch at their facing boundaries unless margins are specified. Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene axes ( tuple [ int , ...] | int ) \u2013 Either a single integer or a tuple describing which axes to align on margins ( tuple [ float , ...] | float | None , default: None ) \u2013 Additional margins in meters between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None. grid_margins ( tuple [ int , ...] | int | None , default: None ) \u2013 Additional margins in Yee-grid voxels between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None. Returns: PositionConstraint ( PositionConstraint ) \u2013 Position constraint aligning objects face-to-face in negative direction Source code in src/fdtdx/objects/object.py 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 def face_to_face_negative_direction ( self , other : \"SimulationObject\" , axes : tuple [ int , ... ] | int , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint : \"\"\"Creates a PositionConstraint that places this object facing another object in the negative direction of specified axes. The objects will touch at their facing boundaries unless margins are specified. Args: other (SimulationObject): Another object in the simulation scene axes (tuple[int, ...] | int): Either a single integer or a tuple describing which axes to align on margins (tuple[float, ...] | float | None, optional): Additional margins in meters between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None. grid_margins (tuple[int, ...] | int | None, optional): Additional margins in Yee-grid voxels between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None. Returns: PositionConstraint: Position constraint aligning objects face-to-face in negative direction \"\"\" if isinstance ( axes , int ): axes = ( axes ,) own_positions = tuple ([ 1 for _ in axes ]) other_positions = tuple ([ - 1 for _ in axes ]) constraint = self . place_relative_to ( other = other , axes = axes , own_positions = own_positions , other_positions = other_positions , margins = margins , grid_margins = grid_margins , ) return constraint face_to_face_positive_direction face_to_face_positive_direction ( other : SimulationObject , axes : tuple [ int , ... ] | int , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint Creates a PositionConstraint that places this object facing another object in the positive direction of specified axes. The objects will touch at their facing boundaries unless margins are specified. Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene axes ( tuple [ int , ...] | int ) \u2013 Either a single integer or a tuple describing which axes to align on margins ( tuple [ float , ...] | float | None , default: None ) \u2013 Additional margins in meters between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None. grid_margins ( tuple [ int , ...] | int | None , default: None ) \u2013 Additional margins in Yee-grid voxels between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None Returns: PositionConstraint ( PositionConstraint ) \u2013 Position constraint aligning objects face-to-face in positive direction Source code in src/fdtdx/objects/object.py 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 def face_to_face_positive_direction ( self , other : \"SimulationObject\" , axes : tuple [ int , ... ] | int , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint : \"\"\"Creates a PositionConstraint that places this object facing another object in the positive direction of specified axes. The objects will touch at their facing boundaries unless margins are specified. Args: other (SimulationObject): Another object in the simulation scene axes (tuple[int, ...] | int): Either a single integer or a tuple describing which axes to align on margins (tuple[float, ...] | float | None, optional): Additional margins in meters between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None. grid_margins (tuple[int, ...] | int | None, optional): Additional margins in Yee-grid voxels between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None Returns: PositionConstraint: Position constraint aligning objects face-to-face in positive direction \"\"\" if isinstance ( axes , int ): axes = ( axes ,) own_positions = tuple ([ - 1 for _ in axes ]) other_positions = tuple ([ 1 for _ in axes ]) constraint = self . place_relative_to ( other = other , axes = axes , own_positions = own_positions , other_positions = other_positions , margins = margins , grid_margins = grid_margins , ) return constraint place_above place_above ( other : SimulationObject , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint Creates a PositionConstraint that places this object above another object along the z-axis. This is a convenience wrapper around face_to_face_positive_direction() for axis 2 (z-axis). Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene margins ( tuple [ float , ...] | float | None , default: None ) \u2013 Additional vertical margins in meters between objects. If None, no margin is used. Defaults to None. grid_margins ( tuple [ int , ...] | int | None , default: None ) \u2013 Additional vertical margins in Yee-grid voxels between objects. If None, no margin is used. Defaults to None. Returns: PositionConstraint ( PositionConstraint ) \u2013 Position constraint placing this object above the other Source code in src/fdtdx/objects/object.py 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 def place_above ( self , other : \"SimulationObject\" , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint : \"\"\"Creates a PositionConstraint that places this object above another object along the z-axis. This is a convenience wrapper around face_to_face_positive_direction() for axis 2 (z-axis). Args: other (SimulationObject): Another object in the simulation scene margins (tuple[float, ...] | float | None, optional): Additional vertical margins in meters between objects. If None, no margin is used. Defaults to None. grid_margins (tuple[int, ...] | int | None, optional): Additional vertical margins in Yee-grid voxels between objects. If None, no margin is used. Defaults to None. Returns: PositionConstraint: Position constraint placing this object above the other \"\"\" constraint = self . face_to_face_positive_direction ( other = other , axes = ( 2 ,), margins = margins , grid_margins = grid_margins , ) return constraint place_at_center place_at_center ( other : SimulationObject , axes : tuple [ int , ... ] | int = ( 0 , 1 , 2 ), own_positions : tuple [ float , ... ] | float | None = None , other_positions : ( tuple [ float , ... ] | float | None ) = None , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint Creates a PositionConstraint that centers this object relative to another object along specified axes. This is a convenience wrapper around place_relative_to() with default positions at the center (0). Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene axes ( tuple [ int , ...] | int , default: (0, 1, 2) ) \u2013 Either a single integer or a tuple describing which axes to center on. Defaults to all axes (0, 1, 2). own_positions ( tuple [ float , ...] | float | None , default: None ) \u2013 Relative positions on this object (-1 to 1). If None, uses center (0). Defaults to None. other_positions ( tuple [ float , ...] | float | None , default: None ) \u2013 Relative positions on other object (-1 to 1). If None, uses center (0). Defaults to None. margins ( tuple [ float , ...] | float | None , default: None ) \u2013 Additional margins in meters between objects. Must have same length as axes. If None, no margin is used. Defaults to None. grid_margins ( tuple[int, ...] | int | None , default: None ) \u2013 Additional margins in Yee-grid voxels between objects. Must have same length as axes. If None, no margin is used. Defaults to None. Returns: PositionConstraint ( PositionConstraint ) \u2013 Position constraint centering objects relative to each other Source code in src/fdtdx/objects/object.py 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 def place_at_center ( self , other : \"SimulationObject\" , axes : tuple [ int , ... ] | int = ( 0 , 1 , 2 ), own_positions : tuple [ float , ... ] | float | None = None , other_positions : tuple [ float , ... ] | float | None = None , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint : \"\"\"Creates a PositionConstraint that centers this object relative to another object along specified axes. This is a convenience wrapper around place_relative_to() with default positions at the center (0). Args: other (SimulationObject): Another object in the simulation scene axes (tuple[int, ...] | int, optional): Either a single integer or a tuple describing which axes to center on. Defaults to all axes (0, 1, 2). own_positions (tuple[float, ...] | float | None, optional): Relative positions on this object (-1 to 1). If None, uses center (0). Defaults to None. other_positions (tuple[float, ...] | float | None, optional): Relative positions on other object (-1 to 1). If None, uses center (0). Defaults to None. margins (tuple[float, ...] | float | None, optional): Additional margins in meters between objects. Must have same length as axes. If None, no margin is used. Defaults to None. grid_margins ( tuple[int, ...] | int | None, optional): Additional margins in Yee-grid voxels between objects. Must have same length as axes. If None, no margin is used. Defaults to None. Returns: PositionConstraint: Position constraint centering objects relative to each other \"\"\" if isinstance ( axes , int ): axes = ( axes ,) if own_positions is None : own_positions = tuple ([ 0 for _ in axes ]) if other_positions is None : other_positions = tuple ([ 0 for _ in axes ]) constraint = self . place_relative_to ( other = other , axes = axes , own_positions = own_positions , other_positions = other_positions , margins = margins , grid_margins = grid_margins , ) return constraint place_below place_below ( other : SimulationObject , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint Creates a PositionConstraint that places this object below another object along the z-axis. This is a convenience wrapper around face_to_face_negative_direction() for axis 2 (z-axis). Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene margins ( tuple [ float , ...] | float | None , default: None ) \u2013 Additional vertical margins in meters between objects. If None, no margin is used. Defaults to None. grid_margins ( tuple [ int , ...] | int | None , default: None ) \u2013 Additional vertical margins in Yee-grid voxels between objects. If None, no margin is used. Defaults to None. Returns: PositionConstraint ( PositionConstraint ) \u2013 Position constraint placing this object below the other Source code in src/fdtdx/objects/object.py 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 def place_below ( self , other : \"SimulationObject\" , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint : \"\"\"Creates a PositionConstraint that places this object below another object along the z-axis. This is a convenience wrapper around face_to_face_negative_direction() for axis 2 (z-axis). Args: other (SimulationObject): Another object in the simulation scene margins (tuple[float, ...] | float | None, optional): Additional vertical margins in meters between objects. If None, no margin is used. Defaults to None. grid_margins (tuple[int, ...] | int | None, optional): Additional vertical margins in Yee-grid voxels between objects. If None, no margin is used. Defaults to None. Returns: PositionConstraint: Position constraint placing this object below the other \"\"\" constraint = self . face_to_face_negative_direction ( other = other , axes = ( 2 ,), margins = margins , grid_margins = grid_margins , ) return constraint place_relative_to place_relative_to ( other : SimulationObject , axes : tuple [ int , ... ] | int , own_positions : tuple [ float , ... ] | float , other_positions : tuple [ float , ... ] | float , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint Creates a PositionalConstraint between two objects. The constraint is defined by anchor points on both objects, which are constrainted to be at the same position. Anchors are defined in relative coordinates, i.e. a position of -1 is the left object boundary in the repective axis and a position of +1 the right boundary. Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene axes ( tuple [ int , ...] | int ) \u2013 Eiter a single integer or a tuple describing the axes of the constraints own_positions ( tuple [ float , ...] | float ) \u2013 The positions of the own anchor in the axes. Must have the same lengths as axes other_positions ( tuple [ float , ...] | float ) \u2013 The positions of the other objects' anchor in the axes. Must have the same lengths as axes margins ( tuple [ float , ...] | float | None , default: None ) \u2013 The margins between the anchors of both objects in meters. Must have the same lengths as axes. If None, no margin is used. Defaults to None. grid_margins ( tuple [ int , ...] | int | None , default: None ) \u2013 The margins between the anchors of both objects in Yee-grid voxels. Must have the same lengths as axes. If none, no margin is used. Defaults to None. Returns: PositionConstraint ( PositionConstraint ) \u2013 Positional constraint between this object and the other Source code in src/fdtdx/objects/object.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 def place_relative_to ( self , other : \"SimulationObject\" , axes : tuple [ int , ... ] | int , own_positions : tuple [ float , ... ] | float , other_positions : tuple [ float , ... ] | float , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint : \"\"\"Creates a PositionalConstraint between two objects. The constraint is defined by anchor points on both objects, which are constrainted to be at the same position. Anchors are defined in relative coordinates, i.e. a position of -1 is the left object boundary in the repective axis and a position of +1 the right boundary. Args: other (SimulationObject): Another object in the simulation scene axes (tuple[int, ...] | int): Eiter a single integer or a tuple describing the axes of the constraints own_positions (tuple[float, ...] | float): The positions of the own anchor in the axes. Must have the same lengths as axes other_positions (tuple[float, ...] | float): The positions of the other objects' anchor in the axes. Must have the same lengths as axes margins (tuple[float, ...] | float | None, optional): The margins between the anchors of both objects in meters. Must have the same lengths as axes. If None, no margin is used. Defaults to None. grid_margins (tuple[int, ...] | int | None, optional): The margins between the anchors of both objects in Yee-grid voxels. Must have the same lengths as axes. If none, no margin is used. Defaults to None. Returns: PositionConstraint: Positional constraint between this object and the other \"\"\" if isinstance ( axes , int ): axes = ( axes ,) if isinstance ( own_positions , int | float ): own_positions = ( float ( own_positions ),) if isinstance ( other_positions , int | float ): other_positions = ( float ( other_positions ),) if isinstance ( margins , int | float ): margins = ( float ( margins ),) if isinstance ( grid_margins , int ): grid_margins = ( grid_margins ,) if margins is None : margins = tuple ([ 0 for _ in axes ]) if grid_margins is None : grid_margins = tuple ([ 0 for _ in axes ]) if ( len ( axes ) != len ( own_positions ) or len ( axes ) != len ( other_positions ) or len ( axes ) != len ( margins ) or len ( axes ) != len ( grid_margins ) ): raise Exception ( \"All inputs should have same lengths\" ) constraint = PositionConstraint ( axes = axes , other_object = other , object = self , other_object_positions = other_positions , object_positions = own_positions , margins = margins , grid_margins = grid_margins , ) return constraint same_position_and_size same_position_and_size ( other : SimulationObject , axes : tuple [ int , ... ] | int = ( 0 , 1 , 2 ), ) -> tuple [ PositionConstraint , SizeConstraint ] Creates both position and size constraints to make this object match another object's position and size. This is a convenience wrapper combining place_at_center() and same_size(). Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene axes ( tuple [ int , ...] | int , default: (0, 1, 2) ) \u2013 Either a single integer or a tuple describing which axes to match. Defaults to all axes (0, 1, 2). Returns: tuple [ PositionConstraint , SizeConstraint ] \u2013 tuple[PositionConstraint, SizeConstraint]: Position and size constraints for matching objects Source code in src/fdtdx/objects/object.py 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 def same_position_and_size ( self , other : \"SimulationObject\" , axes : tuple [ int , ... ] | int = ( 0 , 1 , 2 ), ) -> tuple [ PositionConstraint , SizeConstraint ]: \"\"\"Creates both position and size constraints to make this object match another object's position and size. This is a convenience wrapper combining place_at_center() and same_size(). Args: other (SimulationObject): Another object in the simulation scene axes (tuple[int, ...] | int, optional): Either a single integer or a tuple describing which axes to match. Defaults to all axes (0, 1, 2). Returns: tuple[PositionConstraint, SizeConstraint]: Position and size constraints for matching objects \"\"\" size_constraint = self . same_size ( other = other , axes = axes , ) pos_constraint = self . place_at_center ( other = other , axes = axes , ) return pos_constraint , size_constraint same_size same_size ( other : SimulationObject , axes : tuple [ int , ... ] | int = ( 0 , 1 , 2 ), offsets : tuple [ float , ... ] | float | None = None , grid_offsets : tuple [ int , ... ] | int | None = None , ) -> SizeConstraint Creates a SizeConstraint that makes this object the same size as another object along specified axes. This is a convenience wrapper around size_relative_to() with proportions set to 1.0. Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene axes ( tuple [ int , ...] | int , default: (0, 1, 2) ) \u2013 Either a single integer or a tuple describing which axes should have the same size. Defaults to all axes (0, 1, 2). offsets ( tuple [ float , ...] | float | None , default: None ) \u2013 Additional size offsets in meters to apply. Must have same length as axes. If None, no offset is used. Defaults to None. grid_offsets ( tuple [ int , ...] | int | None , default: None ) \u2013 Additional size offsets in Yee-grid voxels to apply. Must have same length as axes. If None, no offset is used. Defaults to None. Returns: SizeConstraint ( SizeConstraint ) \u2013 Size constraint ensuring equal sizes between objects Source code in src/fdtdx/objects/object.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 def same_size ( self , other : \"SimulationObject\" , axes : tuple [ int , ... ] | int = ( 0 , 1 , 2 ), offsets : tuple [ float , ... ] | float | None = None , grid_offsets : tuple [ int , ... ] | int | None = None , ) -> SizeConstraint : \"\"\"Creates a SizeConstraint that makes this object the same size as another object along specified axes. This is a convenience wrapper around size_relative_to() with proportions set to 1.0. Args: other (SimulationObject): Another object in the simulation scene axes (tuple[int, ...] | int, optional): Either a single integer or a tuple describing which axes should have the same size. Defaults to all axes (0, 1, 2). offsets (tuple[float, ...] | float | None, optional): Additional size offsets in meters to apply. Must have same length as axes. If None, no offset is used. Defaults to None. grid_offsets (tuple[int, ...] | int | None, optional): Additional size offsets in Yee-grid voxels to apply. Must have same length as axes. If None, no offset is used. Defaults to None. Returns: SizeConstraint: Size constraint ensuring equal sizes between objects \"\"\" if isinstance ( axes , int ): axes = ( axes ,) proportions = tuple ([ 1 for _ in axes ]) constraint = self . size_relative_to ( other = other , axes = axes , proportions = proportions , offsets = offsets , grid_offsets = grid_offsets , ) return constraint set_grid_coordinates set_grid_coordinates ( axes : tuple [ int , ... ] | int , sides : ( tuple [ Literal [ \"+\" , \"-\" ], ... ] | Literal [ \"+\" , \"-\" ] ), coordinates : tuple [ int , ... ] | int , ) -> GridCoordinateConstraint Creates a GridCoordinateConstraint that forces specific sides of this object to align with given grid coordinates. Used for precise positioning in the discretized simulation space. Parameters: axes ( tuple [ int , ...] | int ) \u2013 Either a single integer or a tuple describing which axes to constrain sides ( tuple [ Literal ['+', '-'], ...] | Literal ['+', '-'] ) \u2013 Either a single string or a tuple of strings ('+' or '-') indicating which side of each axis to constrain. Must have same length as axes. coordinates ( tuple [ int , ...] | int ) \u2013 Either a single integer or a tuple of integers specifying the grid coordinates to align with. Must have same length as axes. Returns: GridCoordinateConstraint ( GridCoordinateConstraint ) \u2013 Constraint forcing alignment with specific grid coordinates Source code in src/fdtdx/objects/object.py 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 def set_grid_coordinates ( self , axes : tuple [ int , ... ] | int , sides : tuple [ Literal [ \"+\" , \"-\" ], ... ] | Literal [ \"+\" , \"-\" ], coordinates : tuple [ int , ... ] | int , ) -> GridCoordinateConstraint : \"\"\"Creates a GridCoordinateConstraint that forces specific sides of this object to align with given grid coordinates. Used for precise positioning in the discretized simulation space. Args: axes (tuple[int, ...] | int): Either a single integer or a tuple describing which axes to constrain sides (tuple[Literal[\"+\", \"-\"], ...] | Literal[\"+\", \"-\"]): Either a single string or a tuple of strings ('+' or '-') indicating which side of each axis to constrain. Must have same length as axes. coordinates (tuple[int, ...] | int): Either a single integer or a tuple of integers specifying the grid coordinates to align with. Must have same length as axes. Returns: GridCoordinateConstraint: Constraint forcing alignment with specific grid coordinates \"\"\" if isinstance ( axes , int ): axes = ( axes ,) if isinstance ( sides , str ): sides = ( sides ,) if isinstance ( coordinates , int ): coordinates = ( coordinates ,) if len ( axes ) != len ( sides ) or len ( axes ) != len ( coordinates ): raise Exception ( \"All inputs need to have the same lengths!\" ) return GridCoordinateConstraint ( object = self , axes = axes , sides = sides , coordinates = coordinates , ) set_real_coordinates set_real_coordinates ( axes : tuple [ int , ... ] | int , sides : ( tuple [ Literal [ \"+\" , \"-\" ], ... ] | Literal [ \"+\" , \"-\" ] ), coordinates : tuple [ float , ... ] | float , ) -> RealCoordinateConstraint Creates a RealCoordinateConstraint that forces specific sides of this object to align with given real-space coordinates. Used for precise positioning in physical units. Parameters: axes ( tuple [ int , ...] | int ) \u2013 Either a single integer or a tuple describing which axes to constrain sides ( tuple [ Literal ['+', '-'], ...] | Literal ['+', '-'] ) \u2013 Either a single string or a tuple of strings ('+' or '-') indicating which side of each axis to constrain. Must have same length as axes. coordinates ( tuple [ float , ...] | float ) \u2013 Either a single float or a tuple of floats specifying the real-space coordinates in meters to align with. Must have same length as axes. Returns: RealCoordinateConstraint ( RealCoordinateConstraint ) \u2013 Constraint forcing alignment with specific real-space coordinates Source code in src/fdtdx/objects/object.py 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 def set_real_coordinates ( self , axes : tuple [ int , ... ] | int , sides : tuple [ Literal [ \"+\" , \"-\" ], ... ] | Literal [ \"+\" , \"-\" ], coordinates : tuple [ float , ... ] | float , ) -> RealCoordinateConstraint : \"\"\"Creates a RealCoordinateConstraint that forces specific sides of this object to align with given real-space coordinates. Used for precise positioning in physical units. Args: axes (tuple[int, ...] | int): Either a single integer or a tuple describing which axes to constrain sides (tuple[Literal[\"+\", \"-\"], ...] | Literal[\"+\", \"-\"]): Either a single string or a tuple of strings ('+' or '-') indicating which side of each axis to constrain. Must have same length as axes. coordinates (tuple[float, ...] | float): Either a single float or a tuple of floats specifying the real-space coordinates in meters to align with. Must have same length as axes. Returns: RealCoordinateConstraint: Constraint forcing alignment with specific real-space coordinates \"\"\" if isinstance ( axes , int ): axes = ( axes ,) if isinstance ( sides , str ): sides = ( sides ,) if isinstance ( coordinates , int | float ): coordinates = ( float ( coordinates ),) if len ( axes ) != len ( sides ) or len ( axes ) != len ( coordinates ): raise Exception ( \"All inputs need to have the same lengths!\" ) return RealCoordinateConstraint ( object = self , axes = axes , sides = sides , coordinates = coordinates , ) size_relative_to size_relative_to ( other : SimulationObject , axes : tuple [ int , ... ] | int , other_axes : tuple [ int , ... ] | int | None = None , proportions : tuple [ float , ... ] | float | None = None , offsets : tuple [ float , ... ] | float | None = None , grid_offsets : tuple [ int , ... ] | int | None = None , ) -> SizeConstraint Creates a SizeConstraint between two objects. The constraint defines the size of this object relative to another object, allowing for proportional scaling and offsets in specified axes. Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene axes ( tuple [ int , ...] | int ) \u2013 Either a single integer or a tuple describing which axes of this object to constrain. other_axes ( tuple [ int , ...] | int | None , default: None ) \u2013 Either a single integer or a tuple describing which axes of the other object to reference. If None, uses the same axes as specified in 'axes'. Defaults to None. proportions ( tuple [ float , ...] | float | None , default: None ) \u2013 Scale factors to apply to the other object's dimensions. Must have same length as axes. If None, uses 1.0 (same size). Defaults to None. offsets ( tuple [ float , ...] | float | None , default: None ) \u2013 Additional size offsets in meters to apply after scaling. Must have same length as axes. If None, no offset is used. Defaults to None. grid_offsets ( tuple [ int , ...] | int | None , default: None ) \u2013 Additional size offsets in Yee-grid voxels to apply after scaling. Must have same length as axes. If None, no offset is used. Defaults to None. Returns: SizeConstraint ( SizeConstraint ) \u2013 Size constraint between this object and the other Source code in src/fdtdx/objects/object.py 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 def size_relative_to ( self , other : \"SimulationObject\" , axes : tuple [ int , ... ] | int , other_axes : tuple [ int , ... ] | int | None = None , proportions : tuple [ float , ... ] | float | None = None , offsets : tuple [ float , ... ] | float | None = None , grid_offsets : tuple [ int , ... ] | int | None = None , ) -> SizeConstraint : \"\"\"Creates a SizeConstraint between two objects. The constraint defines the size of this object relative to another object, allowing for proportional scaling and offsets in specified axes. Args: other (SimulationObject): Another object in the simulation scene axes (tuple[int, ...] | int): Either a single integer or a tuple describing which axes of this object to constrain. other_axes (tuple[int, ...] | int | None, optional): Either a single integer or a tuple describing which axes of the other object to reference. If None, uses the same axes as specified in 'axes'. Defaults to None. proportions (tuple[float, ...] | float | None, optional): Scale factors to apply to the other object's dimensions. Must have same length as axes. If None, uses 1.0 (same size). Defaults to None. offsets (tuple[float, ...] | float | None, optional): Additional size offsets in meters to apply after scaling. Must have same length as axes. If None, no offset is used. Defaults to None. grid_offsets (tuple[int, ...] | int | None, optional): Additional size offsets in Yee-grid voxels to apply after scaling. Must have same length as axes. If None, no offset is used. Defaults to None. Returns: SizeConstraint: Size constraint between this object and the other \"\"\" if isinstance ( axes , int ): axes = ( axes ,) if isinstance ( other_axes , int ): other_axes = ( other_axes ,) if isinstance ( proportions , int | float ): proportions = ( float ( proportions ),) if isinstance ( offsets , int | float ): offsets = ( offsets ,) if isinstance ( grid_offsets , int ): grid_offsets = ( grid_offsets ,) if offsets is None : offsets = tuple ([ 0 for _ in axes ]) if grid_offsets is None : grid_offsets = tuple ([ 0 for _ in axes ]) if proportions is None : proportions = tuple ([ 1.0 for _ in axes ]) if other_axes is None : other_axes = tuple ([ a for a in axes ]) if len ( axes ) != len ( proportions ) or len ( axes ) != len ( offsets ) or len ( axes ) != len ( grid_offsets ): raise Exception ( \"All inputs should have same lengths\" ) constraint = SizeConstraint ( other_object = other , object = self , axes = axes , other_axes = other_axes , proportions = proportions , offsets = offsets , grid_offsets = grid_offsets , ) return constraint","title":"fdtdx.SimulationObject"},{"location":"api/public/SimulationObject/#fdtdxsimulationobject","text":"","title":"fdtdx.SimulationObject"},{"location":"api/public/SimulationObject/#fdtdx.SimulationObject","text":"Bases: TreeClass , ABC Abstract base class for objects in a 3D simulation environment. This class provides the foundation for simulation objects with spatial properties and positioning capabilities in both real and grid coordinate systems. It supports random positioning offsets. Attributes: partial_real_shape ( PartialRealShape3D ) \u2013 The object's shape in real-world coordinates. Defaults to UNDEFINED_SHAPE_3D if not specified. partial_grid_shape ( PartialGridShape3D ) \u2013 The object's shape in grid coordinates. Defaults to UNDEFINED_SHAPE_3D if not specified. color ( tuple [ float , float , float ] | None ) \u2013 RGB color values for the object, where each component is in the interval [0, 1]. None indicates no color is specified. Defaults to None. name ( str ) \u2013 Unique identifier for the object. Automatically enforced to be unique through the UniqueName validator. The user can also set a name manually. max_random_real_offsets ( tuple [ float , float , float ] ) \u2013 Maximum random offset values that can be applied to the object's position in real coordinates for each axis (x, y, z). Defaults to (0, 0, 0) for no random offset. max_random_grid_offsets ( tuple [ int , int , int ] ) \u2013 Maximum random offset values that can be applied to the object's position in grid coordinates for each axis (x, y, z). Defaults to (0, 0, 0) for no random offset. Note This is an abstract base class and cannot be instantiated directly.","title":"SimulationObject"},{"location":"api/public/SimulationObject/#fdtdx.SimulationObject.extend_to","text":"extend_to ( other : SimulationObject | None , axis : int , direction : Literal [ \"+\" , \"-\" ], other_position : float | None = None , offset : float = 0 , grid_offset : int = 0 , ) -> SizeExtensionConstraint Creates a SizeExtensionConstraint that extends this object along a specified axis until it reaches another object or the simulation boundary. The extension can be in either positive or negative direction. Parameters: other ( SimulationObject | None ) \u2013 Target object to extend to, or None to extend to simulation boundary axis ( int ) \u2013 Which axis to extend along (0, 1, or 2) direction ( Literal ['+', '-'] ) \u2013 Direction to extend in ('+' or '-') other_position ( float | None , default: None ) \u2013 Relative position on target object (-1 to 1) to extend to. If None, defaults to the corresponding side (-1 for '+' direction, 1 for '-' direction). Defaults to None. offset ( float , default: 0 ) \u2013 Additional offset in meters to apply after extension. Ignored when extending to simulation boundary. Defaults to zero. grid_offset ( int , default: 0 ) \u2013 Additional offset in Yee-grid voxels to apply after extension. Ignored when extending to simulation boundary. Defaults to zero. Returns: SizeExtensionConstraint ( SizeExtensionConstraint ) \u2013 Constraint defining how the object extends Source code in src/fdtdx/objects/object.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 def extend_to ( self , other : \"SimulationObject | None\" , axis : int , direction : Literal [ \"+\" , \"-\" ], other_position : float | None = None , offset : float = 0 , grid_offset : int = 0 , ) -> SizeExtensionConstraint : \"\"\"Creates a SizeExtensionConstraint that extends this object along a specified axis until it reaches another object or the simulation boundary. The extension can be in either positive or negative direction. Args: other (SimulationObject | None): Target object to extend to, or None to extend to simulation boundary axis (int): Which axis to extend along (0, 1, or 2) direction (Literal[\"+\", \"-\"]): Direction to extend in ('+' or '-') other_position (float | None, optional): Relative position on target object (-1 to 1) to extend to. If None, defaults to the corresponding side (-1 for '+' direction, 1 for '-' direction). Defaults to None. offset (float, optional): Additional offset in meters to apply after extension. Ignored when extending to simulation boundary. Defaults to zero. grid_offset (int, optional): Additional offset in Yee-grid voxels to apply after extension. Ignored when extending to simulation boundary. Defaults to zero. Returns: SizeExtensionConstraint: Constraint defining how the object extends \"\"\" # default: extend to corresponding side if other_position is None : other_position = - 1 if direction == \"+\" else 1 if other is None : if offset != 0 or grid_offset != 0 : raise Exception ( \"Cannot use offset when extending object to infinity\" ) return SizeExtensionConstraint ( object = self , other_object = other , axis = axis , direction = direction , other_position = other_position , offset = offset , grid_offset = grid_offset , )","title":"extend_to"},{"location":"api/public/SimulationObject/#fdtdx.SimulationObject.face_to_face_negative_direction","text":"face_to_face_negative_direction ( other : SimulationObject , axes : tuple [ int , ... ] | int , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint Creates a PositionConstraint that places this object facing another object in the negative direction of specified axes. The objects will touch at their facing boundaries unless margins are specified. Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene axes ( tuple [ int , ...] | int ) \u2013 Either a single integer or a tuple describing which axes to align on margins ( tuple [ float , ...] | float | None , default: None ) \u2013 Additional margins in meters between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None. grid_margins ( tuple [ int , ...] | int | None , default: None ) \u2013 Additional margins in Yee-grid voxels between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None. Returns: PositionConstraint ( PositionConstraint ) \u2013 Position constraint aligning objects face-to-face in negative direction Source code in src/fdtdx/objects/object.py 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 def face_to_face_negative_direction ( self , other : \"SimulationObject\" , axes : tuple [ int , ... ] | int , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint : \"\"\"Creates a PositionConstraint that places this object facing another object in the negative direction of specified axes. The objects will touch at their facing boundaries unless margins are specified. Args: other (SimulationObject): Another object in the simulation scene axes (tuple[int, ...] | int): Either a single integer or a tuple describing which axes to align on margins (tuple[float, ...] | float | None, optional): Additional margins in meters between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None. grid_margins (tuple[int, ...] | int | None, optional): Additional margins in Yee-grid voxels between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None. Returns: PositionConstraint: Position constraint aligning objects face-to-face in negative direction \"\"\" if isinstance ( axes , int ): axes = ( axes ,) own_positions = tuple ([ 1 for _ in axes ]) other_positions = tuple ([ - 1 for _ in axes ]) constraint = self . place_relative_to ( other = other , axes = axes , own_positions = own_positions , other_positions = other_positions , margins = margins , grid_margins = grid_margins , ) return constraint","title":"face_to_face_negative_direction"},{"location":"api/public/SimulationObject/#fdtdx.SimulationObject.face_to_face_positive_direction","text":"face_to_face_positive_direction ( other : SimulationObject , axes : tuple [ int , ... ] | int , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint Creates a PositionConstraint that places this object facing another object in the positive direction of specified axes. The objects will touch at their facing boundaries unless margins are specified. Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene axes ( tuple [ int , ...] | int ) \u2013 Either a single integer or a tuple describing which axes to align on margins ( tuple [ float , ...] | float | None , default: None ) \u2013 Additional margins in meters between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None. grid_margins ( tuple [ int , ...] | int | None , default: None ) \u2013 Additional margins in Yee-grid voxels between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None Returns: PositionConstraint ( PositionConstraint ) \u2013 Position constraint aligning objects face-to-face in positive direction Source code in src/fdtdx/objects/object.py 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 def face_to_face_positive_direction ( self , other : \"SimulationObject\" , axes : tuple [ int , ... ] | int , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint : \"\"\"Creates a PositionConstraint that places this object facing another object in the positive direction of specified axes. The objects will touch at their facing boundaries unless margins are specified. Args: other (SimulationObject): Another object in the simulation scene axes (tuple[int, ...] | int): Either a single integer or a tuple describing which axes to align on margins (tuple[float, ...] | float | None, optional): Additional margins in meters between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None. grid_margins (tuple[int, ...] | int | None, optional): Additional margins in Yee-grid voxels between the facing surfaces. Must have same length as axes. If None, no margin is used. Defaults to None Returns: PositionConstraint: Position constraint aligning objects face-to-face in positive direction \"\"\" if isinstance ( axes , int ): axes = ( axes ,) own_positions = tuple ([ - 1 for _ in axes ]) other_positions = tuple ([ 1 for _ in axes ]) constraint = self . place_relative_to ( other = other , axes = axes , own_positions = own_positions , other_positions = other_positions , margins = margins , grid_margins = grid_margins , ) return constraint","title":"face_to_face_positive_direction"},{"location":"api/public/SimulationObject/#fdtdx.SimulationObject.place_above","text":"place_above ( other : SimulationObject , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint Creates a PositionConstraint that places this object above another object along the z-axis. This is a convenience wrapper around face_to_face_positive_direction() for axis 2 (z-axis). Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene margins ( tuple [ float , ...] | float | None , default: None ) \u2013 Additional vertical margins in meters between objects. If None, no margin is used. Defaults to None. grid_margins ( tuple [ int , ...] | int | None , default: None ) \u2013 Additional vertical margins in Yee-grid voxels between objects. If None, no margin is used. Defaults to None. Returns: PositionConstraint ( PositionConstraint ) \u2013 Position constraint placing this object above the other Source code in src/fdtdx/objects/object.py 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 def place_above ( self , other : \"SimulationObject\" , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint : \"\"\"Creates a PositionConstraint that places this object above another object along the z-axis. This is a convenience wrapper around face_to_face_positive_direction() for axis 2 (z-axis). Args: other (SimulationObject): Another object in the simulation scene margins (tuple[float, ...] | float | None, optional): Additional vertical margins in meters between objects. If None, no margin is used. Defaults to None. grid_margins (tuple[int, ...] | int | None, optional): Additional vertical margins in Yee-grid voxels between objects. If None, no margin is used. Defaults to None. Returns: PositionConstraint: Position constraint placing this object above the other \"\"\" constraint = self . face_to_face_positive_direction ( other = other , axes = ( 2 ,), margins = margins , grid_margins = grid_margins , ) return constraint","title":"place_above"},{"location":"api/public/SimulationObject/#fdtdx.SimulationObject.place_at_center","text":"place_at_center ( other : SimulationObject , axes : tuple [ int , ... ] | int = ( 0 , 1 , 2 ), own_positions : tuple [ float , ... ] | float | None = None , other_positions : ( tuple [ float , ... ] | float | None ) = None , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint Creates a PositionConstraint that centers this object relative to another object along specified axes. This is a convenience wrapper around place_relative_to() with default positions at the center (0). Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene axes ( tuple [ int , ...] | int , default: (0, 1, 2) ) \u2013 Either a single integer or a tuple describing which axes to center on. Defaults to all axes (0, 1, 2). own_positions ( tuple [ float , ...] | float | None , default: None ) \u2013 Relative positions on this object (-1 to 1). If None, uses center (0). Defaults to None. other_positions ( tuple [ float , ...] | float | None , default: None ) \u2013 Relative positions on other object (-1 to 1). If None, uses center (0). Defaults to None. margins ( tuple [ float , ...] | float | None , default: None ) \u2013 Additional margins in meters between objects. Must have same length as axes. If None, no margin is used. Defaults to None. grid_margins ( tuple[int, ...] | int | None , default: None ) \u2013 Additional margins in Yee-grid voxels between objects. Must have same length as axes. If None, no margin is used. Defaults to None. Returns: PositionConstraint ( PositionConstraint ) \u2013 Position constraint centering objects relative to each other Source code in src/fdtdx/objects/object.py 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 def place_at_center ( self , other : \"SimulationObject\" , axes : tuple [ int , ... ] | int = ( 0 , 1 , 2 ), own_positions : tuple [ float , ... ] | float | None = None , other_positions : tuple [ float , ... ] | float | None = None , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint : \"\"\"Creates a PositionConstraint that centers this object relative to another object along specified axes. This is a convenience wrapper around place_relative_to() with default positions at the center (0). Args: other (SimulationObject): Another object in the simulation scene axes (tuple[int, ...] | int, optional): Either a single integer or a tuple describing which axes to center on. Defaults to all axes (0, 1, 2). own_positions (tuple[float, ...] | float | None, optional): Relative positions on this object (-1 to 1). If None, uses center (0). Defaults to None. other_positions (tuple[float, ...] | float | None, optional): Relative positions on other object (-1 to 1). If None, uses center (0). Defaults to None. margins (tuple[float, ...] | float | None, optional): Additional margins in meters between objects. Must have same length as axes. If None, no margin is used. Defaults to None. grid_margins ( tuple[int, ...] | int | None, optional): Additional margins in Yee-grid voxels between objects. Must have same length as axes. If None, no margin is used. Defaults to None. Returns: PositionConstraint: Position constraint centering objects relative to each other \"\"\" if isinstance ( axes , int ): axes = ( axes ,) if own_positions is None : own_positions = tuple ([ 0 for _ in axes ]) if other_positions is None : other_positions = tuple ([ 0 for _ in axes ]) constraint = self . place_relative_to ( other = other , axes = axes , own_positions = own_positions , other_positions = other_positions , margins = margins , grid_margins = grid_margins , ) return constraint","title":"place_at_center"},{"location":"api/public/SimulationObject/#fdtdx.SimulationObject.place_below","text":"place_below ( other : SimulationObject , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint Creates a PositionConstraint that places this object below another object along the z-axis. This is a convenience wrapper around face_to_face_negative_direction() for axis 2 (z-axis). Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene margins ( tuple [ float , ...] | float | None , default: None ) \u2013 Additional vertical margins in meters between objects. If None, no margin is used. Defaults to None. grid_margins ( tuple [ int , ...] | int | None , default: None ) \u2013 Additional vertical margins in Yee-grid voxels between objects. If None, no margin is used. Defaults to None. Returns: PositionConstraint ( PositionConstraint ) \u2013 Position constraint placing this object below the other Source code in src/fdtdx/objects/object.py 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 def place_below ( self , other : \"SimulationObject\" , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint : \"\"\"Creates a PositionConstraint that places this object below another object along the z-axis. This is a convenience wrapper around face_to_face_negative_direction() for axis 2 (z-axis). Args: other (SimulationObject): Another object in the simulation scene margins (tuple[float, ...] | float | None, optional): Additional vertical margins in meters between objects. If None, no margin is used. Defaults to None. grid_margins (tuple[int, ...] | int | None, optional): Additional vertical margins in Yee-grid voxels between objects. If None, no margin is used. Defaults to None. Returns: PositionConstraint: Position constraint placing this object below the other \"\"\" constraint = self . face_to_face_negative_direction ( other = other , axes = ( 2 ,), margins = margins , grid_margins = grid_margins , ) return constraint","title":"place_below"},{"location":"api/public/SimulationObject/#fdtdx.SimulationObject.place_relative_to","text":"place_relative_to ( other : SimulationObject , axes : tuple [ int , ... ] | int , own_positions : tuple [ float , ... ] | float , other_positions : tuple [ float , ... ] | float , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint Creates a PositionalConstraint between two objects. The constraint is defined by anchor points on both objects, which are constrainted to be at the same position. Anchors are defined in relative coordinates, i.e. a position of -1 is the left object boundary in the repective axis and a position of +1 the right boundary. Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene axes ( tuple [ int , ...] | int ) \u2013 Eiter a single integer or a tuple describing the axes of the constraints own_positions ( tuple [ float , ...] | float ) \u2013 The positions of the own anchor in the axes. Must have the same lengths as axes other_positions ( tuple [ float , ...] | float ) \u2013 The positions of the other objects' anchor in the axes. Must have the same lengths as axes margins ( tuple [ float , ...] | float | None , default: None ) \u2013 The margins between the anchors of both objects in meters. Must have the same lengths as axes. If None, no margin is used. Defaults to None. grid_margins ( tuple [ int , ...] | int | None , default: None ) \u2013 The margins between the anchors of both objects in Yee-grid voxels. Must have the same lengths as axes. If none, no margin is used. Defaults to None. Returns: PositionConstraint ( PositionConstraint ) \u2013 Positional constraint between this object and the other Source code in src/fdtdx/objects/object.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 def place_relative_to ( self , other : \"SimulationObject\" , axes : tuple [ int , ... ] | int , own_positions : tuple [ float , ... ] | float , other_positions : tuple [ float , ... ] | float , margins : tuple [ float , ... ] | float | None = None , grid_margins : tuple [ int , ... ] | int | None = None , ) -> PositionConstraint : \"\"\"Creates a PositionalConstraint between two objects. The constraint is defined by anchor points on both objects, which are constrainted to be at the same position. Anchors are defined in relative coordinates, i.e. a position of -1 is the left object boundary in the repective axis and a position of +1 the right boundary. Args: other (SimulationObject): Another object in the simulation scene axes (tuple[int, ...] | int): Eiter a single integer or a tuple describing the axes of the constraints own_positions (tuple[float, ...] | float): The positions of the own anchor in the axes. Must have the same lengths as axes other_positions (tuple[float, ...] | float): The positions of the other objects' anchor in the axes. Must have the same lengths as axes margins (tuple[float, ...] | float | None, optional): The margins between the anchors of both objects in meters. Must have the same lengths as axes. If None, no margin is used. Defaults to None. grid_margins (tuple[int, ...] | int | None, optional): The margins between the anchors of both objects in Yee-grid voxels. Must have the same lengths as axes. If none, no margin is used. Defaults to None. Returns: PositionConstraint: Positional constraint between this object and the other \"\"\" if isinstance ( axes , int ): axes = ( axes ,) if isinstance ( own_positions , int | float ): own_positions = ( float ( own_positions ),) if isinstance ( other_positions , int | float ): other_positions = ( float ( other_positions ),) if isinstance ( margins , int | float ): margins = ( float ( margins ),) if isinstance ( grid_margins , int ): grid_margins = ( grid_margins ,) if margins is None : margins = tuple ([ 0 for _ in axes ]) if grid_margins is None : grid_margins = tuple ([ 0 for _ in axes ]) if ( len ( axes ) != len ( own_positions ) or len ( axes ) != len ( other_positions ) or len ( axes ) != len ( margins ) or len ( axes ) != len ( grid_margins ) ): raise Exception ( \"All inputs should have same lengths\" ) constraint = PositionConstraint ( axes = axes , other_object = other , object = self , other_object_positions = other_positions , object_positions = own_positions , margins = margins , grid_margins = grid_margins , ) return constraint","title":"place_relative_to"},{"location":"api/public/SimulationObject/#fdtdx.SimulationObject.same_position_and_size","text":"same_position_and_size ( other : SimulationObject , axes : tuple [ int , ... ] | int = ( 0 , 1 , 2 ), ) -> tuple [ PositionConstraint , SizeConstraint ] Creates both position and size constraints to make this object match another object's position and size. This is a convenience wrapper combining place_at_center() and same_size(). Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene axes ( tuple [ int , ...] | int , default: (0, 1, 2) ) \u2013 Either a single integer or a tuple describing which axes to match. Defaults to all axes (0, 1, 2). Returns: tuple [ PositionConstraint , SizeConstraint ] \u2013 tuple[PositionConstraint, SizeConstraint]: Position and size constraints for matching objects Source code in src/fdtdx/objects/object.py 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 def same_position_and_size ( self , other : \"SimulationObject\" , axes : tuple [ int , ... ] | int = ( 0 , 1 , 2 ), ) -> tuple [ PositionConstraint , SizeConstraint ]: \"\"\"Creates both position and size constraints to make this object match another object's position and size. This is a convenience wrapper combining place_at_center() and same_size(). Args: other (SimulationObject): Another object in the simulation scene axes (tuple[int, ...] | int, optional): Either a single integer or a tuple describing which axes to match. Defaults to all axes (0, 1, 2). Returns: tuple[PositionConstraint, SizeConstraint]: Position and size constraints for matching objects \"\"\" size_constraint = self . same_size ( other = other , axes = axes , ) pos_constraint = self . place_at_center ( other = other , axes = axes , ) return pos_constraint , size_constraint","title":"same_position_and_size"},{"location":"api/public/SimulationObject/#fdtdx.SimulationObject.same_size","text":"same_size ( other : SimulationObject , axes : tuple [ int , ... ] | int = ( 0 , 1 , 2 ), offsets : tuple [ float , ... ] | float | None = None , grid_offsets : tuple [ int , ... ] | int | None = None , ) -> SizeConstraint Creates a SizeConstraint that makes this object the same size as another object along specified axes. This is a convenience wrapper around size_relative_to() with proportions set to 1.0. Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene axes ( tuple [ int , ...] | int , default: (0, 1, 2) ) \u2013 Either a single integer or a tuple describing which axes should have the same size. Defaults to all axes (0, 1, 2). offsets ( tuple [ float , ...] | float | None , default: None ) \u2013 Additional size offsets in meters to apply. Must have same length as axes. If None, no offset is used. Defaults to None. grid_offsets ( tuple [ int , ...] | int | None , default: None ) \u2013 Additional size offsets in Yee-grid voxels to apply. Must have same length as axes. If None, no offset is used. Defaults to None. Returns: SizeConstraint ( SizeConstraint ) \u2013 Size constraint ensuring equal sizes between objects Source code in src/fdtdx/objects/object.py 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 def same_size ( self , other : \"SimulationObject\" , axes : tuple [ int , ... ] | int = ( 0 , 1 , 2 ), offsets : tuple [ float , ... ] | float | None = None , grid_offsets : tuple [ int , ... ] | int | None = None , ) -> SizeConstraint : \"\"\"Creates a SizeConstraint that makes this object the same size as another object along specified axes. This is a convenience wrapper around size_relative_to() with proportions set to 1.0. Args: other (SimulationObject): Another object in the simulation scene axes (tuple[int, ...] | int, optional): Either a single integer or a tuple describing which axes should have the same size. Defaults to all axes (0, 1, 2). offsets (tuple[float, ...] | float | None, optional): Additional size offsets in meters to apply. Must have same length as axes. If None, no offset is used. Defaults to None. grid_offsets (tuple[int, ...] | int | None, optional): Additional size offsets in Yee-grid voxels to apply. Must have same length as axes. If None, no offset is used. Defaults to None. Returns: SizeConstraint: Size constraint ensuring equal sizes between objects \"\"\" if isinstance ( axes , int ): axes = ( axes ,) proportions = tuple ([ 1 for _ in axes ]) constraint = self . size_relative_to ( other = other , axes = axes , proportions = proportions , offsets = offsets , grid_offsets = grid_offsets , ) return constraint","title":"same_size"},{"location":"api/public/SimulationObject/#fdtdx.SimulationObject.set_grid_coordinates","text":"set_grid_coordinates ( axes : tuple [ int , ... ] | int , sides : ( tuple [ Literal [ \"+\" , \"-\" ], ... ] | Literal [ \"+\" , \"-\" ] ), coordinates : tuple [ int , ... ] | int , ) -> GridCoordinateConstraint Creates a GridCoordinateConstraint that forces specific sides of this object to align with given grid coordinates. Used for precise positioning in the discretized simulation space. Parameters: axes ( tuple [ int , ...] | int ) \u2013 Either a single integer or a tuple describing which axes to constrain sides ( tuple [ Literal ['+', '-'], ...] | Literal ['+', '-'] ) \u2013 Either a single string or a tuple of strings ('+' or '-') indicating which side of each axis to constrain. Must have same length as axes. coordinates ( tuple [ int , ...] | int ) \u2013 Either a single integer or a tuple of integers specifying the grid coordinates to align with. Must have same length as axes. Returns: GridCoordinateConstraint ( GridCoordinateConstraint ) \u2013 Constraint forcing alignment with specific grid coordinates Source code in src/fdtdx/objects/object.py 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 def set_grid_coordinates ( self , axes : tuple [ int , ... ] | int , sides : tuple [ Literal [ \"+\" , \"-\" ], ... ] | Literal [ \"+\" , \"-\" ], coordinates : tuple [ int , ... ] | int , ) -> GridCoordinateConstraint : \"\"\"Creates a GridCoordinateConstraint that forces specific sides of this object to align with given grid coordinates. Used for precise positioning in the discretized simulation space. Args: axes (tuple[int, ...] | int): Either a single integer or a tuple describing which axes to constrain sides (tuple[Literal[\"+\", \"-\"], ...] | Literal[\"+\", \"-\"]): Either a single string or a tuple of strings ('+' or '-') indicating which side of each axis to constrain. Must have same length as axes. coordinates (tuple[int, ...] | int): Either a single integer or a tuple of integers specifying the grid coordinates to align with. Must have same length as axes. Returns: GridCoordinateConstraint: Constraint forcing alignment with specific grid coordinates \"\"\" if isinstance ( axes , int ): axes = ( axes ,) if isinstance ( sides , str ): sides = ( sides ,) if isinstance ( coordinates , int ): coordinates = ( coordinates ,) if len ( axes ) != len ( sides ) or len ( axes ) != len ( coordinates ): raise Exception ( \"All inputs need to have the same lengths!\" ) return GridCoordinateConstraint ( object = self , axes = axes , sides = sides , coordinates = coordinates , )","title":"set_grid_coordinates"},{"location":"api/public/SimulationObject/#fdtdx.SimulationObject.set_real_coordinates","text":"set_real_coordinates ( axes : tuple [ int , ... ] | int , sides : ( tuple [ Literal [ \"+\" , \"-\" ], ... ] | Literal [ \"+\" , \"-\" ] ), coordinates : tuple [ float , ... ] | float , ) -> RealCoordinateConstraint Creates a RealCoordinateConstraint that forces specific sides of this object to align with given real-space coordinates. Used for precise positioning in physical units. Parameters: axes ( tuple [ int , ...] | int ) \u2013 Either a single integer or a tuple describing which axes to constrain sides ( tuple [ Literal ['+', '-'], ...] | Literal ['+', '-'] ) \u2013 Either a single string or a tuple of strings ('+' or '-') indicating which side of each axis to constrain. Must have same length as axes. coordinates ( tuple [ float , ...] | float ) \u2013 Either a single float or a tuple of floats specifying the real-space coordinates in meters to align with. Must have same length as axes. Returns: RealCoordinateConstraint ( RealCoordinateConstraint ) \u2013 Constraint forcing alignment with specific real-space coordinates Source code in src/fdtdx/objects/object.py 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 def set_real_coordinates ( self , axes : tuple [ int , ... ] | int , sides : tuple [ Literal [ \"+\" , \"-\" ], ... ] | Literal [ \"+\" , \"-\" ], coordinates : tuple [ float , ... ] | float , ) -> RealCoordinateConstraint : \"\"\"Creates a RealCoordinateConstraint that forces specific sides of this object to align with given real-space coordinates. Used for precise positioning in physical units. Args: axes (tuple[int, ...] | int): Either a single integer or a tuple describing which axes to constrain sides (tuple[Literal[\"+\", \"-\"], ...] | Literal[\"+\", \"-\"]): Either a single string or a tuple of strings ('+' or '-') indicating which side of each axis to constrain. Must have same length as axes. coordinates (tuple[float, ...] | float): Either a single float or a tuple of floats specifying the real-space coordinates in meters to align with. Must have same length as axes. Returns: RealCoordinateConstraint: Constraint forcing alignment with specific real-space coordinates \"\"\" if isinstance ( axes , int ): axes = ( axes ,) if isinstance ( sides , str ): sides = ( sides ,) if isinstance ( coordinates , int | float ): coordinates = ( float ( coordinates ),) if len ( axes ) != len ( sides ) or len ( axes ) != len ( coordinates ): raise Exception ( \"All inputs need to have the same lengths!\" ) return RealCoordinateConstraint ( object = self , axes = axes , sides = sides , coordinates = coordinates , )","title":"set_real_coordinates"},{"location":"api/public/SimulationObject/#fdtdx.SimulationObject.size_relative_to","text":"size_relative_to ( other : SimulationObject , axes : tuple [ int , ... ] | int , other_axes : tuple [ int , ... ] | int | None = None , proportions : tuple [ float , ... ] | float | None = None , offsets : tuple [ float , ... ] | float | None = None , grid_offsets : tuple [ int , ... ] | int | None = None , ) -> SizeConstraint Creates a SizeConstraint between two objects. The constraint defines the size of this object relative to another object, allowing for proportional scaling and offsets in specified axes. Parameters: other ( SimulationObject ) \u2013 Another object in the simulation scene axes ( tuple [ int , ...] | int ) \u2013 Either a single integer or a tuple describing which axes of this object to constrain. other_axes ( tuple [ int , ...] | int | None , default: None ) \u2013 Either a single integer or a tuple describing which axes of the other object to reference. If None, uses the same axes as specified in 'axes'. Defaults to None. proportions ( tuple [ float , ...] | float | None , default: None ) \u2013 Scale factors to apply to the other object's dimensions. Must have same length as axes. If None, uses 1.0 (same size). Defaults to None. offsets ( tuple [ float , ...] | float | None , default: None ) \u2013 Additional size offsets in meters to apply after scaling. Must have same length as axes. If None, no offset is used. Defaults to None. grid_offsets ( tuple [ int , ...] | int | None , default: None ) \u2013 Additional size offsets in Yee-grid voxels to apply after scaling. Must have same length as axes. If None, no offset is used. Defaults to None. Returns: SizeConstraint ( SizeConstraint ) \u2013 Size constraint between this object and the other Source code in src/fdtdx/objects/object.py 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 def size_relative_to ( self , other : \"SimulationObject\" , axes : tuple [ int , ... ] | int , other_axes : tuple [ int , ... ] | int | None = None , proportions : tuple [ float , ... ] | float | None = None , offsets : tuple [ float , ... ] | float | None = None , grid_offsets : tuple [ int , ... ] | int | None = None , ) -> SizeConstraint : \"\"\"Creates a SizeConstraint between two objects. The constraint defines the size of this object relative to another object, allowing for proportional scaling and offsets in specified axes. Args: other (SimulationObject): Another object in the simulation scene axes (tuple[int, ...] | int): Either a single integer or a tuple describing which axes of this object to constrain. other_axes (tuple[int, ...] | int | None, optional): Either a single integer or a tuple describing which axes of the other object to reference. If None, uses the same axes as specified in 'axes'. Defaults to None. proportions (tuple[float, ...] | float | None, optional): Scale factors to apply to the other object's dimensions. Must have same length as axes. If None, uses 1.0 (same size). Defaults to None. offsets (tuple[float, ...] | float | None, optional): Additional size offsets in meters to apply after scaling. Must have same length as axes. If None, no offset is used. Defaults to None. grid_offsets (tuple[int, ...] | int | None, optional): Additional size offsets in Yee-grid voxels to apply after scaling. Must have same length as axes. If None, no offset is used. Defaults to None. Returns: SizeConstraint: Size constraint between this object and the other \"\"\" if isinstance ( axes , int ): axes = ( axes ,) if isinstance ( other_axes , int ): other_axes = ( other_axes ,) if isinstance ( proportions , int | float ): proportions = ( float ( proportions ),) if isinstance ( offsets , int | float ): offsets = ( offsets ,) if isinstance ( grid_offsets , int ): grid_offsets = ( grid_offsets ,) if offsets is None : offsets = tuple ([ 0 for _ in axes ]) if grid_offsets is None : grid_offsets = tuple ([ 0 for _ in axes ]) if proportions is None : proportions = tuple ([ 1.0 for _ in axes ]) if other_axes is None : other_axes = tuple ([ a for a in axes ]) if len ( axes ) != len ( proportions ) or len ( axes ) != len ( offsets ) or len ( axes ) != len ( grid_offsets ): raise Exception ( \"All inputs should have same lengths\" ) constraint = SizeConstraint ( other_object = other , object = self , axes = axes , other_axes = other_axes , proportions = proportions , offsets = offsets , grid_offsets = grid_offsets , ) return constraint","title":"size_relative_to"},{"location":"api/public/SimulationVolume/","text":"fdtdx.SimulationVolume Bases: UniformMaterialObject Background material for the entire simulation volume. Defines the default material properties for the simulation background. Usually represents air/vacuum with \u03b5\u1d63=1.0 and \u03bc\u1d63=1.0.","title":"fdtdx.SimulationVolume"},{"location":"api/public/SimulationVolume/#fdtdxsimulationvolume","text":"","title":"fdtdx.SimulationVolume"},{"location":"api/public/SimulationVolume/#fdtdx.SimulationVolume","text":"Bases: UniformMaterialObject Background material for the entire simulation volume. Defines the default material properties for the simulation background. Usually represents air/vacuum with \u03b5\u1d63=1.0 and \u03bc\u1d63=1.0.","title":"SimulationVolume"},{"location":"api/public/SingleFrequencyProfile/","text":"fdtdx.SingleFrequencyProfile Bases: TemporalProfile Simple sinusoidal temporal profile at a single frequency.","title":"fdtdx.SingleFrequencyProfile"},{"location":"api/public/SingleFrequencyProfile/#fdtdxsinglefrequencyprofile","text":"","title":"fdtdx.SingleFrequencyProfile"},{"location":"api/public/SingleFrequencyProfile/#fdtdx.SingleFrequencyProfile","text":"Bases: TemporalProfile Simple sinusoidal temporal profile at a single frequency.","title":"SingleFrequencyProfile"},{"location":"api/public/SizeConstraint/","text":"fdtdx.SizeConstraint dataclass SizeConstraint ( * , object : SimulationObject , other_object : SimulationObject , axes : tuple [ int , ... ], other_axes : tuple [ int , ... ], proportions : tuple [ float , ... ], offsets : tuple [ float , ... ], grid_offsets : tuple [ int , ... ] ) Defines a size relationship between two simulation objects. A constraint that sets the size of one object relative to another, with optional proportions and offsets. Used to specify how objects should be sized relative to each other in the simulation. Attributes: object ( SimulationObject ) \u2013 The \"child\" object whose size is being adjusted other_object ( SimulationObject ) \u2013 The \"parent\" object that serves as reference axes ( tuple [ int , ...] ) \u2013 Which axes of the child to constrain other_axes ( tuple [ int , ...] ) \u2013 Which axes of the parent to reference proportions ( tuple [ float , ...] ) \u2013 Size multipliers relative to parent offsets ( tuple [ float , ...] ) \u2013 Additional real-space size offsets grid_offsets ( tuple [ int , ...] ) \u2013 Additional grid-space size offsets","title":"fdtdx.SizeConstraint"},{"location":"api/public/SizeConstraint/#fdtdxsizeconstraint","text":"","title":"fdtdx.SizeConstraint"},{"location":"api/public/SizeConstraint/#fdtdx.SizeConstraint","text":"SizeConstraint ( * , object : SimulationObject , other_object : SimulationObject , axes : tuple [ int , ... ], other_axes : tuple [ int , ... ], proportions : tuple [ float , ... ], offsets : tuple [ float , ... ], grid_offsets : tuple [ int , ... ] ) Defines a size relationship between two simulation objects. A constraint that sets the size of one object relative to another, with optional proportions and offsets. Used to specify how objects should be sized relative to each other in the simulation. Attributes: object ( SimulationObject ) \u2013 The \"child\" object whose size is being adjusted other_object ( SimulationObject ) \u2013 The \"parent\" object that serves as reference axes ( tuple [ int , ...] ) \u2013 Which axes of the child to constrain other_axes ( tuple [ int , ...] ) \u2013 Which axes of the parent to reference proportions ( tuple [ float , ...] ) \u2013 Size multipliers relative to parent offsets ( tuple [ float , ...] ) \u2013 Additional real-space size offsets grid_offsets ( tuple [ int , ...] ) \u2013 Additional grid-space size offsets","title":"SizeConstraint"},{"location":"api/public/SizeExtensionConstraint/","text":"fdtdx.SizeExtensionConstraint dataclass SizeExtensionConstraint ( * , object : SimulationObject , other_object : Optional [ SimulationObject ], axis : int , direction : Literal [ \"+\" , \"-\" ], other_position : float , offset : float , grid_offset : int ) Defines how an object extends toward another object or boundary. A constraint that extends one object's size until it reaches another object or the simulation boundary. Can extend in positive or negative direction along an axis. Attributes: object ( SimulationObject ) \u2013 The object being extended other_object ( Optional [ SimulationObject ] ) \u2013 Optional target object to extend to axis ( int ) \u2013 Which axis to extend along direction ( Literal ['+', '-'] ) \u2013 Direction to extend ('+' or '-') other_position ( float ) \u2013 Relative position on target (-1 to 1) offset ( float ) \u2013 Additional real-space offset grid_offset ( int ) \u2013 Additional grid-space offset","title":"fdtdx.SizeExtensionConstraint"},{"location":"api/public/SizeExtensionConstraint/#fdtdxsizeextensionconstraint","text":"","title":"fdtdx.SizeExtensionConstraint"},{"location":"api/public/SizeExtensionConstraint/#fdtdx.SizeExtensionConstraint","text":"SizeExtensionConstraint ( * , object : SimulationObject , other_object : Optional [ SimulationObject ], axis : int , direction : Literal [ \"+\" , \"-\" ], other_position : float , offset : float , grid_offset : int ) Defines how an object extends toward another object or boundary. A constraint that extends one object's size until it reaches another object or the simulation boundary. Can extend in positive or negative direction along an axis. Attributes: object ( SimulationObject ) \u2013 The object being extended other_object ( Optional [ SimulationObject ] ) \u2013 Optional target object to extend to axis ( int ) \u2013 Which axis to extend along direction ( Literal ['+', '-'] ) \u2013 Direction to extend ('+' or '-') other_position ( float ) \u2013 Relative position on target (-1 to 1) offset ( float ) \u2013 Additional real-space offset grid_offset ( int ) \u2013 Additional grid-space offset","title":"SizeExtensionConstraint"},{"location":"api/public/Sphere/","text":"fdtdx.Sphere Bases: StaticMultiMaterialObject A sphere or ellipsoid object with configurable properties. This class represents a sphere or ellipsoid with customizable radius/radii and material. When all three radii are equal, the shape is a perfect sphere. Attributes: radius ( float ) \u2013 The default radius of the sphere in meter (used if specific axis radii are not provided). material_name ( str ) \u2013 Name of the sphere material in the materials dictionary to be used for the object. radius_x ( float | None ) \u2013 The radius along the x-axis in meter. If none, use radius. Defaults to None. radius_y ( float | None ) \u2013 The radius along the y-axis in meter. If none, use radius. Defaults to None. radius_z ( float | None ) \u2013 The radius along the z-axis in meter. If none, use radius. Defaults to None. get_voxel_mask_for_shape get_voxel_mask_for_shape () -> jax . Array Generates a voxel mask for a sphere or ellipsoid shape. Returns: Array \u2013 jax.Array: Boolean mask where True indicates voxels inside the sphere/ellipsoid. Source code in src/fdtdx/objects/static_material/sphere.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def get_voxel_mask_for_shape ( self ) -> jax . Array : \"\"\"Generates a voxel mask for a sphere or ellipsoid shape. Returns: jax.Array: Boolean mask where True indicates voxels inside the sphere/ellipsoid. \"\"\" # Get dimensions x_dim , y_dim , z_dim = self . grid_shape # Define center of the ellipsoid center = ( x_dim / 2 , y_dim / 2 , z_dim / 2 ) # Determine the radii for each axis radius_x = self . radius_x if self . radius_x is not None else self . radius radius_y = self . radius_y if self . radius_y is not None else self . radius radius_z = self . radius_z if self . radius_z is not None else self . radius # Convert radii to grid units grid_radius_x = radius_x / self . _config . resolution grid_radius_y = radius_y / self . _config . resolution grid_radius_z = radius_z / self . _config . resolution # Create 3D grid x , y , z = jnp . meshgrid ( jnp . arange ( x_dim ), jnp . arange ( y_dim ), jnp . arange ( z_dim ), indexing = \"ij\" ) # Calculate normalized squared distances for each dimension using the ellipsoid equation x_term = (( x - center [ 0 ] + 0.5 ) / grid_radius_x ) ** 2 y_term = (( y - center [ 1 ] + 0.5 ) / grid_radius_y ) ** 2 z_term = (( z - center [ 2 ] + 0.5 ) / grid_radius_z ) ** 2 # Create mask based on ellipsoid equation: points inside if x^2/a^2 + y^2/b^2 + z^2/c^2 < 1 mask = ( x_term + y_term + z_term ) < 1 return mask","title":"fdtdx.Sphere"},{"location":"api/public/Sphere/#fdtdxsphere","text":"","title":"fdtdx.Sphere"},{"location":"api/public/Sphere/#fdtdx.Sphere","text":"Bases: StaticMultiMaterialObject A sphere or ellipsoid object with configurable properties. This class represents a sphere or ellipsoid with customizable radius/radii and material. When all three radii are equal, the shape is a perfect sphere. Attributes: radius ( float ) \u2013 The default radius of the sphere in meter (used if specific axis radii are not provided). material_name ( str ) \u2013 Name of the sphere material in the materials dictionary to be used for the object. radius_x ( float | None ) \u2013 The radius along the x-axis in meter. If none, use radius. Defaults to None. radius_y ( float | None ) \u2013 The radius along the y-axis in meter. If none, use radius. Defaults to None. radius_z ( float | None ) \u2013 The radius along the z-axis in meter. If none, use radius. Defaults to None.","title":"Sphere"},{"location":"api/public/Sphere/#fdtdx.Sphere.get_voxel_mask_for_shape","text":"get_voxel_mask_for_shape () -> jax . Array Generates a voxel mask for a sphere or ellipsoid shape. Returns: Array \u2013 jax.Array: Boolean mask where True indicates voxels inside the sphere/ellipsoid. Source code in src/fdtdx/objects/static_material/sphere.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def get_voxel_mask_for_shape ( self ) -> jax . Array : \"\"\"Generates a voxel mask for a sphere or ellipsoid shape. Returns: jax.Array: Boolean mask where True indicates voxels inside the sphere/ellipsoid. \"\"\" # Get dimensions x_dim , y_dim , z_dim = self . grid_shape # Define center of the ellipsoid center = ( x_dim / 2 , y_dim / 2 , z_dim / 2 ) # Determine the radii for each axis radius_x = self . radius_x if self . radius_x is not None else self . radius radius_y = self . radius_y if self . radius_y is not None else self . radius radius_z = self . radius_z if self . radius_z is not None else self . radius # Convert radii to grid units grid_radius_x = radius_x / self . _config . resolution grid_radius_y = radius_y / self . _config . resolution grid_radius_z = radius_z / self . _config . resolution # Create 3D grid x , y , z = jnp . meshgrid ( jnp . arange ( x_dim ), jnp . arange ( y_dim ), jnp . arange ( z_dim ), indexing = \"ij\" ) # Calculate normalized squared distances for each dimension using the ellipsoid equation x_term = (( x - center [ 0 ] + 0.5 ) / grid_radius_x ) ** 2 y_term = (( y - center [ 1 ] + 0.5 ) / grid_radius_y ) ** 2 z_term = (( z - center [ 2 ] + 0.5 ) / grid_radius_z ) ** 2 # Create mask based on ellipsoid equation: points inside if x^2/a^2 + y^2/b^2 + z^2/c^2 < 1 mask = ( x_term + y_term + z_term ) < 1 return mask","title":"get_voxel_mask_for_shape"},{"location":"api/public/StandardToCustomRange/","text":"fdtdx.StandardToCustomRange Bases: SameShapeTypeParameterTransform Maps standard [0,1] range to custom range [min_value, max_value]. Linearly maps values from [0,1] to a custom range specified by min_value and max_value parameters. Attributes: min_value ( float ) \u2013 Minimum value of target range. Defaults to zero. max_value ( float ) \u2013 Maximum value of target range. Defaults to one.","title":"fdtdx.StandardToCustomRange"},{"location":"api/public/StandardToCustomRange/#fdtdxstandardtocustomrange","text":"","title":"fdtdx.StandardToCustomRange"},{"location":"api/public/StandardToCustomRange/#fdtdx.StandardToCustomRange","text":"Bases: SameShapeTypeParameterTransform Maps standard [0,1] range to custom range [min_value, max_value]. Linearly maps values from [0,1] to a custom range specified by min_value and max_value parameters. Attributes: min_value ( float ) \u2013 Minimum value of target range. Defaults to zero. max_value ( float ) \u2013 Maximum value of target range. Defaults to one.","title":"StandardToCustomRange"},{"location":"api/public/StandardToPlusOneMinusOneRange/","text":"fdtdx.StandardToPlusOneMinusOneRange Bases: StandardToCustomRange Maps standard [0,1] range to [-1,1] range. Special case of StandardToCustomRange that maps to [-1,1] range. Used for symmetric value ranges around zero.","title":"fdtdx.StandardToPlusOneMinusOneRange"},{"location":"api/public/StandardToPlusOneMinusOneRange/#fdtdxstandardtoplusoneminusonerange","text":"","title":"fdtdx.StandardToPlusOneMinusOneRange"},{"location":"api/public/StandardToPlusOneMinusOneRange/#fdtdx.StandardToPlusOneMinusOneRange","text":"Bases: StandardToCustomRange Maps standard [0,1] range to [-1,1] range. Special case of StandardToCustomRange that maps to [-1,1] range. Used for symmetric value ranges around zero.","title":"StandardToPlusOneMinusOneRange"},{"location":"api/public/SubpixelSmoothedProjection/","text":"fdtdx.SubpixelSmoothedProjection Bases: SameShapeTypeParameterTransform This function is adapted from the Meep repository: https://github.com/NanoComp/meep/blob/master/python/adjoint/filters.py The details of this projection are described in the paper by Alec Hammond: https://arxiv.org/pdf/2503.20189 Project using subpixel smoothing, which allows for \u03b2\u2192\u221e. This technique integrates out the discontinuity within the projection function, allowing the user to smoothly increase \u03b2 from 0 to \u221e without losing the gradient. Effectively, a level set is created, and from this level set, first-order subpixel smoothing is applied to the interfaces (if any are present). In order for this to work, the input array must already be smooth (e.g. by filtering). While the original approach involves numerical quadrature, this approach performs a \"trick\" by assuming that the user is always infinitely projecting (\u03b2=\u221e). In this case, the expensive quadrature simplifies to an analytic fill-factor expression. When to use this fill factor requires some careful logic. For one, we want to make sure that the user can indeed project at any level (not just infinity). So in these cases, we simply check if in interface is within the pixel. If not, we revert to the standard filter plus project technique. If there is an interface, we want to make sure the derivative remains continuous both as the interface leaves the cell, and as it crosses the center. To ensure this, we need to account for the different possibilities. Attributes: projection_midpoint ( float ) \u2013 midpoint of the tanh projection. Defaults to 0.5 Notes The call method requires a beta parameter as a keyword argument passed to the parameter transformation","title":"fdtdx.SubpixelSmoothedProjection"},{"location":"api/public/SubpixelSmoothedProjection/#fdtdxsubpixelsmoothedprojection","text":"","title":"fdtdx.SubpixelSmoothedProjection"},{"location":"api/public/SubpixelSmoothedProjection/#fdtdx.SubpixelSmoothedProjection","text":"Bases: SameShapeTypeParameterTransform This function is adapted from the Meep repository: https://github.com/NanoComp/meep/blob/master/python/adjoint/filters.py The details of this projection are described in the paper by Alec Hammond: https://arxiv.org/pdf/2503.20189 Project using subpixel smoothing, which allows for \u03b2\u2192\u221e. This technique integrates out the discontinuity within the projection function, allowing the user to smoothly increase \u03b2 from 0 to \u221e without losing the gradient. Effectively, a level set is created, and from this level set, first-order subpixel smoothing is applied to the interfaces (if any are present). In order for this to work, the input array must already be smooth (e.g. by filtering). While the original approach involves numerical quadrature, this approach performs a \"trick\" by assuming that the user is always infinitely projecting (\u03b2=\u221e). In this case, the expensive quadrature simplifies to an analytic fill-factor expression. When to use this fill factor requires some careful logic. For one, we want to make sure that the user can indeed project at any level (not just infinity). So in these cases, we simply check if in interface is within the pixel. If not, we revert to the standard filter plus project technique. If there is an interface, we want to make sure the derivative remains continuous both as the interface leaves the cell, and as it crosses the center. To ensure this, we need to account for the different possibilities. Attributes: projection_midpoint ( float ) \u2013 midpoint of the tanh projection. Defaults to 0.5 Notes The call method requires a beta parameter as a keyword argument passed to the parameter transformation","title":"SubpixelSmoothedProjection"},{"location":"api/public/TanhProjection/","text":"fdtdx.TanhProjection Bases: SameShapeTypeParameterTransform Tanh projection filter. This needs the steepness parameter \\(\\beta\\) as a keyword-argument in apply_params Ref: F. Wang, B. S. Lazarov, & O. Sigmund, On projection methods, convergence and robust formulations in topology optimization. Structural and Multidisciplinary Optimization, 43(6), pp. 767-784 (2011). Attributes: projection_midpoint ( float ) \u2013 Midpoint of the TanhProjection. Defaults to 0.5. Notes The call method requires a beta parameter as a keyword argument passed to the parameter transformation","title":"fdtdx.TanhProjection"},{"location":"api/public/TanhProjection/#fdtdxtanhprojection","text":"","title":"fdtdx.TanhProjection"},{"location":"api/public/TanhProjection/#fdtdx.TanhProjection","text":"Bases: SameShapeTypeParameterTransform Tanh projection filter. This needs the steepness parameter \\(\\beta\\) as a keyword-argument in apply_params Ref: F. Wang, B. S. Lazarov, & O. Sigmund, On projection methods, convergence and robust formulations in topology optimization. Structural and Multidisciplinary Optimization, 43(6), pp. 767-784 (2011). Attributes: projection_midpoint ( float ) \u2013 Midpoint of the TanhProjection. Defaults to 0.5. Notes The call method requires a beta parameter as a keyword argument passed to the parameter transformation","title":"TanhProjection"},{"location":"api/public/TreeClass/","text":"fdtdx.TreeClass Bases: TreeClass Extended tree class with improved attribute setting functionality. Extends TreeClass to provide more flexible attribute setting capabilities, particularly for handling non-recursive attribute updates. at property at : ExtendedTreeClassIndexer Gets the extended indexer for this tree. Returns: ExtendedTreeClassIndexer ( ExtendedTreeClassIndexer ) \u2013 Indexer that preserves type information aset aset ( attr_name : str , val : Any , create_new_ok : bool = False ) -> Self Sets an attribute of this class. In contrast to the classical .at[].set(), this method updates the class attribute directly and does not only operate on jax pytree leaf nodes. Instead, replaces the full attribute with the new value. The attribute can either be the attribute name of this class, or for nested classes it can also be the attribute name of a class, which itself is an attribute of this class. The syntax for this operation could look like this: \"a->b->[0]->['name']\". Here, the current class has an attribute a, which has an attribute b, which is a list, which we index at index 0, which is an element of type dictionary, which we index using the dictionary key 'name'. Note that dictionary keys cannot contain square brackets or single quotes (even if they are escaped). Parameters: attr_name ( str ) \u2013 Name of attribute to set val ( Any ) \u2013 Value to set the attribute to create_new_ok ( bool , default: False ) \u2013 If false (default), throw an error if the attribute does not exist. If true, creates a new attribute if the attribute name does not exist yet. Returns: Self ( Self ) \u2013 Updated instance with new attribute value Source code in src/fdtdx/core/jax/pytrees.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def aset ( self , attr_name : str , val : Any , create_new_ok : bool = False , ) -> Self : \"\"\"Sets an attribute of this class. In contrast to the classical .at[].set(), this method updates the class attribute directly and does not only operate on jax pytree leaf nodes. Instead, replaces the full attribute with the new value. The attribute can either be the attribute name of this class, or for nested classes it can also be the attribute name of a class, which itself is an attribute of this class. The syntax for this operation could look like this: \"a->b->[0]->['name']\". Here, the current class has an attribute a, which has an attribute b, which is a list, which we index at index 0, which is an element of type dictionary, which we index using the dictionary key 'name'. Note that dictionary keys cannot contain square brackets or single quotes (even if they are escaped). Args: attr_name (str): Name of attribute to set val (Any): Value to set the attribute to create_new_ok (bool, optional): If false (default), throw an error if the attribute does not exist. If true, creates a new attribute if the attribute name does not exist yet. Returns: Self: Updated instance with new attribute value \"\"\" # parse operations ops = self . _parse_operations ( attr_name ) # find final attribute and save intermediate attributes attr_list = [ self ] current_parent = self for idx , ( op , op_type ) in enumerate ( ops ): if op_type == \"attribute\" : if not safe_hasattr ( current_parent , op ): if idx != len ( ops ) - 1 or not create_new_ok : raise Exception ( f \"Attribute: { op } does not exist for { current_parent . __class__ } \" ) current_parent = None else : current_parent = getattr ( current_parent , op ) elif op_type == \"index\" : if \"__getitem__\" not in dir ( current_parent ): raise Exception ( f \" { current_parent . __class__ } does not implement __getitem__\" ) current_parent = current_parent [ int ( op )] # type: ignore elif op_type == \"key\" : if \"__getitem__\" not in dir ( current_parent ): raise Exception ( f \" { current_parent . __class__ } does not implement __getitem__\" ) if op not in current_parent : # type: ignore if idx != len ( ops ) - 1 or not create_new_ok : raise Exception ( f \"Key: { op } does not exist for { current_parent } \" ) current_parent = None else : current_parent = current_parent [ op ] # type: ignore else : raise Exception ( f \"Invalid operation type: { op_type } . This is an internal bug!\" ) if idx != len ( ops ) - 1 : attr_list . append ( current_parent ) # type: ignore # from bottom-up set attributes and update cur_attr = val for idx in list ( range ( len ( attr_list )))[:: - 1 ]: op , op_type = ops [ idx ] current_parent = attr_list [ idx ] if op_type == \"attribute\" : if not isinstance ( current_parent , TreeClass ): raise Exception ( f \"Can only set attribute on ExtendedTreeClass, but got { current_parent . __class__ } \" ) _ , cur_attr = current_parent . at [ \"_aset\" ]( op , cur_attr ) elif op_type == \"index\" : if \"__setitem__\" not in dir ( current_parent ): raise Exception ( f \"Can only update by index if __setitem__ is implemented, but got { current_parent . __class__ } \" ) cpy = current_parent . copy () # type: ignore cpy [ int ( op )] = cur_attr # type: ignore cur_attr = cpy elif op_type == \"key\" : if \"__setitem__\" not in dir ( current_parent ): raise Exception ( f \"Can only update by index if __setitem__ is implemented, but got { current_parent . __class__ } \" ) cpy = current_parent . copy () # type: ignore cpy [ op ] = cur_attr # type: ignore cur_attr = cpy else : raise Exception ( f \"Invalid operation type: { op_type } . This is an internal bug!\" ) assert cur_attr . __class__ == self . __class__ return cur_attr","title":"fdtdx.TreeClass"},{"location":"api/public/TreeClass/#fdtdxtreeclass","text":"","title":"fdtdx.TreeClass"},{"location":"api/public/TreeClass/#fdtdx.TreeClass","text":"Bases: TreeClass Extended tree class with improved attribute setting functionality. Extends TreeClass to provide more flexible attribute setting capabilities, particularly for handling non-recursive attribute updates.","title":"TreeClass"},{"location":"api/public/TreeClass/#fdtdx.TreeClass.at","text":"at : ExtendedTreeClassIndexer Gets the extended indexer for this tree. Returns: ExtendedTreeClassIndexer ( ExtendedTreeClassIndexer ) \u2013 Indexer that preserves type information","title":"at"},{"location":"api/public/TreeClass/#fdtdx.TreeClass.aset","text":"aset ( attr_name : str , val : Any , create_new_ok : bool = False ) -> Self Sets an attribute of this class. In contrast to the classical .at[].set(), this method updates the class attribute directly and does not only operate on jax pytree leaf nodes. Instead, replaces the full attribute with the new value. The attribute can either be the attribute name of this class, or for nested classes it can also be the attribute name of a class, which itself is an attribute of this class. The syntax for this operation could look like this: \"a->b->[0]->['name']\". Here, the current class has an attribute a, which has an attribute b, which is a list, which we index at index 0, which is an element of type dictionary, which we index using the dictionary key 'name'. Note that dictionary keys cannot contain square brackets or single quotes (even if they are escaped). Parameters: attr_name ( str ) \u2013 Name of attribute to set val ( Any ) \u2013 Value to set the attribute to create_new_ok ( bool , default: False ) \u2013 If false (default), throw an error if the attribute does not exist. If true, creates a new attribute if the attribute name does not exist yet. Returns: Self ( Self ) \u2013 Updated instance with new attribute value Source code in src/fdtdx/core/jax/pytrees.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def aset ( self , attr_name : str , val : Any , create_new_ok : bool = False , ) -> Self : \"\"\"Sets an attribute of this class. In contrast to the classical .at[].set(), this method updates the class attribute directly and does not only operate on jax pytree leaf nodes. Instead, replaces the full attribute with the new value. The attribute can either be the attribute name of this class, or for nested classes it can also be the attribute name of a class, which itself is an attribute of this class. The syntax for this operation could look like this: \"a->b->[0]->['name']\". Here, the current class has an attribute a, which has an attribute b, which is a list, which we index at index 0, which is an element of type dictionary, which we index using the dictionary key 'name'. Note that dictionary keys cannot contain square brackets or single quotes (even if they are escaped). Args: attr_name (str): Name of attribute to set val (Any): Value to set the attribute to create_new_ok (bool, optional): If false (default), throw an error if the attribute does not exist. If true, creates a new attribute if the attribute name does not exist yet. Returns: Self: Updated instance with new attribute value \"\"\" # parse operations ops = self . _parse_operations ( attr_name ) # find final attribute and save intermediate attributes attr_list = [ self ] current_parent = self for idx , ( op , op_type ) in enumerate ( ops ): if op_type == \"attribute\" : if not safe_hasattr ( current_parent , op ): if idx != len ( ops ) - 1 or not create_new_ok : raise Exception ( f \"Attribute: { op } does not exist for { current_parent . __class__ } \" ) current_parent = None else : current_parent = getattr ( current_parent , op ) elif op_type == \"index\" : if \"__getitem__\" not in dir ( current_parent ): raise Exception ( f \" { current_parent . __class__ } does not implement __getitem__\" ) current_parent = current_parent [ int ( op )] # type: ignore elif op_type == \"key\" : if \"__getitem__\" not in dir ( current_parent ): raise Exception ( f \" { current_parent . __class__ } does not implement __getitem__\" ) if op not in current_parent : # type: ignore if idx != len ( ops ) - 1 or not create_new_ok : raise Exception ( f \"Key: { op } does not exist for { current_parent } \" ) current_parent = None else : current_parent = current_parent [ op ] # type: ignore else : raise Exception ( f \"Invalid operation type: { op_type } . This is an internal bug!\" ) if idx != len ( ops ) - 1 : attr_list . append ( current_parent ) # type: ignore # from bottom-up set attributes and update cur_attr = val for idx in list ( range ( len ( attr_list )))[:: - 1 ]: op , op_type = ops [ idx ] current_parent = attr_list [ idx ] if op_type == \"attribute\" : if not isinstance ( current_parent , TreeClass ): raise Exception ( f \"Can only set attribute on ExtendedTreeClass, but got { current_parent . __class__ } \" ) _ , cur_attr = current_parent . at [ \"_aset\" ]( op , cur_attr ) elif op_type == \"index\" : if \"__setitem__\" not in dir ( current_parent ): raise Exception ( f \"Can only update by index if __setitem__ is implemented, but got { current_parent . __class__ } \" ) cpy = current_parent . copy () # type: ignore cpy [ int ( op )] = cur_attr # type: ignore cur_attr = cpy elif op_type == \"key\" : if \"__setitem__\" not in dir ( current_parent ): raise Exception ( f \"Can only update by index if __setitem__ is implemented, but got { current_parent . __class__ } \" ) cpy = current_parent . copy () # type: ignore cpy [ op ] = cur_attr # type: ignore cur_attr = cpy else : raise Exception ( f \"Invalid operation type: { op_type } . This is an internal bug!\" ) assert cur_attr . __class__ == self . __class__ return cur_attr","title":"aset"},{"location":"api/public/UniformMaterialObject/","text":"fdtdx.UniformMaterialObject Bases: OrderableObject","title":"fdtdx.UniformMaterialObject"},{"location":"api/public/UniformMaterialObject/#fdtdxuniformmaterialobject","text":"","title":"fdtdx.UniformMaterialObject"},{"location":"api/public/UniformMaterialObject/#fdtdx.UniformMaterialObject","text":"Bases: OrderableObject","title":"UniformMaterialObject"},{"location":"api/public/UniformPlaneSource/","text":"fdtdx.UniformPlaneSource Bases: LinearlyPolarizedPlaneSource","title":"fdtdx.UniformPlaneSource"},{"location":"api/public/UniformPlaneSource/#fdtdxuniformplanesource","text":"","title":"fdtdx.UniformPlaneSource"},{"location":"api/public/UniformPlaneSource/#fdtdx.UniformPlaneSource","text":"Bases: LinearlyPolarizedPlaneSource","title":"UniformPlaneSource"},{"location":"api/public/WaveCharacter/","text":"fdtdx.WaveCharacter Bases: TreeClass Class describing a wavelength/period/frequency in free space. Importantly, the wave characteristic conversion is based on a free space wave when using the wavelength (For conversion, a refractive index of 1 is used). Attributes: phase_shift ( float ) \u2013 Phase shift in radians. Defaults to 0. period ( float | None ) \u2013 Optional period in seconds. Mutually exclusive with wavelength and frequency. Defaults to None. wavelength ( float | None ) \u2013 Optional wavelength in meters for free space propagation. Mutually exclusive with period and frequency. Defaults to None. frequency ( float | None ) \u2013 Optional frequency in Hz. Mutually exclusive with period and wavelength.","title":"fdtdx.WaveCharacter"},{"location":"api/public/WaveCharacter/#fdtdxwavecharacter","text":"","title":"fdtdx.WaveCharacter"},{"location":"api/public/WaveCharacter/#fdtdx.WaveCharacter","text":"Bases: TreeClass Class describing a wavelength/period/frequency in free space. Importantly, the wave characteristic conversion is based on a free space wave when using the wavelength (For conversion, a refractive index of 1 is used). Attributes: phase_shift ( float ) \u2013 Phase shift in radians. Defaults to 0. period ( float | None ) \u2013 Optional period in seconds. Mutually exclusive with wavelength and frequency. Defaults to None. wavelength ( float | None ) \u2013 Optional wavelength in meters for free space propagation. Mutually exclusive with period and frequency. Defaults to None. frequency ( float | None ) \u2013 Optional frequency in Hz. Mutually exclusive with period and wavelength.","title":"WaveCharacter"},{"location":"api/public/apply_params/","text":"fdtdx.apply_params apply_params ( arrays : ArrayContainer , objects : ObjectContainer , params : ParameterContainer , key : Array , ** transform_kwargs ) -> tuple [ ArrayContainer , ObjectContainer , dict [ str , Any ]] Applies parameters to devices and updates source states. Parameters: arrays ( ArrayContainer ) \u2013 Container with field arrays objects ( ObjectContainer ) \u2013 Container with simulation objects params ( ParameterContainer ) \u2013 Container with device parameters key ( Array ) \u2013 JAX random key for source updates **transform_kwargs \u2013 Keyword arguments passed to the parameter transformation. Returns: tuple[ArrayContainer, ObjectContainer, dict[str, Any]]: A tuple containing: - Updated ArrayContainer with applied device parameters - Updated ObjectContainer with new source states - Dictionary with parameter application info Source code in src/fdtdx/fdtd/initialization.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def apply_params ( arrays : ArrayContainer , objects : ObjectContainer , params : ParameterContainer , key : jax . Array , ** transform_kwargs , ) -> tuple [ ArrayContainer , ObjectContainer , dict [ str , Any ]]: \"\"\"Applies parameters to devices and updates source states. Args: arrays (ArrayContainer): Container with field arrays objects (ObjectContainer): Container with simulation objects params (ParameterContainer): Container with device parameters key (jax.Array): JAX random key for source updates **transform_kwargs: Keyword arguments passed to the parameter transformation. Returns: tuple[ArrayContainer, ObjectContainer, dict[str, Any]]: A tuple containing: - Updated ArrayContainer with applied device parameters - Updated ObjectContainer with new source states - Dictionary with parameter application info \"\"\" info = {} # apply parameter to devices for device in objects . devices : cur_material_indices = device ( params [ device . name ], expand_to_sim_grid = True , ** transform_kwargs ) allowed_perm_list = compute_allowed_permittivities ( device . materials ) if device . output_type == ParameterType . CONTINUOUS : first_term = ( 1 - cur_material_indices ) * ( 1 / allowed_perm_list [ 0 ]) second_term = cur_material_indices * ( 1 / allowed_perm_list [ 1 ]) new_perm_slice = first_term + second_term else : new_perm_slice = jnp . asarray ( allowed_perm_list )[ cur_material_indices . astype ( jnp . int32 )] new_perm_slice = straight_through_estimator ( cur_material_indices , new_perm_slice ) new_perm_slice = 1 / new_perm_slice new_perm = arrays . inv_permittivities . at [ * device . grid_slice ] . set ( new_perm_slice ) arrays = arrays . at [ \"inv_permittivities\" ] . set ( new_perm ) # apply random key to sources new_objects = [] for obj in objects . object_list : key , subkey = jax . random . split ( key ) new_obj = obj . apply ( key = subkey , inv_permittivities = jax . lax . stop_gradient ( arrays . inv_permittivities ), inv_permeabilities = jax . lax . stop_gradient ( arrays . inv_permeabilities ), ) new_objects . append ( new_obj ) new_objects = ObjectContainer ( object_list = new_objects , volume_idx = objects . volume_idx , ) return arrays , new_objects , info","title":"fdtdx.apply_params"},{"location":"api/public/apply_params/#fdtdxapply_params","text":"","title":"fdtdx.apply_params"},{"location":"api/public/apply_params/#fdtdx.apply_params","text":"apply_params ( arrays : ArrayContainer , objects : ObjectContainer , params : ParameterContainer , key : Array , ** transform_kwargs ) -> tuple [ ArrayContainer , ObjectContainer , dict [ str , Any ]] Applies parameters to devices and updates source states. Parameters: arrays ( ArrayContainer ) \u2013 Container with field arrays objects ( ObjectContainer ) \u2013 Container with simulation objects params ( ParameterContainer ) \u2013 Container with device parameters key ( Array ) \u2013 JAX random key for source updates **transform_kwargs \u2013 Keyword arguments passed to the parameter transformation. Returns: tuple[ArrayContainer, ObjectContainer, dict[str, Any]]: A tuple containing: - Updated ArrayContainer with applied device parameters - Updated ObjectContainer with new source states - Dictionary with parameter application info Source code in src/fdtdx/fdtd/initialization.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def apply_params ( arrays : ArrayContainer , objects : ObjectContainer , params : ParameterContainer , key : jax . Array , ** transform_kwargs , ) -> tuple [ ArrayContainer , ObjectContainer , dict [ str , Any ]]: \"\"\"Applies parameters to devices and updates source states. Args: arrays (ArrayContainer): Container with field arrays objects (ObjectContainer): Container with simulation objects params (ParameterContainer): Container with device parameters key (jax.Array): JAX random key for source updates **transform_kwargs: Keyword arguments passed to the parameter transformation. Returns: tuple[ArrayContainer, ObjectContainer, dict[str, Any]]: A tuple containing: - Updated ArrayContainer with applied device parameters - Updated ObjectContainer with new source states - Dictionary with parameter application info \"\"\" info = {} # apply parameter to devices for device in objects . devices : cur_material_indices = device ( params [ device . name ], expand_to_sim_grid = True , ** transform_kwargs ) allowed_perm_list = compute_allowed_permittivities ( device . materials ) if device . output_type == ParameterType . CONTINUOUS : first_term = ( 1 - cur_material_indices ) * ( 1 / allowed_perm_list [ 0 ]) second_term = cur_material_indices * ( 1 / allowed_perm_list [ 1 ]) new_perm_slice = first_term + second_term else : new_perm_slice = jnp . asarray ( allowed_perm_list )[ cur_material_indices . astype ( jnp . int32 )] new_perm_slice = straight_through_estimator ( cur_material_indices , new_perm_slice ) new_perm_slice = 1 / new_perm_slice new_perm = arrays . inv_permittivities . at [ * device . grid_slice ] . set ( new_perm_slice ) arrays = arrays . at [ \"inv_permittivities\" ] . set ( new_perm ) # apply random key to sources new_objects = [] for obj in objects . object_list : key , subkey = jax . random . split ( key ) new_obj = obj . apply ( key = subkey , inv_permittivities = jax . lax . stop_gradient ( arrays . inv_permittivities ), inv_permeabilities = jax . lax . stop_gradient ( arrays . inv_permeabilities ), ) new_objects . append ( new_obj ) new_objects = ObjectContainer ( object_list = new_objects , volume_idx = objects . volume_idx , ) return arrays , new_objects , info","title":"apply_params"},{"location":"api/public/autoinit/","text":"fdtdx.autoinit autoinit ( klass : type [ T ]) -> type [ T ] Wrapper around tc.autoinit that preserves parameter requirement information Source code in src/fdtdx/core/jax/pytrees.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 @dataclass_transform ( field_specifiers = ( Field , tc_field , frozen_field , frozen_private_field , field , private_field ), kw_only_default = True , ) def autoinit ( klass : type [ T ]) -> type [ T ]: \"\"\"Wrapper around tc.autoinit that preserves parameter requirement information\"\"\" return ( klass # if the class already has a user-defined __init__ method # then return the class as is without any modification if \"__init__\" in vars ( klass ) # first convert the current class hints to fields # then build the __init__ method from the fields of the current class # and any base classes that are decorated with `autoinit` else build_init_method ( convert_hints_to_fields ( klass )) )","title":"fdtdx.autoinit"},{"location":"api/public/autoinit/#fdtdxautoinit","text":"","title":"fdtdx.autoinit"},{"location":"api/public/autoinit/#fdtdx.autoinit","text":"autoinit ( klass : type [ T ]) -> type [ T ] Wrapper around tc.autoinit that preserves parameter requirement information Source code in src/fdtdx/core/jax/pytrees.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 @dataclass_transform ( field_specifiers = ( Field , tc_field , frozen_field , frozen_private_field , field , private_field ), kw_only_default = True , ) def autoinit ( klass : type [ T ]) -> type [ T ]: \"\"\"Wrapper around tc.autoinit that preserves parameter requirement information\"\"\" return ( klass # if the class already has a user-defined __init__ method # then return the class as is without any modification if \"__init__\" in vars ( klass ) # first convert the current class hints to fields # then build the __init__ method from the fields of the current class # and any base classes that are decorated with `autoinit` else build_init_method ( convert_hints_to_fields ( klass )) )","title":"autoinit"},{"location":"api/public/boundary_objects_from_config/","text":"fdtdx.boundary_objects_from_config boundary_objects_from_config ( config : BoundaryConfig , volume : SimulationVolume ) -> tuple [ dict [ str , Union [ PerfectlyMatchedLayer , PeriodicBoundary ] ], list [ PositionConstraint ], ] Creates boundary objects from a boundary configuration. Creates PerfectlyMatchedLayer or PeriodicBoundary objects for all six boundaries (min/max x/y/z) based on the provided configuration. Also generates position constraints to properly place the boundary objects relative to the simulation volume. Parameters: config ( BoundaryConfig ) \u2013 Configuration object containing boundary parameters volume ( SimulationVolume ) \u2013 The main simulation volume object that the boundaries will surround Returns: tuple [ dict [ str , Union [ PerfectlyMatchedLayer , PeriodicBoundary ]], list [ PositionConstraint ]] \u2013 tuple[dict[str, Union[PerfectlyMatchedLayer, PeriodicBoundary]], list[PositionConstraint]]: tuple containing: - dict mapping boundary names ('min_x', 'max_x', etc) to boundary objects - list of PositionConstraint objects for placing the boundaries Source code in src/fdtdx/objects/boundaries/initialization.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def boundary_objects_from_config ( config : BoundaryConfig , volume : SimulationVolume , ) -> tuple [ dict [ str , Union [ PerfectlyMatchedLayer , PeriodicBoundary ]], list [ PositionConstraint ]]: \"\"\"Creates boundary objects from a boundary configuration. Creates PerfectlyMatchedLayer or PeriodicBoundary objects for all six boundaries (min/max x/y/z) based on the provided configuration. Also generates position constraints to properly place the boundary objects relative to the simulation volume. Args: config (BoundaryConfig): Configuration object containing boundary parameters volume (SimulationVolume): The main simulation volume object that the boundaries will surround Returns: tuple[dict[str, Union[PerfectlyMatchedLayer, PeriodicBoundary]], list[PositionConstraint]]: tuple containing: - dict mapping boundary names ('min_x', 'max_x', etc) to boundary objects - list of PositionConstraint objects for placing the boundaries \"\"\" boundaries , constraints = {}, [] thickness_dict = config . get_dict () type_dict = config . get_type_dict () kappa_start_dict = config . get_kappa_dict ( \"kappa_start\" ) kappa_end_dict = config . get_kappa_dict ( \"kappa_end\" ) for kind , thickness in thickness_dict . items (): axis , direction = axis_direction_from_kind ( kind ) boundary_type = type_dict [ kind ] kappa_start , kappa_end = kappa_start_dict [ kind ], kappa_end_dict [ kind ] grid_shape_list : list [ int | None ] = [ None , None , None ] grid_shape_list [ axis ] = thickness if boundary_type == \"pml\" else 1 grid_shape : PartialGridShape3D = tuple ( grid_shape_list ) # type: ignore other_axes = [ 0 , 1 , 2 ] del other_axes [ axis ] if boundary_type == \"pml\" : cur_boundary = PerfectlyMatchedLayer ( axis = axis , partial_grid_shape = grid_shape , kappa_start = kappa_start , kappa_end = kappa_end , direction = direction , ) else : # periodic cur_boundary = PeriodicBoundary ( axis = axis , partial_grid_shape = grid_shape , direction = direction , ) direction_int = - 1 if direction == \"-\" else 1 pos_constraint = cur_boundary . place_relative_to ( volume , axes = ( axis , other_axes [ 0 ], other_axes [ 1 ]), own_positions = ( direction_int , 0 , 0 ), other_positions = ( direction_int , 0 , 0 ), ) boundaries [ kind ] = cur_boundary constraints . append ( pos_constraint ) return boundaries , constraints","title":"fdtdx.boundary_objects_from_config"},{"location":"api/public/boundary_objects_from_config/#fdtdxboundary_objects_from_config","text":"","title":"fdtdx.boundary_objects_from_config"},{"location":"api/public/boundary_objects_from_config/#fdtdx.boundary_objects_from_config","text":"boundary_objects_from_config ( config : BoundaryConfig , volume : SimulationVolume ) -> tuple [ dict [ str , Union [ PerfectlyMatchedLayer , PeriodicBoundary ] ], list [ PositionConstraint ], ] Creates boundary objects from a boundary configuration. Creates PerfectlyMatchedLayer or PeriodicBoundary objects for all six boundaries (min/max x/y/z) based on the provided configuration. Also generates position constraints to properly place the boundary objects relative to the simulation volume. Parameters: config ( BoundaryConfig ) \u2013 Configuration object containing boundary parameters volume ( SimulationVolume ) \u2013 The main simulation volume object that the boundaries will surround Returns: tuple [ dict [ str , Union [ PerfectlyMatchedLayer , PeriodicBoundary ]], list [ PositionConstraint ]] \u2013 tuple[dict[str, Union[PerfectlyMatchedLayer, PeriodicBoundary]], list[PositionConstraint]]: tuple containing: - dict mapping boundary names ('min_x', 'max_x', etc) to boundary objects - list of PositionConstraint objects for placing the boundaries Source code in src/fdtdx/objects/boundaries/initialization.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def boundary_objects_from_config ( config : BoundaryConfig , volume : SimulationVolume , ) -> tuple [ dict [ str , Union [ PerfectlyMatchedLayer , PeriodicBoundary ]], list [ PositionConstraint ]]: \"\"\"Creates boundary objects from a boundary configuration. Creates PerfectlyMatchedLayer or PeriodicBoundary objects for all six boundaries (min/max x/y/z) based on the provided configuration. Also generates position constraints to properly place the boundary objects relative to the simulation volume. Args: config (BoundaryConfig): Configuration object containing boundary parameters volume (SimulationVolume): The main simulation volume object that the boundaries will surround Returns: tuple[dict[str, Union[PerfectlyMatchedLayer, PeriodicBoundary]], list[PositionConstraint]]: tuple containing: - dict mapping boundary names ('min_x', 'max_x', etc) to boundary objects - list of PositionConstraint objects for placing the boundaries \"\"\" boundaries , constraints = {}, [] thickness_dict = config . get_dict () type_dict = config . get_type_dict () kappa_start_dict = config . get_kappa_dict ( \"kappa_start\" ) kappa_end_dict = config . get_kappa_dict ( \"kappa_end\" ) for kind , thickness in thickness_dict . items (): axis , direction = axis_direction_from_kind ( kind ) boundary_type = type_dict [ kind ] kappa_start , kappa_end = kappa_start_dict [ kind ], kappa_end_dict [ kind ] grid_shape_list : list [ int | None ] = [ None , None , None ] grid_shape_list [ axis ] = thickness if boundary_type == \"pml\" else 1 grid_shape : PartialGridShape3D = tuple ( grid_shape_list ) # type: ignore other_axes = [ 0 , 1 , 2 ] del other_axes [ axis ] if boundary_type == \"pml\" : cur_boundary = PerfectlyMatchedLayer ( axis = axis , partial_grid_shape = grid_shape , kappa_start = kappa_start , kappa_end = kappa_end , direction = direction , ) else : # periodic cur_boundary = PeriodicBoundary ( axis = axis , partial_grid_shape = grid_shape , direction = direction , ) direction_int = - 1 if direction == \"-\" else 1 pos_constraint = cur_boundary . place_relative_to ( volume , axes = ( axis , other_axes [ 0 ], other_axes [ 1 ]), own_positions = ( direction_int , 0 , 0 ), other_positions = ( direction_int , 0 , 0 ), ) boundaries [ kind ] = cur_boundary constraints . append ( pos_constraint ) return boundaries , constraints","title":"boundary_objects_from_config"},{"location":"api/public/circular_brush/","text":"fdtdx.circular_brush circular_brush ( diameter : float , size : int | None = None ) -> jax . Array Creates a circular binary mask/brush for morphological operations. Parameters: diameter ( float ) \u2013 Diameter of the circle in grid units. size ( int | None , default: None ) \u2013 Optional size of the output array. If None, uses ceil(diameter) rounded up to next odd number. Returns: Array \u2013 jax.Array: Binary array containing a circular mask where True indicates points Array \u2013 within the circle diameter. Source code in src/fdtdx/objects/device/parameters/discretization.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def circular_brush ( diameter : float , size : int | None = None , ) -> jax . Array : \"\"\"Creates a circular binary mask/brush for morphological operations. Args: diameter (float): Diameter of the circle in grid units. size (int | None, optional): Optional size of the output array. If None, uses ceil(diameter) rounded up to next odd number. Returns: jax.Array: Binary array containing a circular mask where True indicates points within the circle diameter. \"\"\" if size is None : s = math . ceil ( diameter ) if s % 2 == 0 : s += 1 size = s xy = jnp . stack ( jnp . meshgrid ( * map ( jnp . arange , ( size , size )), indexing = \"xy\" ), axis =- 1 ) - jnp . asarray (( size / 2 ) - 0.5 ) euc_dist = jnp . sqrt (( xy ** 2 ) . sum ( axis =- 1 )) # the less EQUAL here is important, because otherwise design may be infeasible due to discretization errors mask = euc_dist <= ( diameter / 2 ) return mask","title":"fdtdx.circular_brush"},{"location":"api/public/circular_brush/#fdtdxcircular_brush","text":"","title":"fdtdx.circular_brush"},{"location":"api/public/circular_brush/#fdtdx.circular_brush","text":"circular_brush ( diameter : float , size : int | None = None ) -> jax . Array Creates a circular binary mask/brush for morphological operations. Parameters: diameter ( float ) \u2013 Diameter of the circle in grid units. size ( int | None , default: None ) \u2013 Optional size of the output array. If None, uses ceil(diameter) rounded up to next odd number. Returns: Array \u2013 jax.Array: Binary array containing a circular mask where True indicates points Array \u2013 within the circle diameter. Source code in src/fdtdx/objects/device/parameters/discretization.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 def circular_brush ( diameter : float , size : int | None = None , ) -> jax . Array : \"\"\"Creates a circular binary mask/brush for morphological operations. Args: diameter (float): Diameter of the circle in grid units. size (int | None, optional): Optional size of the output array. If None, uses ceil(diameter) rounded up to next odd number. Returns: jax.Array: Binary array containing a circular mask where True indicates points within the circle diameter. \"\"\" if size is None : s = math . ceil ( diameter ) if s % 2 == 0 : s += 1 size = s xy = jnp . stack ( jnp . meshgrid ( * map ( jnp . arange , ( size , size )), indexing = \"xy\" ), axis =- 1 ) - jnp . asarray (( size / 2 ) - 0.5 ) euc_dist = jnp . sqrt (( xy ** 2 ) . sum ( axis =- 1 )) # the less EQUAL here is important, because otherwise design may be infeasible due to discretization errors mask = euc_dist <= ( diameter / 2 ) return mask","title":"circular_brush"},{"location":"api/public/compute_energy/","text":"fdtdx.compute_energy compute_energy ( E : Array , H : Array , inv_permittivity : Array | float , inv_permeability : Array | float , axis : int = 0 , ) -> jax . Array Computes the total electromagnetic energy density of the field. Parameters: E ( Array ) \u2013 Electric field array with shape (3, nx, ny, nz) H ( Array ) \u2013 Magnetic field array with shape (3, nx, ny, nz) inv_permittivity ( Array | float ) \u2013 Inverse of the electric permittivity array inv_permeability ( Array | float ) \u2013 Inverse of the magnetic permeability array axis ( int , default: 0 ) \u2013 Axis index of the X,Y,Z component for the E and H field. Defaults to 0. Returns: jax.Array: Total energy density array with shape (nx, ny, nz) Source code in src/fdtdx/core/physics/metrics.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def compute_energy ( E : jax . Array , H : jax . Array , inv_permittivity : jax . Array | float , inv_permeability : jax . Array | float , axis : int = 0 , ) -> jax . Array : \"\"\"Computes the total electromagnetic energy density of the field. Args: E (jax.Array): Electric field array with shape (3, nx, ny, nz) H (jax.Array): Magnetic field array with shape (3, nx, ny, nz) inv_permittivity (jax.Array | float): Inverse of the electric permittivity array inv_permeability (jax.Array | float): Inverse of the magnetic permeability array axis (int, optional): Axis index of the X,Y,Z component for the E and H field. Defaults to 0. Returns: jax.Array: Total energy density array with shape (nx, ny, nz) \"\"\" abs_E = jnp . sum ( jnp . square ( jnp . abs ( E )), axis = axis ) energy_E = 0.5 * ( 1 / inv_permittivity ) * abs_E abs_H = jnp . sum ( jnp . square ( jnp . abs ( H )), axis = axis ) energy_H = 0.5 * ( 1 / inv_permeability ) * abs_H total_energy = energy_E + energy_H return total_energy","title":"fdtdx.compute_energy"},{"location":"api/public/compute_energy/#fdtdxcompute_energy","text":"","title":"fdtdx.compute_energy"},{"location":"api/public/compute_energy/#fdtdx.compute_energy","text":"compute_energy ( E : Array , H : Array , inv_permittivity : Array | float , inv_permeability : Array | float , axis : int = 0 , ) -> jax . Array Computes the total electromagnetic energy density of the field. Parameters: E ( Array ) \u2013 Electric field array with shape (3, nx, ny, nz) H ( Array ) \u2013 Magnetic field array with shape (3, nx, ny, nz) inv_permittivity ( Array | float ) \u2013 Inverse of the electric permittivity array inv_permeability ( Array | float ) \u2013 Inverse of the magnetic permeability array axis ( int , default: 0 ) \u2013 Axis index of the X,Y,Z component for the E and H field. Defaults to 0. Returns: jax.Array: Total energy density array with shape (nx, ny, nz) Source code in src/fdtdx/core/physics/metrics.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def compute_energy ( E : jax . Array , H : jax . Array , inv_permittivity : jax . Array | float , inv_permeability : jax . Array | float , axis : int = 0 , ) -> jax . Array : \"\"\"Computes the total electromagnetic energy density of the field. Args: E (jax.Array): Electric field array with shape (3, nx, ny, nz) H (jax.Array): Magnetic field array with shape (3, nx, ny, nz) inv_permittivity (jax.Array | float): Inverse of the electric permittivity array inv_permeability (jax.Array | float): Inverse of the magnetic permeability array axis (int, optional): Axis index of the X,Y,Z component for the E and H field. Defaults to 0. Returns: jax.Array: Total energy density array with shape (nx, ny, nz) \"\"\" abs_E = jnp . sum ( jnp . square ( jnp . abs ( E )), axis = axis ) energy_E = 0.5 * ( 1 / inv_permittivity ) * abs_E abs_H = jnp . sum ( jnp . square ( jnp . abs ( H )), axis = axis ) energy_H = 0.5 * ( 1 / inv_permeability ) * abs_H total_energy = energy_E + energy_H return total_energy","title":"compute_energy"},{"location":"api/public/compute_poynting_flux/","text":"fdtdx.compute_poynting_flux compute_poynting_flux ( E : Array , H : Array , axis : int = 0 ) -> jax . Array Calculates the Poynting vector (energy flux) from E and H fields. Parameters: E ( Array ) \u2013 Electric field array with shape (3, nx, ny, nz) H ( Array ) \u2013 Magnetic field array with shape (3, nx, ny, nz) axis ( int , default: 0 ) \u2013 Axis for computing the poynting flux. Defaults to 0. Returns: Array \u2013 jax.Array: Poynting vector array with shape (3, nx, ny, nz) representing Array \u2013 energy flux in each direction Source code in src/fdtdx/core/physics/metrics.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def compute_poynting_flux ( E : jax . Array , H : jax . Array , axis : int = 0 ) -> jax . Array : \"\"\"Calculates the Poynting vector (energy flux) from E and H fields. Args: E (jax.Array): Electric field array with shape (3, nx, ny, nz) H (jax.Array): Magnetic field array with shape (3, nx, ny, nz) axis (int, optional): Axis for computing the poynting flux. Defaults to 0. Returns: jax.Array: Poynting vector array with shape (3, nx, ny, nz) representing energy flux in each direction \"\"\" return jnp . cross ( E , jnp . conj ( H ), axisa = axis , axisb = axis , axisc = axis , )","title":"fdtdx.compute_poynting_flux"},{"location":"api/public/compute_poynting_flux/#fdtdxcompute_poynting_flux","text":"","title":"fdtdx.compute_poynting_flux"},{"location":"api/public/compute_poynting_flux/#fdtdx.compute_poynting_flux","text":"compute_poynting_flux ( E : Array , H : Array , axis : int = 0 ) -> jax . Array Calculates the Poynting vector (energy flux) from E and H fields. Parameters: E ( Array ) \u2013 Electric field array with shape (3, nx, ny, nz) H ( Array ) \u2013 Magnetic field array with shape (3, nx, ny, nz) axis ( int , default: 0 ) \u2013 Axis for computing the poynting flux. Defaults to 0. Returns: Array \u2013 jax.Array: Poynting vector array with shape (3, nx, ny, nz) representing Array \u2013 energy flux in each direction Source code in src/fdtdx/core/physics/metrics.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def compute_poynting_flux ( E : jax . Array , H : jax . Array , axis : int = 0 ) -> jax . Array : \"\"\"Calculates the Poynting vector (energy flux) from E and H fields. Args: E (jax.Array): Electric field array with shape (3, nx, ny, nz) H (jax.Array): Magnetic field array with shape (3, nx, ny, nz) axis (int, optional): Axis for computing the poynting flux. Defaults to 0. Returns: jax.Array: Poynting vector array with shape (3, nx, ny, nz) representing energy flux in each direction \"\"\" return jnp . cross ( E , jnp . conj ( H ), axisa = axis , axisb = axis , axisc = axis , )","title":"compute_poynting_flux"},{"location":"api/public/constants/","text":"fdtdx.constants fdtdx.constants.c module-attribute c : float = 299792458.0 Speed of light in vacuum (m/s). fdtdx.constants.mu0 module-attribute mu0 : float = 4e-07 * pi Vacuum permeability (H/m). fdtdx.constants.eps0 module-attribute eps0 : float = 1.0 / mu0 * c ** 2 Vacuum permittivity (F/m). fdtdx.constants.eta0 module-attribute eta0 : float = mu0 * c Free space impedance (\u03a9). fdtdx.constants.wavelength_to_period wavelength_to_period ( wavelength : float ) -> float Convert wavelength to time period using speed of light. Uses the speed of light constant to calculate the corresponding time period for a given wavelength. Parameters: wavelength ( float ) \u2013 The wavelength in meters. Returns: float ( float ) \u2013 The corresponding time period in seconds. Source code in src/fdtdx/constants.py 69 70 71 72 73 74 75 76 77 78 79 80 81 def wavelength_to_period ( wavelength : float ) -> float : \"\"\"Convert wavelength to time period using speed of light. Uses the speed of light constant to calculate the corresponding time period for a given wavelength. Args: wavelength (float): The wavelength in meters. Returns: float: The corresponding time period in seconds. \"\"\" return wavelength / c","title":"fdtdx.constants"},{"location":"api/public/constants/#fdtdxconstants","text":"","title":"fdtdx.constants"},{"location":"api/public/constants/#fdtdx.constants.c","text":"c : float = 299792458.0 Speed of light in vacuum (m/s).","title":"c"},{"location":"api/public/constants/#fdtdx.constants.mu0","text":"mu0 : float = 4e-07 * pi Vacuum permeability (H/m).","title":"mu0"},{"location":"api/public/constants/#fdtdx.constants.eps0","text":"eps0 : float = 1.0 / mu0 * c ** 2 Vacuum permittivity (F/m).","title":"eps0"},{"location":"api/public/constants/#fdtdx.constants.eta0","text":"eta0 : float = mu0 * c Free space impedance (\u03a9).","title":"eta0"},{"location":"api/public/constants/#fdtdx.constants.wavelength_to_period","text":"wavelength_to_period ( wavelength : float ) -> float Convert wavelength to time period using speed of light. Uses the speed of light constant to calculate the corresponding time period for a given wavelength. Parameters: wavelength ( float ) \u2013 The wavelength in meters. Returns: float ( float ) \u2013 The corresponding time period in seconds. Source code in src/fdtdx/constants.py 69 70 71 72 73 74 75 76 77 78 79 80 81 def wavelength_to_period ( wavelength : float ) -> float : \"\"\"Convert wavelength to time period using speed of light. Uses the speed of light constant to calculate the corresponding time period for a given wavelength. Args: wavelength (float): The wavelength in meters. Returns: float: The corresponding time period in seconds. \"\"\" return wavelength / c","title":"wavelength_to_period"},{"location":"api/public/metric_efficiency/","text":"fdtdx.metric_efficiency metric_efficiency ( detector_states : dict [ str , dict [ str , Array ]], in_names : Sequence [ str ], out_names : Sequence [ str ], metric_name : str , ) -> tuple [ jax . Array , dict [ str , Any ]] Calculate efficiency metrics between input and output detectors. Computes efficiency ratios between input and output detectors by comparing their metric values (e.g. energy, power). For each input-output detector pair, calculates the ratio of output/input metric values. Parameters: detector_states ( dict [ str , dict [ str , Array ]] ) \u2013 Dictionary mapping detector names to their state dictionaries, which contain metric values as JAX arrays in_names ( Sequence [ str ] ) \u2013 Names of input detectors to use as reference out_names ( Sequence [ str ] ) \u2013 Names of output detectors to compare against inputs metric_name ( str ) \u2013 Name of the metric to compare between detectors (e.g. \"energy\") Returns: tuple [ Array , dict [ str , Any ]] \u2013 tuple[jax.Array, dict[str, Any]]: tuple containing: - jax.Array: Mean efficiency across all input-output pairs - dict: Additional info including individual metric values and efficiencies with keys like: \"{detector} {metric}\" for raw metric values \"{out} {by}_{in}_efficiency\" for individual efficiency ratios Source code in src/fdtdx/core/physics/losses.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def metric_efficiency ( detector_states : dict [ str , dict [ str , jax . Array ]], in_names : Sequence [ str ], out_names : Sequence [ str ], metric_name : str , ) -> tuple [ jax . Array , dict [ str , Any ]]: \"\"\"Calculate efficiency metrics between input and output detectors. Computes efficiency ratios between input and output detectors by comparing their metric values (e.g. energy, power). For each input-output detector pair, calculates the ratio of output/input metric values. Args: detector_states (dict[str, dict[str, jax.Array]]): Dictionary mapping detector names to their state dictionaries, which contain metric values as JAX arrays in_names (Sequence[str]): Names of input detectors to use as reference out_names (Sequence[str]): Names of output detectors to compare against inputs metric_name (str): Name of the metric to compare between detectors (e.g. \"energy\") Returns: tuple[jax.Array, dict[str, Any]]: tuple containing: - jax.Array: Mean efficiency across all input-output pairs - dict: Additional info including individual metric values and efficiencies with keys like: \"{detector}_{metric}\" for raw metric values \"{out}_{by}_{in}_efficiency\" for individual efficiency ratios \"\"\" efficiencies , info = [], {} for in_name in in_names : in_value = jax . lax . stop_gradient ( detector_states [ in_name ][ metric_name ] . mean ()) info [ f \" { in_name } _ { metric_name } \" ] = in_value for out_name in out_names : out_value = detector_states [ out_name ][ metric_name ] . mean () eff = jnp . where ( in_value == 0 , 0 , out_value / in_value ) efficiencies . append ( eff ) info [ f \" { out_name } _ { metric_name } \" ] = out_value info [ f \" { out_name } _by_ { in_name } _efficiency\" ] = eff objective = jnp . mean ( jnp . asarray ( efficiencies )) return objective , info","title":"fdtdx.metric_efficiency"},{"location":"api/public/metric_efficiency/#fdtdxmetric_efficiency","text":"","title":"fdtdx.metric_efficiency"},{"location":"api/public/metric_efficiency/#fdtdx.metric_efficiency","text":"metric_efficiency ( detector_states : dict [ str , dict [ str , Array ]], in_names : Sequence [ str ], out_names : Sequence [ str ], metric_name : str , ) -> tuple [ jax . Array , dict [ str , Any ]] Calculate efficiency metrics between input and output detectors. Computes efficiency ratios between input and output detectors by comparing their metric values (e.g. energy, power). For each input-output detector pair, calculates the ratio of output/input metric values. Parameters: detector_states ( dict [ str , dict [ str , Array ]] ) \u2013 Dictionary mapping detector names to their state dictionaries, which contain metric values as JAX arrays in_names ( Sequence [ str ] ) \u2013 Names of input detectors to use as reference out_names ( Sequence [ str ] ) \u2013 Names of output detectors to compare against inputs metric_name ( str ) \u2013 Name of the metric to compare between detectors (e.g. \"energy\") Returns: tuple [ Array , dict [ str , Any ]] \u2013 tuple[jax.Array, dict[str, Any]]: tuple containing: - jax.Array: Mean efficiency across all input-output pairs - dict: Additional info including individual metric values and efficiencies with keys like: \"{detector} {metric}\" for raw metric values \"{out} {by}_{in}_efficiency\" for individual efficiency ratios Source code in src/fdtdx/core/physics/losses.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def metric_efficiency ( detector_states : dict [ str , dict [ str , jax . Array ]], in_names : Sequence [ str ], out_names : Sequence [ str ], metric_name : str , ) -> tuple [ jax . Array , dict [ str , Any ]]: \"\"\"Calculate efficiency metrics between input and output detectors. Computes efficiency ratios between input and output detectors by comparing their metric values (e.g. energy, power). For each input-output detector pair, calculates the ratio of output/input metric values. Args: detector_states (dict[str, dict[str, jax.Array]]): Dictionary mapping detector names to their state dictionaries, which contain metric values as JAX arrays in_names (Sequence[str]): Names of input detectors to use as reference out_names (Sequence[str]): Names of output detectors to compare against inputs metric_name (str): Name of the metric to compare between detectors (e.g. \"energy\") Returns: tuple[jax.Array, dict[str, Any]]: tuple containing: - jax.Array: Mean efficiency across all input-output pairs - dict: Additional info including individual metric values and efficiencies with keys like: \"{detector}_{metric}\" for raw metric values \"{out}_{by}_{in}_efficiency\" for individual efficiency ratios \"\"\" efficiencies , info = [], {} for in_name in in_names : in_value = jax . lax . stop_gradient ( detector_states [ in_name ][ metric_name ] . mean ()) info [ f \" { in_name } _ { metric_name } \" ] = in_value for out_name in out_names : out_value = detector_states [ out_name ][ metric_name ] . mean () eff = jnp . where ( in_value == 0 , 0 , out_value / in_value ) efficiencies . append ( eff ) info [ f \" { out_name } _ { metric_name } \" ] = out_value info [ f \" { out_name } _by_ { in_name } _efficiency\" ] = eff objective = jnp . mean ( jnp . asarray ( efficiencies )) return objective , info","title":"metric_efficiency"},{"location":"api/public/place_objects/","text":"fdtdx.place_objects place_objects ( volume : SimulationObject , config : SimulationConfig , constraints : Sequence [ PositionConstraint | SizeConstraint | SizeExtensionConstraint | GridCoordinateConstraint | RealCoordinateConstraint ], key : Array , ) -> tuple [ ObjectContainer , ArrayContainer , ParameterContainer , SimulationConfig , dict [ str , Any ], ] Places simulation objects according to specified constraints and initializes containers. Parameters: volume ( SimulationObject ) \u2013 The volume object defining the simulation boundaries config ( SimulationConfig ) \u2013 The simulation configuration constraints ( Sequence [ PositionConstraint | SizeConstraint | SizeExtensionConstraint | GridCoordinateConstraint | RealCoordinateConstraint ] ) \u2013 Sequence of positioning and sizing constraints for objects key ( Array ) \u2013 JAX random key for initialization Returns: tuple [ ObjectContainer , ArrayContainer , ParameterContainer , SimulationConfig , dict [ str , Any ]] \u2013 tuple[ObjectContainer, ArrayContainer, ParameterContainer, SimulationConfig, dict[str, Any]]: A tuple containing - ObjectContainer with placed simulation objects - ArrayContainer with initialized field arrays - ParameterContainer with device parameters - Updated SimulationConfig - Dictionary with additional initialization info Source code in src/fdtdx/fdtd/initialization.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def place_objects ( volume : SimulationObject , config : SimulationConfig , constraints : Sequence [ ( PositionConstraint | SizeConstraint | SizeExtensionConstraint | GridCoordinateConstraint | RealCoordinateConstraint ) ], key : jax . Array , ) -> tuple [ ObjectContainer , ArrayContainer , ParameterContainer , SimulationConfig , dict [ str , Any ], ]: \"\"\"Places simulation objects according to specified constraints and initializes containers. Args: volume (SimulationObject): The volume object defining the simulation boundaries config (SimulationConfig): The simulation configuration constraints (Sequence[PositionConstraint| SizeConstraint| SizeExtensionConstraint| GridCoordinateConstraint| RealCoordinateConstraint]): Sequence of positioning and sizing constraints for objects key (jax.Array): JAX random key for initialization Returns: tuple[ObjectContainer, ArrayContainer, ParameterContainer, SimulationConfig, dict[str, Any]]: A tuple containing - ObjectContainer with placed simulation objects - ArrayContainer with initialized field arrays - ParameterContainer with device parameters - Updated SimulationConfig - Dictionary with additional initialization info \"\"\" slice_tuple_dict = _resolve_object_constraints ( volume = volume , constraints = constraints , config = config , ) obj_list = list ( slice_tuple_dict . keys ()) # place objects on computed grid positions placed_objects = [] for o in obj_list : if o == volume : continue key , subkey = jax . random . split ( key ) placed_objects . append ( o . place_on_grid ( grid_slice_tuple = slice_tuple_dict [ o ], config = config , key = subkey , ) ) key , subkey = jax . random . split ( key ) placed_objects . insert ( 0 , volume . place_on_grid ( grid_slice_tuple = slice_tuple_dict [ volume ], config = config , key = subkey , ), ) # create container objects = ObjectContainer ( object_list = placed_objects , volume_idx = 0 , ) params = _init_params ( objects = objects , key = key , ) arrays , config , info = _init_arrays ( objects = objects , config = config , ) # replace config in objects with compiled config new_object_list = [] for o in objects . objects : o = o . aset ( \"_config\" , config ) new_object_list . append ( o ) objects = ObjectContainer ( object_list = new_object_list , volume_idx = 0 , ) return objects , arrays , params , config , info","title":"fdtdx.place_objects"},{"location":"api/public/place_objects/#fdtdxplace_objects","text":"","title":"fdtdx.place_objects"},{"location":"api/public/place_objects/#fdtdx.place_objects","text":"place_objects ( volume : SimulationObject , config : SimulationConfig , constraints : Sequence [ PositionConstraint | SizeConstraint | SizeExtensionConstraint | GridCoordinateConstraint | RealCoordinateConstraint ], key : Array , ) -> tuple [ ObjectContainer , ArrayContainer , ParameterContainer , SimulationConfig , dict [ str , Any ], ] Places simulation objects according to specified constraints and initializes containers. Parameters: volume ( SimulationObject ) \u2013 The volume object defining the simulation boundaries config ( SimulationConfig ) \u2013 The simulation configuration constraints ( Sequence [ PositionConstraint | SizeConstraint | SizeExtensionConstraint | GridCoordinateConstraint | RealCoordinateConstraint ] ) \u2013 Sequence of positioning and sizing constraints for objects key ( Array ) \u2013 JAX random key for initialization Returns: tuple [ ObjectContainer , ArrayContainer , ParameterContainer , SimulationConfig , dict [ str , Any ]] \u2013 tuple[ObjectContainer, ArrayContainer, ParameterContainer, SimulationConfig, dict[str, Any]]: A tuple containing - ObjectContainer with placed simulation objects - ArrayContainer with initialized field arrays - ParameterContainer with device parameters - Updated SimulationConfig - Dictionary with additional initialization info Source code in src/fdtdx/fdtd/initialization.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def place_objects ( volume : SimulationObject , config : SimulationConfig , constraints : Sequence [ ( PositionConstraint | SizeConstraint | SizeExtensionConstraint | GridCoordinateConstraint | RealCoordinateConstraint ) ], key : jax . Array , ) -> tuple [ ObjectContainer , ArrayContainer , ParameterContainer , SimulationConfig , dict [ str , Any ], ]: \"\"\"Places simulation objects according to specified constraints and initializes containers. Args: volume (SimulationObject): The volume object defining the simulation boundaries config (SimulationConfig): The simulation configuration constraints (Sequence[PositionConstraint| SizeConstraint| SizeExtensionConstraint| GridCoordinateConstraint| RealCoordinateConstraint]): Sequence of positioning and sizing constraints for objects key (jax.Array): JAX random key for initialization Returns: tuple[ObjectContainer, ArrayContainer, ParameterContainer, SimulationConfig, dict[str, Any]]: A tuple containing - ObjectContainer with placed simulation objects - ArrayContainer with initialized field arrays - ParameterContainer with device parameters - Updated SimulationConfig - Dictionary with additional initialization info \"\"\" slice_tuple_dict = _resolve_object_constraints ( volume = volume , constraints = constraints , config = config , ) obj_list = list ( slice_tuple_dict . keys ()) # place objects on computed grid positions placed_objects = [] for o in obj_list : if o == volume : continue key , subkey = jax . random . split ( key ) placed_objects . append ( o . place_on_grid ( grid_slice_tuple = slice_tuple_dict [ o ], config = config , key = subkey , ) ) key , subkey = jax . random . split ( key ) placed_objects . insert ( 0 , volume . place_on_grid ( grid_slice_tuple = slice_tuple_dict [ volume ], config = config , key = subkey , ), ) # create container objects = ObjectContainer ( object_list = placed_objects , volume_idx = 0 , ) params = _init_params ( objects = objects , key = key , ) arrays , config , info = _init_arrays ( objects = objects , config = config , ) # replace config in objects with compiled config new_object_list = [] for o in objects . objects : o = o . aset ( \"_config\" , config ) new_object_list . append ( o ) objects = ObjectContainer ( object_list = new_object_list , volume_idx = 0 , ) return objects , arrays , params , config , info","title":"place_objects"},{"location":"api/public/plot_setup/","text":"fdtdx.plot_setup plot_setup ( config : SimulationConfig , objects : ObjectContainer , exclude_object_list : list [ SimulationObject ] = [], filename : str | Path | None = None , axs : Sequence [ Any ] | None = None , plot_legend : bool = True , exclude_xy_plane_object_list : list [ SimulationObject ] = [], exclude_yz_plane_object_list : list [ SimulationObject ] = [], exclude_xz_plane_object_list : list [ SimulationObject ] = [], ) -> Figure Creates a visualization of the simulation setup showing objects in XY, XZ and YZ planes. Generates three subplots showing cross-sections of the simulation volume and the objects within it. Objects are drawn as colored rectangles with optional legends. The visualization helps verify the correct positioning and sizing of objects in the simulation setup. Parameters: config ( SimulationConfig ) \u2013 Configuration object containing simulation parameters like resolution objects ( ObjectContainer ) \u2013 Container holding all simulation objects to be plotted exclude_object_list ( list [ SimulationObject ] , default: [] ) \u2013 List of objects to exclude from all plots filename ( str | Path | None , default: None ) \u2013 If provided, saves the plot to this file instead of displaying axs ( Sequence [ Any ] | None , default: None ) \u2013 Optional matplotlib axes to plot on. If None, creates new figure plot_legend ( bool , default: True ) \u2013 Whether to add a legend showing object names/types exclude_xy_plane_object_list ( list [ SimulationObject ] , default: [] ) \u2013 Objects to exclude from XY plane plot exclude_yz_plane_object_list ( list [ SimulationObject ] , default: [] ) \u2013 Objects to exclude from YZ plane plot exclude_xz_plane_object_list ( list [ SimulationObject ] , default: [] ) \u2013 Objects to exclude from XZ plane plot Returns: Figure ( Figure ) \u2013 The generated figure object Note The plots show object positions in micrometers, converting from simulation units. PML objects are automatically excluded from their respective boundary planes. Source code in src/fdtdx/utils/plot_setup.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def plot_setup ( config : SimulationConfig , objects : ObjectContainer , exclude_object_list : list [ SimulationObject ] = [], filename : str | Path | None = None , axs : Sequence [ Any ] | None = None , plot_legend : bool = True , exclude_xy_plane_object_list : list [ SimulationObject ] = [], exclude_yz_plane_object_list : list [ SimulationObject ] = [], exclude_xz_plane_object_list : list [ SimulationObject ] = [], ) -> Figure : \"\"\"Creates a visualization of the simulation setup showing objects in XY, XZ and YZ planes. Generates three subplots showing cross-sections of the simulation volume and the objects within it. Objects are drawn as colored rectangles with optional legends. The visualization helps verify the correct positioning and sizing of objects in the simulation setup. Args: config (SimulationConfig): Configuration object containing simulation parameters like resolution objects (ObjectContainer): Container holding all simulation objects to be plotted exclude_object_list (list[SimulationObject], optional): List of objects to exclude from all plots filename (str | Path | None, optional): If provided, saves the plot to this file instead of displaying axs (Sequence[Any] | None, optional): Optional matplotlib axes to plot on. If None, creates new figure plot_legend (bool, optional): Whether to add a legend showing object names/types exclude_xy_plane_object_list (list[SimulationObject], optional): Objects to exclude from XY plane plot exclude_yz_plane_object_list (list[SimulationObject], optional): Objects to exclude from YZ plane plot exclude_xz_plane_object_list (list[SimulationObject], optional): Objects to exclude from XZ plane plot Returns: Figure: The generated figure object Note: The plots show object positions in micrometers, converting from simulation units. PML objects are automatically excluded from their respective boundary planes. \"\"\" # add boundaries to exclude lists for o in objects . objects : if not isinstance ( o , ( PerfectlyMatchedLayer , PeriodicBoundary )): continue if o . axis == 0 : exclude_yz_plane_object_list . append ( o ) elif o . axis == 1 : exclude_xz_plane_object_list . append ( o ) elif o . axis == 2 : exclude_xy_plane_object_list . append ( o ) # add volume to exclude list volume = objects . volume exclude_object_list . append ( volume ) object_list = [ o for o in objects . objects if o not in exclude_object_list ] if axs is None : fig , axs = plt . subplots ( 1 , 3 , figsize = ( 15 , 5 )) else : fig = None assert axs is not None resolution = config . resolution / 1.0e-6 # Convert to \u00b5m # get a color map colored_objects : list [ SimulationObject ] = [ o for o in object_list if o . color is not None ] if plot_legend : handles = [] used_lists = [] for o in colored_objects : print_single = False for o2 in colored_objects : if o . __class__ == o2 . __class__ : if o . color != o2 . color : print_single = True if not o . name . startswith ( \"Object\" ): print_single = True label = o . __class__ . __name__ if o . name . startswith ( \"Object\" ) else o . name patch = Patch ( color = o . color , label = label ) if print_single : handles . append ( patch ) else : if o . __class__ . __name__ not in used_lists : used_lists . append ( o . __class__ . __name__ ) handles . append ( patch ) plt . legend ( handles = handles , loc = \"upper right\" , bbox_to_anchor = ( 1.75 , 0.75 ), frameon = False , ) # Plot each object on the corresponding subplot for obj in colored_objects : slices = obj . grid_slice_tuple color = obj . color # XY plane at Z center if exclude_xy_plane_object_list is None or obj not in exclude_xy_plane_object_list : axs [ 0 ] . add_patch ( Rectangle ( ( slices [ 0 ][ 0 ] * resolution , slices [ 1 ][ 0 ] * resolution ), ( slices [ 0 ][ 1 ] - slices [ 0 ][ 0 ]) * resolution , ( slices [ 1 ][ 1 ] - slices [ 1 ][ 0 ]) * resolution , color = color , alpha = 0.5 , linestyle = \"--\" if isinstance ( obj , PeriodicBoundary ) else \"-\" , ) ) # XZ plane at Y center if exclude_xz_plane_object_list is None or obj not in exclude_xz_plane_object_list : axs [ 1 ] . add_patch ( Rectangle ( ( slices [ 0 ][ 0 ] * resolution , slices [ 2 ][ 0 ] * resolution ), ( slices [ 0 ][ 1 ] - slices [ 0 ][ 0 ]) * resolution , ( slices [ 2 ][ 1 ] - slices [ 2 ][ 0 ]) * resolution , color = color , alpha = 0.5 , linestyle = \"--\" if isinstance ( obj , PeriodicBoundary ) else \"-\" , ) ) # YZ plane at X center if exclude_yz_plane_object_list is None or obj not in exclude_yz_plane_object_list : axs [ 2 ] . add_patch ( Rectangle ( ( slices [ 1 ][ 0 ] * resolution , slices [ 2 ][ 0 ] * resolution ), ( slices [ 1 ][ 1 ] - slices [ 1 ][ 0 ]) * resolution , ( slices [ 2 ][ 1 ] - slices [ 2 ][ 0 ]) * resolution , color = color , alpha = 0.5 , linestyle = \"--\" if isinstance ( obj , PeriodicBoundary ) else \"-\" , ) ) # Set labels and titles axs [ 0 ] . set_xlabel ( \"x (\u00b5m)\" ) axs [ 0 ] . set_ylabel ( \"y (\u00b5m)\" ) axs [ 0 ] . set_title ( \"XY plane\" ) axs [ 0 ] . set_xlim ([ 0 , volume . grid_shape [ 0 ] * resolution ]) axs [ 0 ] . set_ylim ([ 0 , volume . grid_shape [ 1 ] * resolution ]) axs [ 1 ] . set_xlabel ( \"x (\u00b5m)\" ) axs [ 1 ] . set_ylabel ( \"z (\u00b5m)\" ) axs [ 1 ] . set_title ( \"XZ plane\" ) axs [ 1 ] . set_xlim ([ 0 , volume . grid_shape [ 0 ] * resolution ]) axs [ 1 ] . set_ylim ([ 0 , volume . grid_shape [ 2 ] * resolution ]) axs [ 2 ] . set_xlabel ( \"y (\u00b5m)\" ) axs [ 2 ] . set_ylabel ( \"z (\u00b5m)\" ) axs [ 2 ] . set_title ( \"YZ plane\" ) axs [ 2 ] . set_xlim ([ 0 , volume . grid_shape [ 1 ] * resolution ]) axs [ 2 ] . set_ylim ([ 0 , volume . grid_shape [ 2 ] * resolution ]) # Adjust the plots for better visualization for ax in axs : ax . set_aspect ( \"equal\" ) ax . grid ( True ) if filename is not None : plt . savefig ( filename , bbox_inches = \"tight\" , dpi = 300 ) plt . close () return plt . gcf () if fig is None else fig","title":"fdtdx.plot_setup"},{"location":"api/public/plot_setup/#fdtdxplot_setup","text":"","title":"fdtdx.plot_setup"},{"location":"api/public/plot_setup/#fdtdx.plot_setup","text":"plot_setup ( config : SimulationConfig , objects : ObjectContainer , exclude_object_list : list [ SimulationObject ] = [], filename : str | Path | None = None , axs : Sequence [ Any ] | None = None , plot_legend : bool = True , exclude_xy_plane_object_list : list [ SimulationObject ] = [], exclude_yz_plane_object_list : list [ SimulationObject ] = [], exclude_xz_plane_object_list : list [ SimulationObject ] = [], ) -> Figure Creates a visualization of the simulation setup showing objects in XY, XZ and YZ planes. Generates three subplots showing cross-sections of the simulation volume and the objects within it. Objects are drawn as colored rectangles with optional legends. The visualization helps verify the correct positioning and sizing of objects in the simulation setup. Parameters: config ( SimulationConfig ) \u2013 Configuration object containing simulation parameters like resolution objects ( ObjectContainer ) \u2013 Container holding all simulation objects to be plotted exclude_object_list ( list [ SimulationObject ] , default: [] ) \u2013 List of objects to exclude from all plots filename ( str | Path | None , default: None ) \u2013 If provided, saves the plot to this file instead of displaying axs ( Sequence [ Any ] | None , default: None ) \u2013 Optional matplotlib axes to plot on. If None, creates new figure plot_legend ( bool , default: True ) \u2013 Whether to add a legend showing object names/types exclude_xy_plane_object_list ( list [ SimulationObject ] , default: [] ) \u2013 Objects to exclude from XY plane plot exclude_yz_plane_object_list ( list [ SimulationObject ] , default: [] ) \u2013 Objects to exclude from YZ plane plot exclude_xz_plane_object_list ( list [ SimulationObject ] , default: [] ) \u2013 Objects to exclude from XZ plane plot Returns: Figure ( Figure ) \u2013 The generated figure object Note The plots show object positions in micrometers, converting from simulation units. PML objects are automatically excluded from their respective boundary planes. Source code in src/fdtdx/utils/plot_setup.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def plot_setup ( config : SimulationConfig , objects : ObjectContainer , exclude_object_list : list [ SimulationObject ] = [], filename : str | Path | None = None , axs : Sequence [ Any ] | None = None , plot_legend : bool = True , exclude_xy_plane_object_list : list [ SimulationObject ] = [], exclude_yz_plane_object_list : list [ SimulationObject ] = [], exclude_xz_plane_object_list : list [ SimulationObject ] = [], ) -> Figure : \"\"\"Creates a visualization of the simulation setup showing objects in XY, XZ and YZ planes. Generates three subplots showing cross-sections of the simulation volume and the objects within it. Objects are drawn as colored rectangles with optional legends. The visualization helps verify the correct positioning and sizing of objects in the simulation setup. Args: config (SimulationConfig): Configuration object containing simulation parameters like resolution objects (ObjectContainer): Container holding all simulation objects to be plotted exclude_object_list (list[SimulationObject], optional): List of objects to exclude from all plots filename (str | Path | None, optional): If provided, saves the plot to this file instead of displaying axs (Sequence[Any] | None, optional): Optional matplotlib axes to plot on. If None, creates new figure plot_legend (bool, optional): Whether to add a legend showing object names/types exclude_xy_plane_object_list (list[SimulationObject], optional): Objects to exclude from XY plane plot exclude_yz_plane_object_list (list[SimulationObject], optional): Objects to exclude from YZ plane plot exclude_xz_plane_object_list (list[SimulationObject], optional): Objects to exclude from XZ plane plot Returns: Figure: The generated figure object Note: The plots show object positions in micrometers, converting from simulation units. PML objects are automatically excluded from their respective boundary planes. \"\"\" # add boundaries to exclude lists for o in objects . objects : if not isinstance ( o , ( PerfectlyMatchedLayer , PeriodicBoundary )): continue if o . axis == 0 : exclude_yz_plane_object_list . append ( o ) elif o . axis == 1 : exclude_xz_plane_object_list . append ( o ) elif o . axis == 2 : exclude_xy_plane_object_list . append ( o ) # add volume to exclude list volume = objects . volume exclude_object_list . append ( volume ) object_list = [ o for o in objects . objects if o not in exclude_object_list ] if axs is None : fig , axs = plt . subplots ( 1 , 3 , figsize = ( 15 , 5 )) else : fig = None assert axs is not None resolution = config . resolution / 1.0e-6 # Convert to \u00b5m # get a color map colored_objects : list [ SimulationObject ] = [ o for o in object_list if o . color is not None ] if plot_legend : handles = [] used_lists = [] for o in colored_objects : print_single = False for o2 in colored_objects : if o . __class__ == o2 . __class__ : if o . color != o2 . color : print_single = True if not o . name . startswith ( \"Object\" ): print_single = True label = o . __class__ . __name__ if o . name . startswith ( \"Object\" ) else o . name patch = Patch ( color = o . color , label = label ) if print_single : handles . append ( patch ) else : if o . __class__ . __name__ not in used_lists : used_lists . append ( o . __class__ . __name__ ) handles . append ( patch ) plt . legend ( handles = handles , loc = \"upper right\" , bbox_to_anchor = ( 1.75 , 0.75 ), frameon = False , ) # Plot each object on the corresponding subplot for obj in colored_objects : slices = obj . grid_slice_tuple color = obj . color # XY plane at Z center if exclude_xy_plane_object_list is None or obj not in exclude_xy_plane_object_list : axs [ 0 ] . add_patch ( Rectangle ( ( slices [ 0 ][ 0 ] * resolution , slices [ 1 ][ 0 ] * resolution ), ( slices [ 0 ][ 1 ] - slices [ 0 ][ 0 ]) * resolution , ( slices [ 1 ][ 1 ] - slices [ 1 ][ 0 ]) * resolution , color = color , alpha = 0.5 , linestyle = \"--\" if isinstance ( obj , PeriodicBoundary ) else \"-\" , ) ) # XZ plane at Y center if exclude_xz_plane_object_list is None or obj not in exclude_xz_plane_object_list : axs [ 1 ] . add_patch ( Rectangle ( ( slices [ 0 ][ 0 ] * resolution , slices [ 2 ][ 0 ] * resolution ), ( slices [ 0 ][ 1 ] - slices [ 0 ][ 0 ]) * resolution , ( slices [ 2 ][ 1 ] - slices [ 2 ][ 0 ]) * resolution , color = color , alpha = 0.5 , linestyle = \"--\" if isinstance ( obj , PeriodicBoundary ) else \"-\" , ) ) # YZ plane at X center if exclude_yz_plane_object_list is None or obj not in exclude_yz_plane_object_list : axs [ 2 ] . add_patch ( Rectangle ( ( slices [ 1 ][ 0 ] * resolution , slices [ 2 ][ 0 ] * resolution ), ( slices [ 1 ][ 1 ] - slices [ 1 ][ 0 ]) * resolution , ( slices [ 2 ][ 1 ] - slices [ 2 ][ 0 ]) * resolution , color = color , alpha = 0.5 , linestyle = \"--\" if isinstance ( obj , PeriodicBoundary ) else \"-\" , ) ) # Set labels and titles axs [ 0 ] . set_xlabel ( \"x (\u00b5m)\" ) axs [ 0 ] . set_ylabel ( \"y (\u00b5m)\" ) axs [ 0 ] . set_title ( \"XY plane\" ) axs [ 0 ] . set_xlim ([ 0 , volume . grid_shape [ 0 ] * resolution ]) axs [ 0 ] . set_ylim ([ 0 , volume . grid_shape [ 1 ] * resolution ]) axs [ 1 ] . set_xlabel ( \"x (\u00b5m)\" ) axs [ 1 ] . set_ylabel ( \"z (\u00b5m)\" ) axs [ 1 ] . set_title ( \"XZ plane\" ) axs [ 1 ] . set_xlim ([ 0 , volume . grid_shape [ 0 ] * resolution ]) axs [ 1 ] . set_ylim ([ 0 , volume . grid_shape [ 2 ] * resolution ]) axs [ 2 ] . set_xlabel ( \"y (\u00b5m)\" ) axs [ 2 ] . set_ylabel ( \"z (\u00b5m)\" ) axs [ 2 ] . set_title ( \"YZ plane\" ) axs [ 2 ] . set_xlim ([ 0 , volume . grid_shape [ 1 ] * resolution ]) axs [ 2 ] . set_ylim ([ 0 , volume . grid_shape [ 2 ] * resolution ]) # Adjust the plots for better visualization for ax in axs : ax . set_aspect ( \"equal\" ) ax . grid ( True ) if filename is not None : plt . savefig ( filename , bbox_inches = \"tight\" , dpi = 300 ) plt . close () return plt . gcf () if fig is None else fig","title":"plot_setup"},{"location":"api/public/run_fdtd/","text":"fdtdx.run_fdtd run_fdtd ( arrays : ArrayContainer , objects : ObjectContainer , config : SimulationConfig , key : Array , ) -> SimulationState Source code in src/fdtdx/fdtd/wrapper.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def run_fdtd ( arrays : ArrayContainer , objects : ObjectContainer , config : SimulationConfig , key : jax . Array , ) -> SimulationState : if config . gradient_config is None : # only forward simulation, use standard while loop of checkpointed fdtd return checkpointed_fdtd ( arrays = arrays , objects = objects , config = config , key = key , ) if config . gradient_config . method == \"reversible\" : return reversible_fdtd ( arrays = arrays , objects = objects , config = config , key = key , ) elif config . gradient_config . method == \"checkpointed\" : return checkpointed_fdtd ( arrays = arrays , objects = objects , config = config , key = key , ) else : raise Exception ( f \"Unknown gradient computation method: { config . gradient_config . method } \" )","title":"fdtdx.run_fdtd"},{"location":"api/public/run_fdtd/#fdtdxrun_fdtd","text":"","title":"fdtdx.run_fdtd"},{"location":"api/public/run_fdtd/#fdtdx.run_fdtd","text":"run_fdtd ( arrays : ArrayContainer , objects : ObjectContainer , config : SimulationConfig , key : Array , ) -> SimulationState Source code in src/fdtdx/fdtd/wrapper.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def run_fdtd ( arrays : ArrayContainer , objects : ObjectContainer , config : SimulationConfig , key : jax . Array , ) -> SimulationState : if config . gradient_config is None : # only forward simulation, use standard while loop of checkpointed fdtd return checkpointed_fdtd ( arrays = arrays , objects = objects , config = config , key = key , ) if config . gradient_config . method == \"reversible\" : return reversible_fdtd ( arrays = arrays , objects = objects , config = config , key = key , ) elif config . gradient_config . method == \"checkpointed\" : return checkpointed_fdtd ( arrays = arrays , objects = objects , config = config , key = key , ) else : raise Exception ( f \"Unknown gradient computation method: { config . gradient_config . method } \" )","title":"run_fdtd"},{"location":"api/public/typing/","text":"fdtdx.typing fdtdx.typing.RealShape3D module-attribute RealShape3D = tuple [ float , float , float ] 3D shape with real-valued (physical) dimensions in meters. fdtdx.typing.PartialRealShape3D module-attribute PartialRealShape3D = tuple [ OptionalAxisSize , OptionalAxisSize , OptionalAxisSize ] Partial 3D shape where some physical dimensions may be undefined (None). fdtdx.typing.GridShape3D module-attribute GridShape3D = tuple [ int , int , int ] 3D shape with integer dimensions in grid points. fdtdx.typing.PartialGridShape3D module-attribute PartialGridShape3D = tuple [ OptionalGridAxisSize , OptionalGridAxisSize , OptionalGridAxisSize , ] Partial 3D grid shape where some dimensions may be undefined (None). fdtdx.typing.BackendOption module-attribute BackendOption = Literal [ 'gpu' , 'tpu' , 'cpu' , 'METAL' ] Backend options for JAX. Can be either gpu, tpu, cpu or METAL","title":"fdtdx.typing"},{"location":"api/public/typing/#fdtdxtyping","text":"","title":"fdtdx.typing"},{"location":"api/public/typing/#fdtdx.typing.RealShape3D","text":"RealShape3D = tuple [ float , float , float ] 3D shape with real-valued (physical) dimensions in meters.","title":"RealShape3D"},{"location":"api/public/typing/#fdtdx.typing.PartialRealShape3D","text":"PartialRealShape3D = tuple [ OptionalAxisSize , OptionalAxisSize , OptionalAxisSize ] Partial 3D shape where some physical dimensions may be undefined (None).","title":"PartialRealShape3D"},{"location":"api/public/typing/#fdtdx.typing.GridShape3D","text":"GridShape3D = tuple [ int , int , int ] 3D shape with integer dimensions in grid points.","title":"GridShape3D"},{"location":"api/public/typing/#fdtdx.typing.PartialGridShape3D","text":"PartialGridShape3D = tuple [ OptionalGridAxisSize , OptionalGridAxisSize , OptionalGridAxisSize , ] Partial 3D grid shape where some dimensions may be undefined (None).","title":"PartialGridShape3D"},{"location":"api/public/typing/#fdtdx.typing.BackendOption","text":"BackendOption = Literal [ 'gpu' , 'tpu' , 'cpu' , 'METAL' ] Backend options for JAX. Can be either gpu, tpu, cpu or METAL","title":"BackendOption"},{"location":"tutorials/interface_compression/","text":"Gradient computation by time reversibility FDTDX implements automatic differentiation by exploiting the time-reversibility of Maxwell's equations. You can find more details about the time-reversible gradient computation in our paper . For this tutorial, the important point to note is that during the forward simulation, the interface region between PML and actual simulation volume needs to be saved at every time step. Even though this is better than the standard implementation of AutoDiff (which would save the whole 3D volume at every time step), this can still lead to large memory requirements if the simulation is large or the simulation time long. As a remedy, we implement a compression mechanism for these saved fields. The compression settings can be adjusted in the simulation config: from fdtdx import ( GradientConfig , SimulationConfig , DtypeConversion , Recorder , LinearReconstructEveryK , ) import jax.numpy as jnp gradient_config = GradientConfig ( recorder = Recorder ( modules = [ LinearReconstructEveryK ( 2 ), DtypeConversion ( dtype = jnp . float16 ), ] ) ) config = SimulationConfig ( time = 300e-15 , resolution = 100e-9 , dtype = jnp . float32 , courant_factor = 0.99 , gradient_config = gradient_config , # <- This needs to be set for gradient computation ) Similarly to the constraint mappings , the recorder of the gradient config is defined by a list of modules, which are applied consecutively. In this example, the following two modules are used: - LinearReconstructEveryK: Firstly, this module only saves the boundary fields at every second time step. During reconstruction, the missing values are recomputed by linearly interpolating between the saved time steps. The attribute k=2 defines the step size. - DtypeConversion: The output of the previous module is converted to a different data type. In our example, the simulation runs with 32 bit floating point precision and the module converts these values to 16 bit precision, again saving 50% of the required memory. At the moment, these are the only two important compression modules implemented. Experience has shown that in almost all cases 8bit precision is also sufficient, namely the data type \"jnp.float8_e4m3fnuz\". Regarding the number of time steps, a rule of thumb is that 10 time steps per period should be saved for accurate results. Often lower saving intervals also suffice, but one needs to make sure that this is actually the case. So for example, if the simulation performs 30 time steps per period (this depends on the Courant-Friedrichs-Levy Condition), then a compression of LinearReconstructEveryK(3) should be used to save 10 time steps. The number of time steps per period can be computed by: from fdtdx import constants wavelength = 1.55e-6 period = constants . wavelength_to_period ( wavelength ) steps_per_period = period / config . time_step_duration Gradient Computation The actual gradient computation can be invoked using the standard jax.grad method on the fdtd_reversible function call. In pseudocode this might look something like this: def loss_function ( params , ... ) arrays , new_objects , info = apply_params ( arrays , objects , params , key ) _ , arrays = reversible_fdtd ( arrays = arrays , objects = new_objects , config = config , key = key , ) loss = - figure_of_merit ( arrays . detector_states ) return loss grad_function = jax . grad ( loss_fn ) grad_loss_wrt_params = grad_function ( params ) Of course figure_of_merit can be any objective function that should be optimized. The apply_params function internally calls the Parameter mapping of the device and sets the proper inverse permittivities for the simulation.","title":"Interface Compression"},{"location":"tutorials/interface_compression/#gradient-computation-by-time-reversibility","text":"FDTDX implements automatic differentiation by exploiting the time-reversibility of Maxwell's equations. You can find more details about the time-reversible gradient computation in our paper . For this tutorial, the important point to note is that during the forward simulation, the interface region between PML and actual simulation volume needs to be saved at every time step. Even though this is better than the standard implementation of AutoDiff (which would save the whole 3D volume at every time step), this can still lead to large memory requirements if the simulation is large or the simulation time long. As a remedy, we implement a compression mechanism for these saved fields. The compression settings can be adjusted in the simulation config: from fdtdx import ( GradientConfig , SimulationConfig , DtypeConversion , Recorder , LinearReconstructEveryK , ) import jax.numpy as jnp gradient_config = GradientConfig ( recorder = Recorder ( modules = [ LinearReconstructEveryK ( 2 ), DtypeConversion ( dtype = jnp . float16 ), ] ) ) config = SimulationConfig ( time = 300e-15 , resolution = 100e-9 , dtype = jnp . float32 , courant_factor = 0.99 , gradient_config = gradient_config , # <- This needs to be set for gradient computation ) Similarly to the constraint mappings , the recorder of the gradient config is defined by a list of modules, which are applied consecutively. In this example, the following two modules are used: - LinearReconstructEveryK: Firstly, this module only saves the boundary fields at every second time step. During reconstruction, the missing values are recomputed by linearly interpolating between the saved time steps. The attribute k=2 defines the step size. - DtypeConversion: The output of the previous module is converted to a different data type. In our example, the simulation runs with 32 bit floating point precision and the module converts these values to 16 bit precision, again saving 50% of the required memory. At the moment, these are the only two important compression modules implemented. Experience has shown that in almost all cases 8bit precision is also sufficient, namely the data type \"jnp.float8_e4m3fnuz\". Regarding the number of time steps, a rule of thumb is that 10 time steps per period should be saved for accurate results. Often lower saving intervals also suffice, but one needs to make sure that this is actually the case. So for example, if the simulation performs 30 time steps per period (this depends on the Courant-Friedrichs-Levy Condition), then a compression of LinearReconstructEveryK(3) should be used to save 10 time steps. The number of time steps per period can be computed by: from fdtdx import constants wavelength = 1.55e-6 period = constants . wavelength_to_period ( wavelength ) steps_per_period = period / config . time_step_duration","title":"Gradient computation by time reversibility"},{"location":"tutorials/interface_compression/#gradient-computation","text":"The actual gradient computation can be invoked using the standard jax.grad method on the fdtd_reversible function call. In pseudocode this might look something like this: def loss_function ( params , ... ) arrays , new_objects , info = apply_params ( arrays , objects , params , key ) _ , arrays = reversible_fdtd ( arrays = arrays , objects = new_objects , config = config , key = key , ) loss = - figure_of_merit ( arrays . detector_states ) return loss grad_function = jax . grad ( loss_fn ) grad_loss_wrt_params = grad_function ( params ) Of course figure_of_merit can be any objective function that should be optimized. The apply_params function internally calls the Parameter mapping of the device and sets the proper inverse permittivities for the simulation.","title":"Gradient Computation"},{"location":"tutorials/jax_introduction/","text":"Introduction to JAX JAX is a high-performance numerical computing library developed by Google that brings together the familiar NumPy API with powerful features like automatic differentiation, just-in-time (JIT) compilation, and seamless GPU/TPU acceleration. Originally designed for machine learning research, JAX has become popular across scientific computing applications due to its speed and flexibility. Jax itself provides a good introduction here and here . Otherwise, the following is a small crash course. Functional Programming Paradigm JAX operates exclusively in a functional programming style, which means it requires you to write pure functions without side effects. This functional approach has several important implications: Pure Functions Only JAX functions cannot modify variables in-place or maintain internal state. Instead of operations like array[0] = 5, you must use functional equivalents like array.at[0].set(5) that return new arrays. # This won't work in JAX def bad_function ( x ): x [ 0 ] = x [ 0 ] + 1 # In-place modification return x # This is the JAX way def good_function ( x ): return x . at [ 0 ] . add ( 1 ) # Returns new array No Side Effects Functions should not print to console, write to files, or modify global variables during compilation. JAX's JIT compiler optimizes based on the assumption that functions are deterministic and side-effect free. Immutable Data Arrays and other data structures are treated as immutable. Operations create new objects rather than modifying existing ones, similar to how NumPy handles broadcasting operations. This functional constraint enables JAX's powerful transformations like jit (compilation), grad (automatic differentiation), vmap (vectorization), and pmap (parallelization). While the functional style requires some adjustment if you're used to imperative programming, it unlocks JAX's ability to automatically optimize and transform your numerical code in ways that would be impossible with stateful operations. TreeClass Objects in FDTDX FDTDX leverages JAX's functional programming paradigm through a specialized TreeClass system that makes it easy to work with complex hierarchical data structures while maintaining JAX compatibility. The TreeClass provides a clean, object-oriented interface that automatically integrates with JAX's pytree system, allowing for seamless use with JAX transformations. TreeClass Structure The TreeClass system uses dataclass-like syntax with the @fdtdx.autoinit decorator to automatically generate initialization methods. Here's how it works: import fdtdx @fdtdx . autoinit class A ( fdtdx . TreeClass ): a : float = 2 x : int = 5 @fdtdx . autoinit class B ( fdtdx . TreeClass ): a1 : A z : int = 7 @fdtdx . autoinit class C ( fdtdx . TreeClass ): b_list : list [ B ] c : float = 2 These classes can be nested arbitrarily deep and contain lists, dictionaries, or other complex data structures. The @fdtdx.autoinit decorator automatically generates init methods that handle default values and type checking. Working with TreeClass Instances # Create instances with default or custom values b = B ( a1 = A ()) # Uses defaults: A(a=2, x=5), z=7 b = b . aset ( \"z\" , 7 ) # Functional update # Create more complex nested structures b2 = B ( a1 = A ( a = 10 , x = 11 ), z = 12 ) b3 = B ( a1 = A ( a = 20 , x = 21 ), z = 22 ) # Collections of TreeClass instances c = C ( b_list = [ b , b2 ]) # Deep nested updates using path syntax c2 = c . aset ( \"b_list->[0]->a1->a\" , 100 ) The aset Method: Functional Updates Made Easy The aset method is the cornerstone of FDTDX's functional approach. Unlike JAX's standard .at[].set() which only works on pytree leaf nodes (typically arrays), aset can update any attribute at any level of nesting within a TreeClass hierarchy. Path Syntax: The method uses an intuitive string-based path syntax to navigate nested structures: \"attribute\" - Direct attribute access \"a->b\" - Nested attribute access (a.b) \"a->[0]\" - List indexing \"a->['key']\" - Dictionary key access \"b_list->[0]->a1->a\" - Complex nested path In the example c2 = c.aset(\"b_list->[0]->a1->a\", 100), this path means: - Access the b_list attribute of c - Get the first element [0] of that list - Access the a1 attribute of that element - Access the a attribute of a1 - Set that value to 100 The method returns a completely new instance with the updated value, maintaining JAX's functional programming requirements. This allows FDTDX data structures to be used seamlessly with JAX transformations like jit, grad, and vmap, while providing a much more intuitive interface than manually reconstructing nested data structures. This approach bridges the gap between JAX's powerful functional capabilities and the practical need for complex, hierarchical data management in scientific computing applications. How JAX is used in FDTDX For a full example on how to use JAX with fdtdx, check out this example or this example . The script demonstrates FDTDX's seamless integration with JAX's jit transformation. The core simulation function sim_fn takes FDTDX TreeClass structures as arguments and is JIT-compiled: def sim_fn ( params : fdtdx . ParameterContainer , arrays : fdtdx . ArrayContainer , key : jax . Array , ): # Complex FDTD simulation logic with TreeClass structures arrays , new_objects , info = fdtdx . apply_params ( arrays , objects , params , key ) final_state = fdtdx . run_fdtd ( arrays = arrays , objects = new_objects , config = config , key = key ) # ... more operations return arrays , new_info jitted_loss = jax . jit ( sim_fn , donate_argnames = [ \"arrays\" ]) . lower ( params , arrays , key ) . compile () JIT compilation with TreeClass arguments Key Features: TreeClass Compatibility: The ParameterContainer and ArrayContainer are FDTDX TreeClass structures that work seamlessly with jit. JAX automatically handles the pytree registration, allowing these complex nested structures to be compiled efficiently. Memory Optimization: The donate_argnames=[\"arrays\"] parameter tells JAX it can reuse the memory of the arrays argument, which is crucial for large electromagnetic field arrays in FDTD simulations. Compilation Pipeline: The script uses .lower().compile() to explicitly control the compilation process, providing timing information for performance analysis. While this specific example focuses on forward simulation, FDTDX is designed for gradient-based optimization. The GradientConfig setup shows how gradients would be computed: gradient_config = fdtdx . GradientConfig ( recorder = fdtdx . Recorder ( modules = [ fdtdx . DtypeConversion ( dtype = jnp . bfloat16 )] ) ) For gradient computation, you would typically use: # Hypothetical gradient computation grad_fn = jax . grad ( sim_fn , argnums = 0 ) # Gradient w.r.t. params gradients = grad_fn ( params , arrays , key )","title":"JAX in FDTDX"},{"location":"tutorials/jax_introduction/#introduction-to-jax","text":"JAX is a high-performance numerical computing library developed by Google that brings together the familiar NumPy API with powerful features like automatic differentiation, just-in-time (JIT) compilation, and seamless GPU/TPU acceleration. Originally designed for machine learning research, JAX has become popular across scientific computing applications due to its speed and flexibility. Jax itself provides a good introduction here and here . Otherwise, the following is a small crash course.","title":"Introduction to JAX"},{"location":"tutorials/jax_introduction/#functional-programming-paradigm","text":"JAX operates exclusively in a functional programming style, which means it requires you to write pure functions without side effects. This functional approach has several important implications:","title":"Functional Programming Paradigm"},{"location":"tutorials/jax_introduction/#pure-functions-only","text":"JAX functions cannot modify variables in-place or maintain internal state. Instead of operations like array[0] = 5, you must use functional equivalents like array.at[0].set(5) that return new arrays. # This won't work in JAX def bad_function ( x ): x [ 0 ] = x [ 0 ] + 1 # In-place modification return x # This is the JAX way def good_function ( x ): return x . at [ 0 ] . add ( 1 ) # Returns new array","title":"Pure Functions Only"},{"location":"tutorials/jax_introduction/#no-side-effects","text":"Functions should not print to console, write to files, or modify global variables during compilation. JAX's JIT compiler optimizes based on the assumption that functions are deterministic and side-effect free.","title":"No Side Effects"},{"location":"tutorials/jax_introduction/#immutable-data","text":"Arrays and other data structures are treated as immutable. Operations create new objects rather than modifying existing ones, similar to how NumPy handles broadcasting operations. This functional constraint enables JAX's powerful transformations like jit (compilation), grad (automatic differentiation), vmap (vectorization), and pmap (parallelization). While the functional style requires some adjustment if you're used to imperative programming, it unlocks JAX's ability to automatically optimize and transform your numerical code in ways that would be impossible with stateful operations.","title":"Immutable Data"},{"location":"tutorials/jax_introduction/#treeclass-objects-in-fdtdx","text":"FDTDX leverages JAX's functional programming paradigm through a specialized TreeClass system that makes it easy to work with complex hierarchical data structures while maintaining JAX compatibility. The TreeClass provides a clean, object-oriented interface that automatically integrates with JAX's pytree system, allowing for seamless use with JAX transformations.","title":"TreeClass Objects in FDTDX"},{"location":"tutorials/jax_introduction/#treeclass-structure","text":"The TreeClass system uses dataclass-like syntax with the @fdtdx.autoinit decorator to automatically generate initialization methods. Here's how it works: import fdtdx @fdtdx . autoinit class A ( fdtdx . TreeClass ): a : float = 2 x : int = 5 @fdtdx . autoinit class B ( fdtdx . TreeClass ): a1 : A z : int = 7 @fdtdx . autoinit class C ( fdtdx . TreeClass ): b_list : list [ B ] c : float = 2 These classes can be nested arbitrarily deep and contain lists, dictionaries, or other complex data structures. The @fdtdx.autoinit decorator automatically generates init methods that handle default values and type checking.","title":"TreeClass Structure"},{"location":"tutorials/jax_introduction/#working-with-treeclass-instances","text":"# Create instances with default or custom values b = B ( a1 = A ()) # Uses defaults: A(a=2, x=5), z=7 b = b . aset ( \"z\" , 7 ) # Functional update # Create more complex nested structures b2 = B ( a1 = A ( a = 10 , x = 11 ), z = 12 ) b3 = B ( a1 = A ( a = 20 , x = 21 ), z = 22 ) # Collections of TreeClass instances c = C ( b_list = [ b , b2 ]) # Deep nested updates using path syntax c2 = c . aset ( \"b_list->[0]->a1->a\" , 100 )","title":"Working with TreeClass Instances"},{"location":"tutorials/jax_introduction/#the-aset-method-functional-updates-made-easy","text":"The aset method is the cornerstone of FDTDX's functional approach. Unlike JAX's standard .at[].set() which only works on pytree leaf nodes (typically arrays), aset can update any attribute at any level of nesting within a TreeClass hierarchy.","title":"The aset Method: Functional Updates Made Easy"},{"location":"tutorials/jax_introduction/#path-syntax-the-method-uses-an-intuitive-string-based-path-syntax-to-navigate-nested-structures","text":"\"attribute\" - Direct attribute access \"a->b\" - Nested attribute access (a.b) \"a->[0]\" - List indexing \"a->['key']\" - Dictionary key access \"b_list->[0]->a1->a\" - Complex nested path In the example c2 = c.aset(\"b_list->[0]->a1->a\", 100), this path means: - Access the b_list attribute of c - Get the first element [0] of that list - Access the a1 attribute of that element - Access the a attribute of a1 - Set that value to 100 The method returns a completely new instance with the updated value, maintaining JAX's functional programming requirements. This allows FDTDX data structures to be used seamlessly with JAX transformations like jit, grad, and vmap, while providing a much more intuitive interface than manually reconstructing nested data structures. This approach bridges the gap between JAX's powerful functional capabilities and the practical need for complex, hierarchical data management in scientific computing applications.","title":"Path Syntax: The method uses an intuitive string-based path syntax to navigate nested structures:"},{"location":"tutorials/jax_introduction/#how-jax-is-used-in-fdtdx","text":"For a full example on how to use JAX with fdtdx, check out this example or this example . The script demonstrates FDTDX's seamless integration with JAX's jit transformation. The core simulation function sim_fn takes FDTDX TreeClass structures as arguments and is JIT-compiled: def sim_fn ( params : fdtdx . ParameterContainer , arrays : fdtdx . ArrayContainer , key : jax . Array , ): # Complex FDTD simulation logic with TreeClass structures arrays , new_objects , info = fdtdx . apply_params ( arrays , objects , params , key ) final_state = fdtdx . run_fdtd ( arrays = arrays , objects = new_objects , config = config , key = key ) # ... more operations return arrays , new_info jitted_loss = jax . jit ( sim_fn , donate_argnames = [ \"arrays\" ]) . lower ( params , arrays , key ) . compile ()","title":"How JAX is used in FDTDX"},{"location":"tutorials/jax_introduction/#jit-compilation-with-treeclass-arguments","text":"Key Features: TreeClass Compatibility: The ParameterContainer and ArrayContainer are FDTDX TreeClass structures that work seamlessly with jit. JAX automatically handles the pytree registration, allowing these complex nested structures to be compiled efficiently. Memory Optimization: The donate_argnames=[\"arrays\"] parameter tells JAX it can reuse the memory of the arrays argument, which is crucial for large electromagnetic field arrays in FDTD simulations. Compilation Pipeline: The script uses .lower().compile() to explicitly control the compilation process, providing timing information for performance analysis. While this specific example focuses on forward simulation, FDTDX is designed for gradient-based optimization. The GradientConfig setup shows how gradients would be computed: gradient_config = fdtdx . GradientConfig ( recorder = fdtdx . Recorder ( modules = [ fdtdx . DtypeConversion ( dtype = jnp . bfloat16 )] ) ) For gradient computation, you would typically use: # Hypothetical gradient computation grad_fn = jax . grad ( sim_fn , argnums = 0 ) # Gradient w.r.t. params gradients = grad_fn ( params , arrays , key )","title":"JIT compilation with TreeClass arguments"},{"location":"tutorials/materials/","text":"Materials Guide In FDTDX, objects can have different permittivities and permeabilities. Currently, the conductivity of all materials is assumed to be zero, but we are planning to implement conductive materials in the very near future. Also, currently neither dispersion nor non-linear materials are implemented. The implementation of dispersion is scheduled in the near-mid future and afterwards an implementation of non-linear materials will follow. This guide is currently very short and will be expanded with them implementations mentioned above. UniformMaterial The most basic and also probably most useful object is the UniformMaterialObject. As the name suggests, it has a single material. from fdtdx import ( constants , UniformMaterialObject , Material , colors , ) uniform_obj = UniformMaterialObject ( partial_real_shape = ( 0.6e-6 , 0.6e-6 , 0.6e-6 ), material = Material ( permittivity = constants . relative_permittivity_silica ), # permeability is one by default permeability = 1.0 , color = colors . CYAN , name = \"uniform_obj\" , ) The name and color attribute are only used for plotting and do not have any effect on the simulation. Device For inverse design, it is necessary to model objects that can either be one or the other materials. In some applications, it might even be necessary to model objects consisting of more than two materials. In this example, we create a device consisting of voxels that are either air or polymer. material_config = { \"Air\" : Material ( permittivity = constants . relative_permittivity_air ), \"Polymer\" : Material ( permittivity = constants . relative_permittivity_ma_N_1400_series ), } device = Device ( name = \"Device\" , partial_real_shape = ( 1e-6 , 1e-6 , 1e-6 ), material = material_config , parameter_mapping =... , partial_voxel_real_shape = ( 0.2e-6 , 0.2e-6 , 0.2e-6 ), ) The device has a permittivity config, which defines the different permittivity options. This is currently only implemented for permittivity, but we will expand it in the future to metallic materials as well. The partial_voxel_real_shape argument specifies the size of the uniform material voxels within the device. In this case, voxels, of 200nm^3 have a single permittivity. Since the device has a shape of 1\u00b5m^3, there are 5x5x5=125 of these voxels within the device. Importantly, the size of the device needs to be divisible by the voxel size. Additionally, the voxel size needs to be suffiently larger than the resolution of the Yee-grid in the simulation. For example, if the resolution of the Yee-grid is also 200nm, then this simulation will not produce accurate results. As a rule of thumb, the resolution of the Yee-grid should be at least three times smaller than the size of the voxels. The device has one latent parameter for every voxel. Initially, these latent parameters are uniformly random in the interval [0, 1]. The constraint mapping defines how these latent parameters are mapped to actual inverse permittivity choices. A detailed guide on this topic can be found here .","title":"Materials Guide"},{"location":"tutorials/materials/#materials-guide","text":"In FDTDX, objects can have different permittivities and permeabilities. Currently, the conductivity of all materials is assumed to be zero, but we are planning to implement conductive materials in the very near future. Also, currently neither dispersion nor non-linear materials are implemented. The implementation of dispersion is scheduled in the near-mid future and afterwards an implementation of non-linear materials will follow. This guide is currently very short and will be expanded with them implementations mentioned above.","title":"Materials Guide"},{"location":"tutorials/materials/#uniformmaterial","text":"The most basic and also probably most useful object is the UniformMaterialObject. As the name suggests, it has a single material. from fdtdx import ( constants , UniformMaterialObject , Material , colors , ) uniform_obj = UniformMaterialObject ( partial_real_shape = ( 0.6e-6 , 0.6e-6 , 0.6e-6 ), material = Material ( permittivity = constants . relative_permittivity_silica ), # permeability is one by default permeability = 1.0 , color = colors . CYAN , name = \"uniform_obj\" , ) The name and color attribute are only used for plotting and do not have any effect on the simulation.","title":"UniformMaterial"},{"location":"tutorials/materials/#device","text":"For inverse design, it is necessary to model objects that can either be one or the other materials. In some applications, it might even be necessary to model objects consisting of more than two materials. In this example, we create a device consisting of voxels that are either air or polymer. material_config = { \"Air\" : Material ( permittivity = constants . relative_permittivity_air ), \"Polymer\" : Material ( permittivity = constants . relative_permittivity_ma_N_1400_series ), } device = Device ( name = \"Device\" , partial_real_shape = ( 1e-6 , 1e-6 , 1e-6 ), material = material_config , parameter_mapping =... , partial_voxel_real_shape = ( 0.2e-6 , 0.2e-6 , 0.2e-6 ), ) The device has a permittivity config, which defines the different permittivity options. This is currently only implemented for permittivity, but we will expand it in the future to metallic materials as well. The partial_voxel_real_shape argument specifies the size of the uniform material voxels within the device. In this case, voxels, of 200nm^3 have a single permittivity. Since the device has a shape of 1\u00b5m^3, there are 5x5x5=125 of these voxels within the device. Importantly, the size of the device needs to be divisible by the voxel size. Additionally, the voxel size needs to be suffiently larger than the resolution of the Yee-grid in the simulation. For example, if the resolution of the Yee-grid is also 200nm, then this simulation will not produce accurate results. As a rule of thumb, the resolution of the Yee-grid should be at least three times smaller than the size of the voxels. The device has one latent parameter for every voxel. Initially, these latent parameters are uniformly random in the interval [0, 1]. The constraint mapping defines how these latent parameters are mapped to actual inverse permittivity choices. A detailed guide on this topic can be found here .","title":"Device"},{"location":"tutorials/object_placement/","text":"Object Placement Guide This guide explains how to position objects in a simulation scene in FDTDX. The basic workflow looks like this: 1. Define a Simulation volume 2. Define objects and sizing/placement constraints between objects 3. Compute the actual position of objects in the simulation scene by using the place_objects function 4. Optional, but recommend: Plot the simulation scene using plot_setup() 5. Run a simulation Basic Positioning In FDTDX, objects are positioned either directly or relation to other objects through constraints. The first step should always be to define the size of the simulation volume. FDTDX always uses metrical units, i.e. meters or grid positions referring to the Yee-grid, which depends on the resolution used. # create a simulation config config = SimulationConfig ( time = 200e-15 , resolution = 100e-9 ) # Create a simulation volume volume = SimulationVolume ( partial_real_shape = ( 4e-6 , 4e-6 , 1.5e-6 ), ) We can already use the place_objects and plot_setup function to see the simulation volume. key = jax . random . PRNGKey ( seed = 42 ) # random key # place objects and resolve constraints objects , arrays , params , config , info = place_objects ( volume = volume , config = config , constraints = [], key = key , ) # plot the simulation scene fig = plot_setup ( config = config , objects = objects , ) fig . savefig ( \"empty_scene.png\" ) Now, we can start to position some objects in the simulation scene. We start with a substrate at the bottom of simulation. To this end, we specify a constraint that aligns the objects in the z-axis (axis 2). The user should specify these constraints and collect them in a list. Positional constraints define an anchor point for both objects, which are constrainted to be at the same position. The position of the anchor point can be specified in a relative coordinate system of each object. A relative coordinate system means that a position of -1 would place the anchor at the left boundary of the object, a position of 0 at the middle and a position of 1 at the right boundary. In case of the substrate, we want the lower boundary of the substrate to be aligned with the lower boundary of the simulation volume. This ensures that the substrate is placed exactly at the bottom of the simulation. # create list of constraints placement_constraints = [] # create substrate substrate = UniformMaterialObject ( partial_real_shape = ( None , None , 0.6e-6 ), material = Material ( permittivity = constants . relative_permittivity_silica ), ) # place at the bottom of simulation volume constraint = substrate . place_relative_to ( volume , axes = 2 , own_positions =- 1 , other_positions =- 1 , margins = 0 , grid_margins = 0 , ) placement_constraints . append ( constraint ) The margins and grid_margins arguments are optional and would allow to speficy a fixed distance between the anchor points. The margins argument is in units of meters, the grid margins in units of yee-grid cells. Plotting this again results in There exist a number of useful shorthands for rapid placements. Some of them are listed below that place a cube in the scene. The name and colors argument are only used for plotting. # place an object on top (z-axis / 2) of another object cube1 = UniformMaterialObject ( name = \"cube\" , color = colors . GREEN , partial_real_shape = ( 0.5e-6 , 0.5e-6 , 0.5e-6 ), material = Material ( permittivity = constants . relative_permittivity_silicon ), ) placement_constraints . append ( cube1 . place_above ( substrate ) ) # place an object at the center of another object placement_constraints . append ( cube1 . place_at_center ( substrate , axes = ( 0 , 1 ), ) ) Size Configuration Object sizes can be specified in a number of ways. Firstly, one can directly set the size of an object in the init method. This can either be a specified in Yee-grid cells or metrical units (meter). # size in meters cube = UniformMaterialObject ( partial_real_shape = ( 0.3e-6 , 1.0e-6 , 0.7e-6 ), ... ) Size in grid units # size in grid units (each 100nm as defined in config above) cube = UniformMaterialObject ( partial_grid_shape = ( 4 , 10 , 2 ), ... ) Combination of grid and metrical units # partial combination cube = UniformMaterialObject ( partial_real_shape = ( None , 0.5e-6 , None ), partial_grid_shape = ( 3 , None , 1 ), ... ) Undefined Sizes can be useful If the size of an object is only partially defined and does not have any constraints, the size is set to the size of the simulation volume in the respective axis. We actually already used this behavior to define the substrate above. # z-axis is undefined, size is extended to simulation size cube = UniformMaterialObject ( partial_real_shape = ( None , 0.5e-6 , None ), partial_grid_shape = ( 3 , None , None ), ... ) # This now results in an error: placement_constraints . append ( cube1 . place_above ( substrate ) ) Using this specification for the cube, we get the following error: Exception: Inconsisten grid shape (may be due to extension to infinity) at lower bound: 0 != 6 for axis=2, cube (<class 'fdtdx.objects.material.UniformMaterialObject'>). Object has a position constraint that puts the lower boundary at 6, but the lower bound was alreay computed to be at 0. This could be due to a missing size constraint/specification, which resulted in an expansion of the object to the simulation boundary (default size) or another constraint on this object. The error occurs, because we tried to place the cube above the substrate, which is no longer possible if the z-size of the cube is the whole simulation size. When we remove the problematic placement constraint, we get the correct simulation scene. Relative Sizing constraint The size of an object can also be set in relation to another object. To demonstrate this, we define a second cube, which should be placed above the substrate and have a 200nm distance to the other cube in the x-axis. cube2 = UniformMaterialObject ( name = \"cube2\" , color = colors . GREEN , partial_real_shape = ( 0.5e-6 , 0.5e-6 , 0.5e-6 ), material = Material ( permittivity = constants . relative_permittivity_silicon ), ) placement_constraints . extend ([ cube2 . place_above ( substrate ), cube2 . place_relative_to ( cube1 , axes = ( 0 , 1 ), own_positions = ( 1 , 0 ), other_positions = ( - 1 , 0 ), margins = ( - 200e-9 , 0 ) ) ]) Now let's change the size definition of the second cube to a relative size constraint, which defines the y-size of the second cube as the size of the first cube in the z-axis. cube2 = UniformMaterialObject ( name = \"cube2\" , color = colors . GREEN , partial_real_shape = ( 0.5e-6 , None , 0.5e-6 ), material = Material ( permittivity = constants . relative_permittivity_silicon ), ) placement_constraints . append ( cube2 . size_relative_to ( cube1 , axes = 1 , other_axes = 2 , proportions = 1.0 , ) ) Another useful convenience wrapper is the following: object1 . same_size ( object2 , axes = ( 0 , 1 )) Extending objects to other objects or Simulation boundaries The last method to set the size of an object is to constrain the size, such that it extends up to another object in the simulation scene. # definition of first cube cube1 = UniformMaterialObject ( partial_real_shape = ( 0.5e-6 , 0.5e-6 , 0.5e-6 ), name = \"cube\" , color = colors . GREEN , material = Material ( permittivity = constants . relative_permittivity_silicon ), ) placement_constraints . append ( cube1 . place_above ( substrate ) ) placement_constraints . append ( cube1 . place_at_center ( substrate , axes = ( 0 , 1 ), ) ) cube2 = UniformMaterialObject ( name = \"cube2\" , color = colors . MAGENTA , partial_real_shape = ( None , 0.5e-6 , 0.5e-6 ), material = Material ( permittivity = constants . relative_permittivity_silicon ), ) placement_constraints . extend ([ cube2 . place_above ( substrate ), # place at center of y-axis cube2 . place_at_center ( cube1 , axes = 1 , ), # extend object up to first cube cube2 . extend_to ( cube1 , axis = 0 , direction = \"+\" , ) ]) This constrains the size of cube2 such that its upper boundary (\"+\") extends directly up to cube1 in the x-axis. See the Objects API Reference for complete details on all positioning and sizing options.","title":"Object Placement"},{"location":"tutorials/object_placement/#object-placement-guide","text":"This guide explains how to position objects in a simulation scene in FDTDX. The basic workflow looks like this: 1. Define a Simulation volume 2. Define objects and sizing/placement constraints between objects 3. Compute the actual position of objects in the simulation scene by using the place_objects function 4. Optional, but recommend: Plot the simulation scene using plot_setup() 5. Run a simulation","title":"Object Placement Guide"},{"location":"tutorials/object_placement/#basic-positioning","text":"In FDTDX, objects are positioned either directly or relation to other objects through constraints. The first step should always be to define the size of the simulation volume. FDTDX always uses metrical units, i.e. meters or grid positions referring to the Yee-grid, which depends on the resolution used. # create a simulation config config = SimulationConfig ( time = 200e-15 , resolution = 100e-9 ) # Create a simulation volume volume = SimulationVolume ( partial_real_shape = ( 4e-6 , 4e-6 , 1.5e-6 ), ) We can already use the place_objects and plot_setup function to see the simulation volume. key = jax . random . PRNGKey ( seed = 42 ) # random key # place objects and resolve constraints objects , arrays , params , config , info = place_objects ( volume = volume , config = config , constraints = [], key = key , ) # plot the simulation scene fig = plot_setup ( config = config , objects = objects , ) fig . savefig ( \"empty_scene.png\" ) Now, we can start to position some objects in the simulation scene. We start with a substrate at the bottom of simulation. To this end, we specify a constraint that aligns the objects in the z-axis (axis 2). The user should specify these constraints and collect them in a list. Positional constraints define an anchor point for both objects, which are constrainted to be at the same position. The position of the anchor point can be specified in a relative coordinate system of each object. A relative coordinate system means that a position of -1 would place the anchor at the left boundary of the object, a position of 0 at the middle and a position of 1 at the right boundary. In case of the substrate, we want the lower boundary of the substrate to be aligned with the lower boundary of the simulation volume. This ensures that the substrate is placed exactly at the bottom of the simulation. # create list of constraints placement_constraints = [] # create substrate substrate = UniformMaterialObject ( partial_real_shape = ( None , None , 0.6e-6 ), material = Material ( permittivity = constants . relative_permittivity_silica ), ) # place at the bottom of simulation volume constraint = substrate . place_relative_to ( volume , axes = 2 , own_positions =- 1 , other_positions =- 1 , margins = 0 , grid_margins = 0 , ) placement_constraints . append ( constraint ) The margins and grid_margins arguments are optional and would allow to speficy a fixed distance between the anchor points. The margins argument is in units of meters, the grid margins in units of yee-grid cells. Plotting this again results in There exist a number of useful shorthands for rapid placements. Some of them are listed below that place a cube in the scene. The name and colors argument are only used for plotting. # place an object on top (z-axis / 2) of another object cube1 = UniformMaterialObject ( name = \"cube\" , color = colors . GREEN , partial_real_shape = ( 0.5e-6 , 0.5e-6 , 0.5e-6 ), material = Material ( permittivity = constants . relative_permittivity_silicon ), ) placement_constraints . append ( cube1 . place_above ( substrate ) ) # place an object at the center of another object placement_constraints . append ( cube1 . place_at_center ( substrate , axes = ( 0 , 1 ), ) )","title":"Basic Positioning"},{"location":"tutorials/object_placement/#size-configuration","text":"Object sizes can be specified in a number of ways. Firstly, one can directly set the size of an object in the init method. This can either be a specified in Yee-grid cells or metrical units (meter). # size in meters cube = UniformMaterialObject ( partial_real_shape = ( 0.3e-6 , 1.0e-6 , 0.7e-6 ), ... )","title":"Size Configuration"},{"location":"tutorials/object_placement/#size-in-grid-units","text":"# size in grid units (each 100nm as defined in config above) cube = UniformMaterialObject ( partial_grid_shape = ( 4 , 10 , 2 ), ... )","title":"Size in grid units"},{"location":"tutorials/object_placement/#combination-of-grid-and-metrical-units","text":"# partial combination cube = UniformMaterialObject ( partial_real_shape = ( None , 0.5e-6 , None ), partial_grid_shape = ( 3 , None , 1 ), ... )","title":"Combination of grid and metrical units"},{"location":"tutorials/object_placement/#undefined-sizes-can-be-useful","text":"If the size of an object is only partially defined and does not have any constraints, the size is set to the size of the simulation volume in the respective axis. We actually already used this behavior to define the substrate above. # z-axis is undefined, size is extended to simulation size cube = UniformMaterialObject ( partial_real_shape = ( None , 0.5e-6 , None ), partial_grid_shape = ( 3 , None , None ), ... ) # This now results in an error: placement_constraints . append ( cube1 . place_above ( substrate ) ) Using this specification for the cube, we get the following error: Exception: Inconsisten grid shape (may be due to extension to infinity) at lower bound: 0 != 6 for axis=2, cube (<class 'fdtdx.objects.material.UniformMaterialObject'>). Object has a position constraint that puts the lower boundary at 6, but the lower bound was alreay computed to be at 0. This could be due to a missing size constraint/specification, which resulted in an expansion of the object to the simulation boundary (default size) or another constraint on this object. The error occurs, because we tried to place the cube above the substrate, which is no longer possible if the z-size of the cube is the whole simulation size. When we remove the problematic placement constraint, we get the correct simulation scene.","title":"Undefined Sizes can be useful"},{"location":"tutorials/object_placement/#relative-sizing-constraint","text":"The size of an object can also be set in relation to another object. To demonstrate this, we define a second cube, which should be placed above the substrate and have a 200nm distance to the other cube in the x-axis. cube2 = UniformMaterialObject ( name = \"cube2\" , color = colors . GREEN , partial_real_shape = ( 0.5e-6 , 0.5e-6 , 0.5e-6 ), material = Material ( permittivity = constants . relative_permittivity_silicon ), ) placement_constraints . extend ([ cube2 . place_above ( substrate ), cube2 . place_relative_to ( cube1 , axes = ( 0 , 1 ), own_positions = ( 1 , 0 ), other_positions = ( - 1 , 0 ), margins = ( - 200e-9 , 0 ) ) ]) Now let's change the size definition of the second cube to a relative size constraint, which defines the y-size of the second cube as the size of the first cube in the z-axis. cube2 = UniformMaterialObject ( name = \"cube2\" , color = colors . GREEN , partial_real_shape = ( 0.5e-6 , None , 0.5e-6 ), material = Material ( permittivity = constants . relative_permittivity_silicon ), ) placement_constraints . append ( cube2 . size_relative_to ( cube1 , axes = 1 , other_axes = 2 , proportions = 1.0 , ) ) Another useful convenience wrapper is the following: object1 . same_size ( object2 , axes = ( 0 , 1 ))","title":"Relative Sizing constraint"},{"location":"tutorials/object_placement/#extending-objects-to-other-objects-or-simulation-boundaries","text":"The last method to set the size of an object is to constrain the size, such that it extends up to another object in the simulation scene. # definition of first cube cube1 = UniformMaterialObject ( partial_real_shape = ( 0.5e-6 , 0.5e-6 , 0.5e-6 ), name = \"cube\" , color = colors . GREEN , material = Material ( permittivity = constants . relative_permittivity_silicon ), ) placement_constraints . append ( cube1 . place_above ( substrate ) ) placement_constraints . append ( cube1 . place_at_center ( substrate , axes = ( 0 , 1 ), ) ) cube2 = UniformMaterialObject ( name = \"cube2\" , color = colors . MAGENTA , partial_real_shape = ( None , 0.5e-6 , 0.5e-6 ), material = Material ( permittivity = constants . relative_permittivity_silicon ), ) placement_constraints . extend ([ cube2 . place_above ( substrate ), # place at center of y-axis cube2 . place_at_center ( cube1 , axes = 1 , ), # extend object up to first cube cube2 . extend_to ( cube1 , axis = 0 , direction = \"+\" , ) ]) This constrains the size of cube2 such that its upper boundary (\"+\") extends directly up to cube1 in the x-axis. See the Objects API Reference for complete details on all positioning and sizing options.","title":"Extending objects to other objects or Simulation boundaries"},{"location":"tutorials/parameter_mapping/","text":"Incorporation of Fabrication Constraints When using inverse design with FDTDX, fabrication constraints have to be specified. The basic building block for an object optimizable by inverse design is a Device: from fdtdx import ( Device , constants , Material ) material_config = { \"Air\" : Material ( permittivity = constants . relative_permittivity_air ), \"Polymer\" : Material ( permittivity = constants . relative_permittivity_ma_N_1400_series ), } device_scatter = DiscreteDevice ( name = \"Device\" , partial_real_shape = ( 1e-6 , 1e-6 , 1e-6 ), material = material_config , param_transforms =... , # <- This needs to be filled partial_voxel_real_shape = ( 0.2e-6 , 0.2e-6 , 0.2e-6 ), ) The parameter mapping, which is left empty above, specifies the mapping from continuous latent parameters to materials used in the simulation. Simple example At the beginning of optimization, the latent parameters of a device are always initialized randomly in the interval [0, 1]. Depending on the constraint mapping, these parameteters are mapped to inverse permittivities. Let's look at an example of a simple constraint mapping: from fdtdx import ClosestIndex param_transforms = [ ClosestIndex ()] The constraint mapping consists of a chain of modules, or in other words a chain of transformations followed by a discretization. Let's look at the module in detail: - ClosestIndex(): This module quantizes the latent variables to the closest integer. Since latent parameters are initialized randomly in the interval [0, 1], this module maps the continuous parameters to either the index 0 or 1. Since this operation is not differentiable, we employ a straight-through-estimator (STE), which simply copies the gradient from the quantized values to the original values in the backward pass. This mapping constraints each voxel independently of the other voxels to the inverse permittivity of either air or polymer. However, often more elaborate fabrication constraints are needed in practice, which we introduce in the following sections. Silicon Device with minimum feature constraint Now let's develop a constraint mapping for silicon photonics, which restricts the minimum feature size of a device. from fdtdx import ( StandardToPlusOneMinusOneRange , BrushConstraint2D , circular_brush , ) brush_diameter_in_voxels = round ( 100e-9 / config . resolution ) param_transforms = [ StandardToPlusOneMinusOneRange () BrushConstraint2D ( brush = circular_brush ( diameter = brush_diameter_in_voxels ), axis = 2 , ), ] This mapping does not just quantize latent paramters to material indices, but also makes sure that the device adheres to a minimum feature size with regard to a specific brush. In this example, we used a circular brush of 100nm. In other words, one could \"paint\" the design with a brush of this size. In more detail: - StandardToPlusOneMinusOneRange(): maps the standard [0, 1] range to [-1, 1]. This is necessary, because the BrushConstraint2D expects the input to be in this range. - BrushConstraint2D(): maps the output of the previous module to permittivity indices similar to ClosestIndex() described above. However, it also makes sure that the design adheres to a minimum feature size regarding a specific brush shape. The axis argument defines the axis perpendicular to the 2D-design plane used. In our example, the perpendicular axis is 2 (in other words z/upwards). Therefore, the minimum feature constraint is enforced in the XY-plane. 3D Fabrication Constraints for Two-Photon-Polymerization Lastly, let's look at a more involved constraint mapping used to Two-Photon Polymerization (2PP). In 2PP, a laser is focused on liquid monomer to harden the material. This allows the creation of fully three-dimensional designs. Resulting from this fabrication technique multiple constraints arise. Firstly, basic physical knowledge tells us that no material can float in the air without a connection to the ground. In 3D-design, we have to explicitly incorporate this constraint, which was not necessary in 2D (in 2D, all voxels are always connected to the ground). Secondly, there cannot be enclosed air cavities in a design for 2PP. An enclosed cavity would trap unpolmerized monomer and destroy the structural integrity of the design. However, in practice it is often not necessary to explicitly encode this constraint in the simulation. Enclosed cavities seldomly increase a figure of merit and therefore only rarely appear in an optimized design. But, it is important to check after the simulation is finished if any enclosed cavitities exist in the design. from fdtdx import ( BOTTOM_Z_PADDING_CONFIG_REPEAT , BinaryMedianFilterModule , RemoveFloatingMaterial , ClosestIndex , ) param_transforms = [ ClosestIndex (), BinaryMedianFilterModule ( kernel_sizes = ( 5 , 5 , 5 ), padding_cfg = BOTTOM_Z_PADDING_CONFIG_REPEAT , num_repeats = 2 , ), RemoveFloatingMaterial (), ] This constraint mapping is one possibility to implement constraints for 2PP. The two new modules are: - BinaryMedianFilterModule: This module does a soft enforcement of a minimum feature size by smoothing the incoming indices (produced by the previous module) with a median filter. The kernel size describes the size of the smoothing kernel in Yee grid cells. The padding config describes how the boundaries of the design are padded for smoothing. The BOTTOM_Z_PADDING_CONFIG_REPEAT uses a repeat of the boundary values except at the bottom of the design, where the design is padded with non-air-material. Heuristically, this gives the design better ground contact. The num_repeats argument specifies how often the smoothing filter is applied. However, in contrast to the BrushConstraint2D, this is only an approximation and does not always enforce the minimum feature size. - RemoveFloatingMaterial: As the name suggests, this module goes through the indices generated by the previous module (BinaryMedianFilter) and removes any floating material without ground connection. Ground connection is computed using a simple flood fill algorithm and all voxels with floating material are converted to the background material (usually air).","title":"Fabrication Constraints"},{"location":"tutorials/parameter_mapping/#incorporation-of-fabrication-constraints","text":"When using inverse design with FDTDX, fabrication constraints have to be specified. The basic building block for an object optimizable by inverse design is a Device: from fdtdx import ( Device , constants , Material ) material_config = { \"Air\" : Material ( permittivity = constants . relative_permittivity_air ), \"Polymer\" : Material ( permittivity = constants . relative_permittivity_ma_N_1400_series ), } device_scatter = DiscreteDevice ( name = \"Device\" , partial_real_shape = ( 1e-6 , 1e-6 , 1e-6 ), material = material_config , param_transforms =... , # <- This needs to be filled partial_voxel_real_shape = ( 0.2e-6 , 0.2e-6 , 0.2e-6 ), ) The parameter mapping, which is left empty above, specifies the mapping from continuous latent parameters to materials used in the simulation.","title":"Incorporation of Fabrication Constraints"},{"location":"tutorials/parameter_mapping/#simple-example","text":"At the beginning of optimization, the latent parameters of a device are always initialized randomly in the interval [0, 1]. Depending on the constraint mapping, these parameteters are mapped to inverse permittivities. Let's look at an example of a simple constraint mapping: from fdtdx import ClosestIndex param_transforms = [ ClosestIndex ()] The constraint mapping consists of a chain of modules, or in other words a chain of transformations followed by a discretization. Let's look at the module in detail: - ClosestIndex(): This module quantizes the latent variables to the closest integer. Since latent parameters are initialized randomly in the interval [0, 1], this module maps the continuous parameters to either the index 0 or 1. Since this operation is not differentiable, we employ a straight-through-estimator (STE), which simply copies the gradient from the quantized values to the original values in the backward pass. This mapping constraints each voxel independently of the other voxels to the inverse permittivity of either air or polymer. However, often more elaborate fabrication constraints are needed in practice, which we introduce in the following sections.","title":"Simple example"},{"location":"tutorials/parameter_mapping/#silicon-device-with-minimum-feature-constraint","text":"Now let's develop a constraint mapping for silicon photonics, which restricts the minimum feature size of a device. from fdtdx import ( StandardToPlusOneMinusOneRange , BrushConstraint2D , circular_brush , ) brush_diameter_in_voxels = round ( 100e-9 / config . resolution ) param_transforms = [ StandardToPlusOneMinusOneRange () BrushConstraint2D ( brush = circular_brush ( diameter = brush_diameter_in_voxels ), axis = 2 , ), ] This mapping does not just quantize latent paramters to material indices, but also makes sure that the device adheres to a minimum feature size with regard to a specific brush. In this example, we used a circular brush of 100nm. In other words, one could \"paint\" the design with a brush of this size. In more detail: - StandardToPlusOneMinusOneRange(): maps the standard [0, 1] range to [-1, 1]. This is necessary, because the BrushConstraint2D expects the input to be in this range. - BrushConstraint2D(): maps the output of the previous module to permittivity indices similar to ClosestIndex() described above. However, it also makes sure that the design adheres to a minimum feature size regarding a specific brush shape. The axis argument defines the axis perpendicular to the 2D-design plane used. In our example, the perpendicular axis is 2 (in other words z/upwards). Therefore, the minimum feature constraint is enforced in the XY-plane.","title":"Silicon Device with minimum feature constraint"},{"location":"tutorials/parameter_mapping/#3d-fabrication-constraints-for-two-photon-polymerization","text":"Lastly, let's look at a more involved constraint mapping used to Two-Photon Polymerization (2PP). In 2PP, a laser is focused on liquid monomer to harden the material. This allows the creation of fully three-dimensional designs. Resulting from this fabrication technique multiple constraints arise. Firstly, basic physical knowledge tells us that no material can float in the air without a connection to the ground. In 3D-design, we have to explicitly incorporate this constraint, which was not necessary in 2D (in 2D, all voxels are always connected to the ground). Secondly, there cannot be enclosed air cavities in a design for 2PP. An enclosed cavity would trap unpolmerized monomer and destroy the structural integrity of the design. However, in practice it is often not necessary to explicitly encode this constraint in the simulation. Enclosed cavities seldomly increase a figure of merit and therefore only rarely appear in an optimized design. But, it is important to check after the simulation is finished if any enclosed cavitities exist in the design. from fdtdx import ( BOTTOM_Z_PADDING_CONFIG_REPEAT , BinaryMedianFilterModule , RemoveFloatingMaterial , ClosestIndex , ) param_transforms = [ ClosestIndex (), BinaryMedianFilterModule ( kernel_sizes = ( 5 , 5 , 5 ), padding_cfg = BOTTOM_Z_PADDING_CONFIG_REPEAT , num_repeats = 2 , ), RemoveFloatingMaterial (), ] This constraint mapping is one possibility to implement constraints for 2PP. The two new modules are: - BinaryMedianFilterModule: This module does a soft enforcement of a minimum feature size by smoothing the incoming indices (produced by the previous module) with a median filter. The kernel size describes the size of the smoothing kernel in Yee grid cells. The padding config describes how the boundaries of the design are padded for smoothing. The BOTTOM_Z_PADDING_CONFIG_REPEAT uses a repeat of the boundary values except at the bottom of the design, where the design is padded with non-air-material. Heuristically, this gives the design better ground contact. The num_repeats argument specifies how often the smoothing filter is applied. However, in contrast to the BrushConstraint2D, this is only an approximation and does not always enforce the minimum feature size. - RemoveFloatingMaterial: As the name suggests, this module goes through the indices generated by the previous module (BinaryMedianFilter) and removes any floating material without ground connection. Ground connection is computed using a simple flood fill algorithm and all voxels with floating material are converted to the background material (usually air).","title":"3D Fabrication Constraints for Two-Photon-Polymerization"}]}
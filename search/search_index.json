{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FDTDX Documentation","text":"<p>FDTDX is a high-performance framework for electromagnetic simulations and inverse design of photonic devices. Built on JAX, it provides GPU-accelerated FDTD (Finite-Difference Time-Domain) simulations with automatic differentiation capabilities.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install FDTDX using pip:</p> <pre><code>pip install fdtdx\n</code></pre> <p>For development installation, clone the repository and install in editable mode:</p> <pre><code>git clone https://github.com/ymahlau/fdtdx\ncd fdtdx\npip install -e .\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#high-performance-computing","title":"High Performance Computing","text":"<ul> <li>Native GPU acceleration through JAX</li> <li>Multi-GPU scaling for large simulations </li> <li>Memory-efficient time-reversal implementation</li> <li>Optimized for large-scale inverse design</li> <li>Flexible boundary conditions with PML support</li> </ul>"},{"location":"#guides","title":"Guides","text":"<ul> <li>Object Placement Guide - Learn how to position and configure simulation objects</li> <li>Materials Guide - Learn how to use materials in FDTDX</li> <li>Fabrication Constraints - Learn how to use the constraint mapping API to include fabrication constraints</li> <li>Interface Compression - Learn how to use The compresion API to compute gradients with reversible autodiff</li> <li>See the examples folder for complete scripts for inverse design in FDTDX</li> <li>More guides will follow shortly</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you find this repository helpful for your work, please consider citing:</p> <pre><code>@article{schubert2024quantized,\n  title={Quantized Inverse Design for Photonic Integrated Circuits},\n  author={Schubert, Frederik and Mahlau, Yannik and Bethmann, Konrad and Hartmann, Fabian and Caspary, Reinhard and Munderloh, Marco and Ostermann, J{\\\"o}rn and Rosenhahn, Bodo},\n  journal={arXiv preprint arXiv:2407.10273},\n  year={2024}\n}\n</code></pre>"},{"location":"api/","title":"API Documentation","text":"<p>The FDTDX API is organized into several main components:</p>"},{"location":"api/#core-package","title":"Core Package","text":"<p>The Core package provides fundamental data structures and utilities: - Configuration management - JAX integration - Array operations - Distributed computing support</p>"},{"location":"api/#constraints","title":"Constraints","text":"<p>The Constraints package handles material and geometry constraints: - Material property mapping - Feature size control - Connectivity constraints - Binary operations</p>"},{"location":"api/#objects","title":"Objects","text":"<p>The Objects package defines simulation components: - Material definitions - Sources and detectors - Boundary conditions - Object positioning</p>"},{"location":"api/#physics","title":"Physics","text":"<p>The Physics package implements electromagnetic calculations: - Physical constants - Material properties - Field metrics - Mode solvers</p>"},{"location":"api/#fdtd","title":"FDTD","text":"<p>The FDTD package provides simulation algorithms: - Forward/backward propagation - FDTD implementations - Field updates - Curl operations</p>"},{"location":"api/#utilities","title":"Utilities","text":"<p>The Utilities package contains support functions: - Visualization tools - File conversion - Image processing - Debugging utilities</p>"},{"location":"api/constraints/","title":"Constraints","text":"<p>The constraints package provides tools for applying physical and geometric constraints during optimization.</p>"},{"location":"api/constraints/#components","title":"Components","text":"<ul> <li>Mapping - Constraint mapping functionality</li> <li>Modules - Base classes and transformation modules</li> <li>Utilities - Index generation and value matching utilities  </li> <li>Binary Operations - Morphological operations and connectivity analysis</li> <li>Discrete Constraints - Material connectivity and feature size control</li> </ul>"},{"location":"api/constraints/binary/","title":"Binary Operations","text":""},{"location":"api/constraints/binary/#morphological-operations","title":"Morphological Operations","text":""},{"location":"api/constraints/binary/#fdtdx.constraints.binary_transform.dilate_jax","title":"<code>fdtdx.constraints.binary_transform.dilate_jax(image, kernel)</code>","text":"<p>Performs morphological dilation on a binary image using JAX.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>Binary input array to be dilated.</p> required <code>kernel</code> <code>Array</code> <p>Binary kernel defining the dilation shape.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Dilated binary array.</p> Source code in <code>src/fdtdx/constraints/binary_transform.py</code> <pre><code>def dilate_jax(image: jax.Array, kernel: jax.Array) -&gt; jax.Array:\n    \"\"\"Performs morphological dilation on a binary image using JAX.\n\n    Args:\n        image: Binary input array to be dilated.\n        kernel: Binary kernel defining the dilation shape.\n\n    Returns:\n        Dilated binary array.\n    \"\"\"\n    conv = jax.scipy.signal.convolve2d(image, kernel, mode=\"same\", boundary=\"fill\")\n    binary_arr = jnp.asarray(conv, dtype=bool)\n    return binary_arr\n</code></pre>"},{"location":"api/constraints/binary/#fdtdx.constraints.binary_transform.erode_jax","title":"<code>fdtdx.constraints.binary_transform.erode_jax(image, kernel)</code>","text":"<p>Performs morphological erosion on a binary image using JAX.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>Binary input array to be eroded.</p> required <code>kernel</code> <code>Array</code> <p>Binary kernel defining the erosion shape.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Eroded binary array.</p> Source code in <code>src/fdtdx/constraints/binary_transform.py</code> <pre><code>def erode_jax(image: jax.Array, kernel: jax.Array) -&gt; jax.Array:\n    \"\"\"Performs morphological erosion on a binary image using JAX.\n\n    Args:\n        image: Binary input array to be eroded.\n        kernel: Binary kernel defining the erosion shape.\n\n    Returns:\n        Eroded binary array.\n    \"\"\"\n    conv = jax.scipy.signal.convolve2d(~image, kernel, mode=\"same\", boundary=\"fill\")\n    binary_arr = jnp.asarray(conv, dtype=bool)\n    return ~binary_arr\n</code></pre>"},{"location":"api/constraints/binary/#fdtdx.constraints.binary_transform.seperated_3d_dilation","title":"<code>fdtdx.constraints.binary_transform.seperated_3d_dilation(arr_3d, kernel_xy, kernel_yz, kernel_xz, reduction_arr)</code>","text":"<p>Performs separated 3D dilation along each axis plane.</p> <p>Applies 2D dilation kernels separately in the XY, YZ, and XZ planes to approximate 3D dilation while being more computationally efficient. The result is masked by the reduction array after each operation.</p> <p>Parameters:</p> Name Type Description Default <code>arr_3d</code> <code>Array</code> <p>3D binary array to be dilated.</p> required <code>kernel_xy</code> <code>Array</code> <p>2D kernel for XY plane dilation.</p> required <code>kernel_yz</code> <code>Array</code> <p>2D kernel for YZ plane dilation.</p> required <code>kernel_xz</code> <code>Array</code> <p>2D kernel for XZ plane dilation.</p> required <code>reduction_arr</code> <code>Array</code> <p>Binary mask to constrain dilation results.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Dilated 3D binary array.</p> Source code in <code>src/fdtdx/constraints/binary_transform.py</code> <pre><code>def seperated_3d_dilation(\n    arr_3d: jax.Array,\n    kernel_xy: jax.Array,\n    kernel_yz: jax.Array,\n    kernel_xz: jax.Array,\n    reduction_arr: jax.Array,\n) -&gt; jax.Array:\n    \"\"\"Performs separated 3D dilation along each axis plane.\n\n    Applies 2D dilation kernels separately in the XY, YZ, and XZ planes\n    to approximate 3D dilation while being more computationally efficient.\n    The result is masked by the reduction array after each operation.\n\n    Args:\n        arr_3d: 3D binary array to be dilated.\n        kernel_xy: 2D kernel for XY plane dilation.\n        kernel_yz: 2D kernel for YZ plane dilation.\n        kernel_xz: 2D kernel for XZ plane dilation.\n        reduction_arr: Binary mask to constrain dilation results.\n\n    Returns:\n        Dilated 3D binary array.\n    \"\"\"\n\n    def convolve_partial(image: jax.Array, kernel: jax.Array):\n        return jax.scipy.signal.convolve2d(image, kernel, mode=\"same\", boundary=\"fill\")\n\n    arr_3d = jax.vmap(convolve_partial, in_axes=(2, None), out_axes=(2))(arr_3d, kernel_xy)\n    arr_3d = jnp.asarray(arr_3d, dtype=bool)\n    arr_3d = arr_3d &amp; reduction_arr\n\n    arr_3d = jax.vmap(convolve_partial, in_axes=(1, None), out_axes=(1))(arr_3d, kernel_xz)\n    arr_3d = jnp.asarray(arr_3d, dtype=bool)\n    arr_3d = arr_3d &amp; reduction_arr\n\n    arr_3d = jax.vmap(convolve_partial, in_axes=(0, None), out_axes=(0))(arr_3d, kernel_yz)\n    arr_3d = jnp.asarray(arr_3d, dtype=bool)\n    arr_3d = arr_3d &amp; reduction_arr\n\n    return arr_3d\n</code></pre>"},{"location":"api/constraints/binary/#fdtdx.constraints.binary_transform.binary_median_filter","title":"<code>fdtdx.constraints.binary_transform.binary_median_filter(arr_3d, kernel_sizes, padding_cfg)</code>","text":"<p>Applies a binary median filter to a 3D array.</p> <p>Implements a median filter for binary data by using convolution and thresholding. The filter is applied separately along each axis using the specified kernel sizes.</p> <p>Parameters:</p> Name Type Description Default <code>arr_3d</code> <code>Array</code> <p>3D binary input array.</p> required <code>kernel_sizes</code> <code>tuple[int, int, int]</code> <p>Tuple of (kx, ky, kz) specifying filter size in each dimension.</p> required <code>padding_cfg</code> <code>PaddingConfig</code> <p>Configuration for padding the input array.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Filtered binary array.</p> Source code in <code>src/fdtdx/constraints/binary_transform.py</code> <pre><code>def binary_median_filter(\n    arr_3d: jax.Array,\n    kernel_sizes: tuple[int, int, int],\n    padding_cfg: PaddingConfig,\n) -&gt; jax.Array:\n    \"\"\"Applies a binary median filter to a 3D array.\n\n    Implements a median filter for binary data by using convolution\n    and thresholding. The filter is applied separately along each axis\n    using the specified kernel sizes.\n\n    Args:\n        arr_3d: 3D binary input array.\n        kernel_sizes: Tuple of (kx, ky, kz) specifying filter size in each dimension.\n        padding_cfg: Configuration for padding the input array.\n\n    Returns:\n        Filtered binary array.\n    \"\"\"\n    # padding\n    padded_arr, orig_slice = advanced_padding(arr_3d, padding_cfg)\n    padded_arr = padded_arr.astype(jnp.float32)\n    # create filter kernel and convolve (avg filter)\n    for axis, k_size in enumerate(kernel_sizes):\n        shape_list = [1, 1, 1]\n        shape_list[axis] = k_size\n        shape_tpl = tuple(shape_list)\n        kernel = jnp.ones(shape=shape_tpl, dtype=jnp.float32)\n        padded_arr = jax.scipy.signal.convolve(padded_arr, kernel, mode=\"same\", method=\"direct\")\n    # discretize again to get median\n    kernel_sum = jnp.prod(jnp.asarray(kernel_sizes))\n    result = padded_arr / kernel_sum\n    result = result[orig_slice]\n    result = jnp.round(result).astype(arr_3d.dtype)\n    return result\n</code></pre>"},{"location":"api/constraints/binary/#connectivity-analysis","title":"Connectivity Analysis","text":""},{"location":"api/constraints/binary/#fdtdx.constraints.binary_transform.compute_polymer_connection","title":"<code>fdtdx.constraints.binary_transform.compute_polymer_connection(matrix, connected_slice=None)</code>","text":"<p>Computes a mask of polymer regions connected to specified points.</p> <p>Uses iterative dilation to identify polymer regions (ones in the matrix) that are connected either to the bottom layer or to specified points in connected_slice.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Array</code> <p>Binary array where 1 represents polymer and 0 represents air.</p> required <code>connected_slice</code> <code>tuple[int | None, int | None, int | None] | None</code> <p>Optional tuple of indices specifying starting points            for the connection computation. If None, uses bottom layer.</p> <code>None</code> <p>Returns:</p> Type Description <code>Array</code> <p>Boolean array marking connected polymer regions.</p> Source code in <code>src/fdtdx/constraints/binary_transform.py</code> <pre><code>def compute_polymer_connection(\n    matrix: jax.Array,\n    connected_slice: tuple[int | None, int | None, int | None] | None = None,\n) -&gt; jax.Array:\n    \"\"\"Computes a mask of polymer regions connected to specified points.\n\n    Uses iterative dilation to identify polymer regions (ones in the matrix)\n    that are connected either to the bottom layer or to specified points\n    in connected_slice.\n\n    Args:\n        matrix: Binary array where 1 represents polymer and 0 represents air.\n        connected_slice: Optional tuple of indices specifying starting points\n                       for the connection computation. If None, uses bottom layer.\n\n    Returns:\n        Boolean array marking connected polymer regions.\n    \"\"\"\n    n = max([matrix.shape[0], matrix.shape[1], matrix.shape[2]])\n    padded = False\n    if matrix.shape[2] == 1:\n        padded = True\n        matrix = jnp.pad(matrix, pad_width=((0, 0), (0, 0), (1, 1)))\n    n4_kernel = jnp.asarray(\n        [\n            [0, 1, 0],\n            [1, 1, 1],\n            [0, 1, 0],\n        ],\n        dtype=bool,\n    )\n    connected = jnp.zeros_like(matrix, dtype=bool)\n    if connected_slice is None:\n        connected = connected.at[..., 0].set(True)\n    else:\n        connected = connected.at[connected_slice].set(True)\n\n    def _body_fn(_, arr):\n        arr = seperated_3d_dilation(\n            arr_3d=arr,\n            kernel_xy=n4_kernel,\n            kernel_xz=n4_kernel,\n            kernel_yz=n4_kernel,\n            reduction_arr=matrix,\n        )\n        return arr\n\n    connected = jax.lax.fori_loop(0, n, _body_fn, connected)\n\n    if padded:\n        connected = connected[..., 1:2]\n    return connected\n</code></pre>"},{"location":"api/constraints/binary/#fdtdx.constraints.binary_transform.compute_air_connection","title":"<code>fdtdx.constraints.binary_transform.compute_air_connection(matrix)</code>","text":"<p>Computes a mask of air regions connected to the boundaries.</p> <p>Uses iterative dilation to identify air regions (zeros in the matrix) that are connected to the simulation boundaries. This is used to ensure proper ventilation in the structure.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Array</code> <p>Binary array where 1 represents polymer and 0 represents air.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Boolean array marking air regions connected to boundaries.</p> Source code in <code>src/fdtdx/constraints/binary_transform.py</code> <pre><code>def compute_air_connection(matrix: jax.Array) -&gt; jax.Array:\n    \"\"\"Computes a mask of air regions connected to the boundaries.\n\n    Uses iterative dilation to identify air regions (zeros in the matrix)\n    that are connected to the simulation boundaries. This is used to ensure\n    proper ventilation in the structure.\n\n    Args:\n        matrix: Binary array where 1 represents polymer and 0 represents air.\n\n    Returns:\n        Boolean array marking air regions connected to boundaries.\n    \"\"\"\n    inv_matrix = jnp.invert(matrix)\n    n = max([matrix.shape[0], matrix.shape[1], matrix.shape[2]])\n    n4_kernel = jnp.asarray(\n        [\n            [0, 1, 0],\n            [1, 1, 1],\n            [0, 1, 0],\n        ],\n        dtype=bool,\n    )\n    connected = jnp.zeros_like(inv_matrix, dtype=bool)\n    connected = connected.at[:, :, -1].set(True)\n    connected = connected.at[0, :, :].set(True)\n    connected = connected.at[-1, :, :].set(True)\n    connected = connected.at[:, 0, :].set(True)\n    connected = connected.at[:, -1, :].set(True)\n    connected = connected &amp; inv_matrix\n\n    def _body_fn(_, arr):\n        arr = seperated_3d_dilation(\n            arr_3d=arr,\n            kernel_xy=n4_kernel,\n            kernel_xz=n4_kernel,\n            kernel_yz=n4_kernel,\n            reduction_arr=inv_matrix,\n        )\n        return arr\n\n    connected = jax.lax.fori_loop(0, n, _body_fn, connected)\n\n    return connected\n</code></pre>"},{"location":"api/constraints/binary/#fdtdx.constraints.binary_transform.connect_slice","title":"<code>fdtdx.constraints.binary_transform.connect_slice(lower_slice, middle_slice, upper_slice, upper_save_points)</code>","text":"<p>Connects polymer regions between adjacent slices.</p> <p>Attempts to connect disconnected polymer regions between three adjacent z-slices by modifying the middle and upper slices while preserving specified connection points.</p> <p>Parameters:</p> Name Type Description Default <code>lower_slice</code> <code>Array</code> <p>Binary array representing the lower z-slice.</p> required <code>middle_slice</code> <code>Array</code> <p>Binary array representing the middle z-slice to be optimized.</p> required <code>upper_slice</code> <code>Array</code> <p>Binary array representing the upper z-slice to be optimized.</p> required <code>upper_save_points</code> <code>Array</code> <p>Boolean mask of points in upper slice that must remain connected.</p> required <p>Returns:</p> Type Description <code>tuple[Array, Array]</code> <p>Tuple of (modified_middle_slice, modified_upper_slice) with connected regions.</p> Source code in <code>src/fdtdx/constraints/binary_transform.py</code> <pre><code>def connect_slice(\n    lower_slice: jax.Array,\n    middle_slice: jax.Array,  # this layer is optimized\n    upper_slice: jax.Array,  # this layer is optimized,\n    upper_save_points: jax.Array,  # points which are surely connected\n) -&gt; tuple[jax.Array, jax.Array]:\n    \"\"\"Connects polymer regions between adjacent slices.\n\n    Attempts to connect disconnected polymer regions between three adjacent\n    z-slices by modifying the middle and upper slices while preserving\n    specified connection points.\n\n    Args:\n        lower_slice: Binary array representing the lower z-slice.\n        middle_slice: Binary array representing the middle z-slice to be optimized.\n        upper_slice: Binary array representing the upper z-slice to be optimized.\n        upper_save_points: Boolean mask of points in upper slice that must remain connected.\n\n    Returns:\n        Tuple of (modified_middle_slice, modified_upper_slice) with connected regions.\n    \"\"\"\n    n = max(lower_slice.shape[0], lower_slice.shape[1])\n\n    # define kernels\n    n4_kernel = jnp.asarray(\n        [\n            [0, 1, 0],\n            [1, 1, 1],\n            [0, 1, 0],\n        ],\n        dtype=bool,\n    )\n    n8_kernel = jnp.asarray(\n        [\n            [1, 1, 1],\n            [1, 1, 1],\n            [1, 1, 1],\n        ],\n        dtype=bool,\n    )\n    direction_kernels = jnp.asarray(\n        [\n            [[0, 1, 0], [0, 0, 0], [0, 0, 0]],\n            [[0, 0, 0], [0, 0, 1], [0, 0, 0]],\n            [[0, 0, 0], [0, 0, 0], [0, 1, 0]],\n            [[0, 0, 0], [1, 0, 0], [0, 0, 0]],\n        ],\n        dtype=bool,\n    )\n\n    # first determine all well-supported points\n    connected_points = upper_slice &amp; middle_slice\n    connected_points = connected_points | upper_save_points\n\n    for _ in range(n):\n        connected_points = dilate_jax(connected_points, n4_kernel)\n        connected_points = connected_points &amp; upper_slice\n    upper_air = jnp.invert(upper_slice)\n    non_connected_points = jnp.invert(upper_air | connected_points)\n\n    # first try to connect by setting additional polymers in lower array\n    connectable_region_lower = dilate_jax(middle_slice, n4_kernel)\n    connectable_region_lower = connectable_region_lower | lower_slice  # connectable either vertical or horiz.\n    connectable_by_lower = non_connected_points &amp; connectable_region_lower\n    # update matrix, non-connected and connected points\n    middle_slice = middle_slice | connectable_by_lower\n    connected_points = connected_points | connectable_by_lower\n    for _ in range(n):\n        connected_points = dilate_jax(connected_points, n4_kernel)\n        connected_points = connected_points &amp; upper_slice\n    non_connected_points = jnp.invert(upper_air | connected_points)\n\n    # then try to connect by adding polymer in upper array\n    connectable_region_upper = dilate_jax(connected_points, n8_kernel)\n    connectable_by_upper = non_connected_points &amp; connectable_region_upper\n    connection_points = jax.vmap(dilate_jax, in_axes=(None, 0))(connectable_by_upper, direction_kernels)\n    valid_connection_points = connectable_region_upper &amp; connection_points\n    valid_connection_points = jnp.sum(valid_connection_points, axis=0).astype(bool)\n    # update matrix, non-connected and connected points\n    upper_slice = upper_slice | valid_connection_points\n    for _ in range(n):\n        connected_points = dilate_jax(connected_points, n4_kernel)\n        connected_points = connected_points &amp; upper_slice\n    non_connected_points = jnp.invert(upper_air | connected_points)\n\n    # delete all non-connected\n    upper_slice = upper_slice &amp; jnp.invert(non_connected_points)\n\n    return middle_slice, upper_slice\n</code></pre>"},{"location":"api/constraints/binary/#structure-optimization","title":"Structure Optimization","text":""},{"location":"api/constraints/binary/#fdtdx.constraints.binary_transform.remove_floating_polymer","title":"<code>fdtdx.constraints.binary_transform.remove_floating_polymer(matrix)</code>","text":"<p>Removes polymer regions that are not connected to the substrate.</p> <p>Uses flood-fill algorithm to identify polymer regions connected to the bottom layer and removes any floating polymer regions that are not connected.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Array</code> <p>Binary array where 1 represents polymer and 0 represents air.    Shape is (x, y, z) representing the 3D grid.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Modified binary array with floating polymer regions removed.</p> Source code in <code>src/fdtdx/constraints/binary_transform.py</code> <pre><code>def remove_floating_polymer(\n    matrix: jax.Array,  # 1 is polymer, zero is air, shape (x, y, z)\n) -&gt; jax.Array:\n    \"\"\"Removes polymer regions that are not connected to the substrate.\n\n    Uses flood-fill algorithm to identify polymer regions connected to the bottom layer\n    and removes any floating polymer regions that are not connected.\n\n    Args:\n        matrix: Binary array where 1 represents polymer and 0 represents air.\n               Shape is (x, y, z) representing the 3D grid.\n\n    Returns:\n        Modified binary array with floating polymer regions removed.\n    \"\"\"\n    connected = compute_polymer_connection(matrix)\n    non_connected_polymer = jnp.invert(connected) &amp; matrix\n    matrix = matrix &amp; jnp.invert(non_connected_polymer)\n    return matrix\n</code></pre>"},{"location":"api/constraints/binary/#fdtdx.constraints.binary_transform.remove_polymer_non_connected_to_x_max_middle","title":"<code>fdtdx.constraints.binary_transform.remove_polymer_non_connected_to_x_max_middle(matrix)</code>","text":"<p>Removes polymer regions not connected to the middle of the x-max boundary.</p> <p>Uses flood-fill algorithm starting from the middle point of the x-max boundary to identify connected polymer regions and removes unconnected regions.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Array</code> <p>Binary array where 1 represents polymer and 0 represents air.    Shape is (x, y, z) representing the 3D grid.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Modified binary array with unconnected polymer regions removed.</p> Source code in <code>src/fdtdx/constraints/binary_transform.py</code> <pre><code>def remove_polymer_non_connected_to_x_max_middle(\n    matrix: jax.Array,  # 1 is polymer, zero is air, shape (x, y, z)\n) -&gt; jax.Array:\n    \"\"\"Removes polymer regions not connected to the middle of the x-max boundary.\n\n    Uses flood-fill algorithm starting from the middle point of the x-max boundary\n    to identify connected polymer regions and removes unconnected regions.\n\n    Args:\n        matrix: Binary array where 1 represents polymer and 0 represents air.\n               Shape is (x, y, z) representing the 3D grid.\n\n    Returns:\n        Modified binary array with unconnected polymer regions removed.\n    \"\"\"\n    y_middle = round(matrix.shape[1] / 2)\n    x_middle = round(matrix.shape[0] / 2)\n    connected = compute_polymer_connection(\n        matrix,\n        connected_slice=(x_middle, y_middle, None),\n    )\n    non_connected_polymer = jnp.invert(connected) &amp; matrix\n    matrix = matrix &amp; jnp.invert(non_connected_polymer)\n    return matrix\n</code></pre>"},{"location":"api/constraints/binary/#fdtdx.constraints.binary_transform.connect_holes_and_structures","title":"<code>fdtdx.constraints.binary_transform.connect_holes_and_structures(matrix)</code>","text":"<p>Connects disconnected polymer structures and air holes in the matrix.</p> <p>Performs a two-pass algorithm: 1. Connects disconnected polymer structures by adding polymer material 2. Connects disconnected air regions by removing polymer material</p> <p>This ensures both structural integrity and proper air ventilation.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Array</code> <p>Binary array where 1 represents polymer and 0 represents air.    Shape is (x, y, z) representing the 3D grid.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Modified binary array with connected structures and holes.</p> Source code in <code>src/fdtdx/constraints/binary_transform.py</code> <pre><code>def connect_holes_and_structures(\n    matrix: jax.Array,  # 1 is polymer, zero is air, shape (x, y, z)\n) -&gt; jax.Array:\n    \"\"\"Connects disconnected polymer structures and air holes in the matrix.\n\n    Performs a two-pass algorithm:\n    1. Connects disconnected polymer structures by adding polymer material\n    2. Connects disconnected air regions by removing polymer material\n\n    This ensures both structural integrity and proper air ventilation.\n\n    Args:\n        matrix: Binary array where 1 represents polymer and 0 represents air.\n               Shape is (x, y, z) representing the 3D grid.\n\n    Returns:\n        Modified binary array with connected structures and holes.\n    \"\"\"\n    matrix = matrix.astype(bool)\n    # first connect all polymer structures  # TODO: convert to fori-loops\n    for i in range(matrix.shape[-1] - 1):\n        connected = compute_polymer_connection(matrix)\n        if i == 0:\n            lower_slice = jnp.ones_like(matrix[..., 0])\n        else:\n            lower_slice = matrix[..., i - 1]\n        new_middle, new_upper = connect_slice(\n            lower_slice=lower_slice,\n            middle_slice=matrix[..., i],\n            upper_slice=matrix[..., i + 1],\n            upper_save_points=connected[..., i + 1],\n        )\n        matrix = matrix.at[..., i].set(new_middle)\n        matrix = matrix.at[..., i + 1].set(new_upper)\n    # then connect all air\n    for i in range(matrix.shape[-1], 0, -1):\n        air_connected = compute_air_connection(matrix)\n        if i == matrix.shape[-1]:\n            lower_slice = jnp.ones_like(matrix[..., 0])\n        else:\n            lower_slice = jnp.invert(matrix[..., i + 1])\n        new_middle, new_upper = connect_slice(\n            lower_slice=lower_slice,\n            middle_slice=jnp.invert(matrix[..., i]),\n            upper_slice=jnp.invert(matrix[..., i - 1]),\n            upper_save_points=air_connected[..., i - 1],\n        )\n        matrix = matrix.at[..., i].set(jnp.invert(new_middle))\n        matrix = matrix.at[..., i - 1].set(jnp.invert(new_upper))\n    # throw away all polymer that got free floating due to air connection in last step\n    connected = compute_polymer_connection(matrix)\n    non_connected_polymer = jnp.invert(connected) &amp; matrix\n    matrix = matrix &amp; jnp.invert(non_connected_polymer)\n    return matrix\n</code></pre>"},{"location":"api/constraints/discrete/","title":"Discrete Constraints","text":""},{"location":"api/constraints/discrete/#material-connectivity","title":"Material Connectivity","text":""},{"location":"api/constraints/discrete/#fdtdx.constraints.discrete.RemoveFloatingMaterial","title":"<code>fdtdx.constraints.discrete.RemoveFloatingMaterial</code>","text":"<p>               Bases: <code>ConstraintModule</code></p> <p>Finds all material that floats in the air and sets their permittivity to air.</p> <p>This constraint module identifies regions of material that are not connected to any substrate or boundary and converts them to air. This helps ensure physically realizable designs by eliminating floating/disconnected material regions.</p> <p>The module only works with binary material systems (2 permittivities) where one material represents air.</p> Source code in <code>src/fdtdx/constraints/discrete.py</code> <pre><code>@extended_autoinit\nclass RemoveFloatingMaterial(ConstraintModule):\n    \"\"\"Finds all material that floats in the air and sets their permittivity to air.\n\n    This constraint module identifies regions of material that are not connected to any\n    substrate or boundary and converts them to air. This helps ensure physically\n    realizable designs by eliminating floating/disconnected material regions.\n\n    The module only works with binary material systems (2 permittivities) where one\n    material represents air.\n    \"\"\"\n\n    def transform(\n        self,\n        input_params: dict[str, jax.Array],\n    ) -&gt; dict[str, jax.Array]:\n        \"\"\"Transforms input parameters by removing floating material regions.\n\n        Args:\n            input_params: Dictionary mapping parameter names to their values as JAX arrays.\n                Expected to contain a single array with material indices.\n\n        Returns:\n            Dictionary with same structure as input but with floating material regions\n            converted to air index.\n\n        Raises:\n            NotImplementedError: If more than 2 permittivities are specified.\n            Exception: If input contains more than one array.\n        \"\"\"\n        if len(self._allowed_permittivities) != 2:\n            raise NotImplementedError(\"Remove floating material currently only implemented for single material\")\n        air_name = get_air_name(self._permittivity_config)\n        air_idx = self._permittivity_names.index(air_name)\n        arr = list(input_params.values())[0]\n        is_material_matrix = arr != air_idx\n        result = remove_floating_polymer(is_material_matrix)\n        # result = result.astype(arr.dtype)\n        result = straight_through_estimator(arr, result)\n        return {list(input_params.keys())[0]: result}\n\n    def input_interface(\n        self,\n        output_interface: ConstraintInterface,\n    ) -&gt; ConstraintInterface:\n        \"\"\"Validates and processes the input interface specification.\n\n        Args:\n            output_interface: Interface specification from the next module in the chain.\n\n        Returns:\n            The validated interface specification.\n\n        Raises:\n            Exception: If output interface has multiple shapes or wrong type.\n            NotImplementedError: If more than 2 permittivities are specified.\n        \"\"\"\n        if len(output_interface.shapes) != 1:\n            raise Exception(\n                f\"RemoveFloatingMaterial expects a single array as output, but got {output_interface.shapes}\"\n            )\n        if output_interface.type != \"index\":\n            raise Exception(\"RemoveFloatingMaterial can only be followed by a module using indices\")\n        if len(self._allowed_permittivities) != 2:\n            raise NotImplementedError(\"RemoveFloatingMaterial currently only implemented for single material\")\n        return output_interface\n</code></pre>"},{"location":"api/constraints/discrete/#fdtdx.constraints.discrete.RemoveFloatingMaterial.input_interface","title":"<code>input_interface(output_interface)</code>","text":"<p>Validates and processes the input interface specification.</p> <p>Parameters:</p> Name Type Description Default <code>output_interface</code> <code>ConstraintInterface</code> <p>Interface specification from the next module in the chain.</p> required <p>Returns:</p> Type Description <code>ConstraintInterface</code> <p>The validated interface specification.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If output interface has multiple shapes or wrong type.</p> <code>NotImplementedError</code> <p>If more than 2 permittivities are specified.</p> Source code in <code>src/fdtdx/constraints/discrete.py</code> <pre><code>def input_interface(\n    self,\n    output_interface: ConstraintInterface,\n) -&gt; ConstraintInterface:\n    \"\"\"Validates and processes the input interface specification.\n\n    Args:\n        output_interface: Interface specification from the next module in the chain.\n\n    Returns:\n        The validated interface specification.\n\n    Raises:\n        Exception: If output interface has multiple shapes or wrong type.\n        NotImplementedError: If more than 2 permittivities are specified.\n    \"\"\"\n    if len(output_interface.shapes) != 1:\n        raise Exception(\n            f\"RemoveFloatingMaterial expects a single array as output, but got {output_interface.shapes}\"\n        )\n    if output_interface.type != \"index\":\n        raise Exception(\"RemoveFloatingMaterial can only be followed by a module using indices\")\n    if len(self._allowed_permittivities) != 2:\n        raise NotImplementedError(\"RemoveFloatingMaterial currently only implemented for single material\")\n    return output_interface\n</code></pre>"},{"location":"api/constraints/discrete/#fdtdx.constraints.discrete.RemoveFloatingMaterial.transform","title":"<code>transform(input_params)</code>","text":"<p>Transforms input parameters by removing floating material regions.</p> <p>Parameters:</p> Name Type Description Default <code>input_params</code> <code>dict[str, Array]</code> <p>Dictionary mapping parameter names to their values as JAX arrays. Expected to contain a single array with material indices.</p> required <p>Returns:</p> Type Description <code>dict[str, Array]</code> <p>Dictionary with same structure as input but with floating material regions</p> <code>dict[str, Array]</code> <p>converted to air index.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If more than 2 permittivities are specified.</p> <code>Exception</code> <p>If input contains more than one array.</p> Source code in <code>src/fdtdx/constraints/discrete.py</code> <pre><code>def transform(\n    self,\n    input_params: dict[str, jax.Array],\n) -&gt; dict[str, jax.Array]:\n    \"\"\"Transforms input parameters by removing floating material regions.\n\n    Args:\n        input_params: Dictionary mapping parameter names to their values as JAX arrays.\n            Expected to contain a single array with material indices.\n\n    Returns:\n        Dictionary with same structure as input but with floating material regions\n        converted to air index.\n\n    Raises:\n        NotImplementedError: If more than 2 permittivities are specified.\n        Exception: If input contains more than one array.\n    \"\"\"\n    if len(self._allowed_permittivities) != 2:\n        raise NotImplementedError(\"Remove floating material currently only implemented for single material\")\n    air_name = get_air_name(self._permittivity_config)\n    air_idx = self._permittivity_names.index(air_name)\n    arr = list(input_params.values())[0]\n    is_material_matrix = arr != air_idx\n    result = remove_floating_polymer(is_material_matrix)\n    # result = result.astype(arr.dtype)\n    result = straight_through_estimator(arr, result)\n    return {list(input_params.keys())[0]: result}\n</code></pre>"},{"location":"api/constraints/discrete/#fdtdx.constraints.discrete.ConnectHolesAndStructures","title":"<code>fdtdx.constraints.discrete.ConnectHolesAndStructures</code>","text":"<p>               Bases: <code>ConstraintModule</code></p> <p>Connects floating polymer regions and ensures air holes connect to outside.</p> <p>This constraint module ensures physical realizability of designs by: 1. Either connecting floating polymer regions to the substrate or removing them 2. Ensuring all air holes are connected to the outside (no trapped air)</p> <p>The bottom (lower z) is treated as the substrate reference.</p> <p>Attributes:</p> Name Type Description <code>fill_material</code> <code>str | None</code> <p>Name of material to use for filling gaps when connecting regions. Required when working with more than 2 materials.</p> Source code in <code>src/fdtdx/constraints/discrete.py</code> <pre><code>@extended_autoinit\nclass ConnectHolesAndStructures(ConstraintModule):\n    \"\"\"Connects floating polymer regions and ensures air holes connect to outside.\n\n    This constraint module ensures physical realizability of designs by:\n    1. Either connecting floating polymer regions to the substrate or removing them\n    2. Ensuring all air holes are connected to the outside (no trapped air)\n\n    The bottom (lower z) is treated as the substrate reference.\n\n    Attributes:\n        fill_material: Name of material to use for filling gaps when connecting regions.\n            Required when working with more than 2 materials.\n    \"\"\"\n\n    fill_material: str | None = frozen_field(default=None)\n\n    def input_interface(\n        self,\n        output_interface: ConstraintInterface,\n    ) -&gt; ConstraintInterface:\n        if len(self._allowed_permittivities) &gt; 2 and self.fill_material is None:\n            raise Exception(\n                \"ConnectHolesAndStructures: Need to specify fill material when working with more than a single material\"\n            )\n        if output_interface.type != \"index\":\n            raise Exception(\"ConnectHolesAndStructures can only be followed by a module using indices\")\n        return output_interface\n\n    def transform(\n        self,\n        input_params: dict[str, jax.Array],\n    ) -&gt; dict[str, jax.Array]:\n        arr = list(input_params.values())[0]\n        air_name = get_air_name(self._permittivity_config)\n        air_idx = self._permittivity_names.index(air_name)\n        is_material_matrix = arr != air_idx\n        feasible_material_matrix = connect_holes_and_structures(is_material_matrix)\n\n        result = jnp.empty_like(arr)\n        # set air\n        result = jnp.where(\n            feasible_material_matrix,\n            -1,  # this is set below\n            air_idx,\n        )\n        # material where previously was material\n        result = jnp.where(feasible_material_matrix &amp; is_material_matrix, arr, result)\n\n        # material, where previously was air\n        fill_name = self.fill_material\n        if fill_name is None:\n            if len(self._allowed_permittivities) &gt; 2:\n                raise Exception(\"This should never happen\")\n            fill_name = self._permittivity_names[1 - air_idx]\n        fill_idx = self._permittivity_names.index(fill_name)\n        result = jnp.where(\n            feasible_material_matrix &amp; ~is_material_matrix,\n            fill_idx,\n            result,\n        )\n        return {list(input_params.keys())[0]: result}\n</code></pre>"},{"location":"api/constraints/discrete/#feature-size-control","title":"Feature Size Control","text":""},{"location":"api/constraints/discrete/#fdtdx.constraints.discrete.circular_brush","title":"<code>fdtdx.constraints.discrete.circular_brush(diameter, size=None)</code>","text":"<p>Creates a circular binary mask/brush for morphological operations.</p> <p>Parameters:</p> Name Type Description Default <code>diameter</code> <code>float</code> <p>Diameter of the circle in grid units.</p> required <code>size</code> <code>int | None</code> <p>Optional size of the output array. If None, uses ceil(diameter) rounded up to next odd number.</p> <code>None</code> <p>Returns:</p> Type Description <code>Array</code> <p>Binary JAX array containing a circular mask where True indicates points</p> <code>Array</code> <p>within the circle diameter.</p> Source code in <code>src/fdtdx/constraints/discrete.py</code> <pre><code>def circular_brush(\n    diameter: float,\n    size: int | None = None,\n) -&gt; jax.Array:\n    \"\"\"Creates a circular binary mask/brush for morphological operations.\n\n    Args:\n        diameter: Diameter of the circle in grid units.\n        size: Optional size of the output array. If None, uses ceil(diameter) rounded\n            up to next odd number.\n\n    Returns:\n        Binary JAX array containing a circular mask where True indicates points\n        within the circle diameter.\n    \"\"\"\n    if size is None:\n        s = math.ceil(diameter)\n        if s % 2 == 0:\n            s += 1\n        size = s\n    xy = jnp.stack(jnp.meshgrid(*map(jnp.arange, (size, size)), indexing=\"xy\"), axis=-1) - jnp.asarray((size / 2) - 0.5)\n    euc_dist = jnp.sqrt((xy**2).sum(axis=-1))\n    # the less EQUAL here is important, because otherwise design may be infeasible\n    # due to discretization errors\n    mask = euc_dist &lt;= (diameter / 2)\n    return mask\n</code></pre>"},{"location":"api/constraints/discrete/#fdtdx.constraints.discrete.BrushConstraint2D","title":"<code>fdtdx.constraints.discrete.BrushConstraint2D</code>","text":"<p>               Bases: <code>ConstraintModule</code></p> <p>Applies 2D brush-based constraints to ensure minimum feature sizes.</p> <p>Implements the brush-based constraint method described in: https://pubs.acs.org/doi/10.1021/acsphotonics.2c00313</p> <p>This ensures minimum feature sizes and connectivity in 2D designs by using morphological operations with a brush kernel.</p> <p>Attributes:</p> Name Type Description <code>brush</code> <code>Array</code> <p>JAX array defining the brush kernel for morphological operations.</p> <code>axis</code> <code>int</code> <p>Axis along which to apply the 2D constraint (perpendicular plane).</p> Source code in <code>src/fdtdx/constraints/discrete.py</code> <pre><code>@extended_autoinit\nclass BrushConstraint2D(ConstraintModule):\n    \"\"\"Applies 2D brush-based constraints to ensure minimum feature sizes.\n\n    Implements the brush-based constraint method described in:\n    https://pubs.acs.org/doi/10.1021/acsphotonics.2c00313\n\n    This ensures minimum feature sizes and connectivity in 2D designs by using\n    morphological operations with a brush kernel.\n\n    Attributes:\n        brush: JAX array defining the brush kernel for morphological operations.\n        axis: Axis along which to apply the 2D constraint (perpendicular plane).\n    \"\"\"\n\n    brush: jax.Array = frozen_field()\n    axis: int = frozen_field()\n\n    def transform(\n        self,\n        input_params: dict[str, jax.Array],\n    ) -&gt; dict[str, jax.Array]:\n        result = {}\n        for k, v in input_params.items():\n            arr_2d = jnp.take(\n                v,\n                jnp.asarray(0),\n                axis=self.axis,\n            )\n\n            # with jax.disable_jit():\n            cur_result = 1 - self._generator(arr_2d)\n\n            air_name = get_air_name(self._permittivity_config)\n            air_idx = self._permittivity_names.index(air_name)\n            if air_idx != 0:\n                cur_result = 1 - cur_result\n            cur_result = jnp.expand_dims(cur_result, axis=self.axis)\n            result[k] = straight_through_estimator(v, cur_result)\n        return result\n\n    def _generator(\n        self,\n        arr: jax.Array,\n    ) -&gt; jax.Array:\n        touches_void = jnp.zeros_like(arr, dtype=jnp.bool)\n        touches_solid = jnp.zeros_like(touches_void)\n\n        def cond_fn(arrs):\n            touch_v, touch_s = arrs[0], arrs[1]\n            pixel_existing_solid = dilate_jax(touch_s, self.brush)\n            pixel_existing_void = dilate_jax(touch_v, self.brush)\n            return ~jnp.all(pixel_existing_solid | pixel_existing_void)\n\n        def body_fn(sv_arrs: tuple[jax.Array, jax.Array]):\n            # see Algorithm 1 in paper\n            touch_v, touch_s = sv_arrs[0], sv_arrs[1]\n            # compute touches and pixel arrays\n            pixel_existing_solid = dilate_jax(touch_s, self.brush)\n            pixel_existing_void = dilate_jax(touch_v, self.brush)\n            touch_impossible_solid = dilate_jax(pixel_existing_void, self.brush)\n            touch_impossible_void = dilate_jax(pixel_existing_solid, self.brush)\n            touch_valid_solid = ~touch_impossible_solid &amp; ~touch_s\n            touch_valid_void = ~touch_impossible_void &amp; ~touch_v\n            pixel_possible_solid = dilate_jax(touch_s | touch_valid_solid, self.brush)\n            pixel_possible_void = dilate_jax(touch_v | touch_valid_void, self.brush)\n            pixel_required_solid = ~pixel_existing_solid &amp; ~pixel_possible_void\n            pixel_required_void = ~pixel_existing_void &amp; ~pixel_possible_solid\n            touch_resolving_solid = dilate_jax(pixel_required_solid, self.brush) &amp; touch_valid_solid\n            touch_resolving_void = dilate_jax(pixel_required_void, self.brush) &amp; touch_valid_void\n            touch_free_solid = ~dilate_jax(pixel_possible_void | pixel_existing_void, self.brush) &amp; touch_valid_solid\n            touch_free_void = ~dilate_jax(pixel_possible_solid | pixel_existing_solid, self.brush) &amp; touch_valid_void\n\n            # case 1\n            def select_all_free_touches():\n                new_v = touch_v | touch_free_void\n                new_s = touch_s | touch_free_solid\n                return new_v, new_s\n\n            # case 2\n            def select_best_resolving_touch():\n                values_solid = jnp.where(touch_resolving_solid, arr, -jnp.inf)\n                values_void = jnp.where(touch_resolving_void, -arr, -jnp.inf)\n\n                def select_void():\n                    max_idx = jnp.argmax(values_void)\n                    new_v = touch_v.flatten().at[max_idx].set(True).reshape(touch_s.shape)\n                    return new_v, touch_s\n\n                def select_solid():\n                    max_idx = jnp.argmax(values_solid)\n                    new_s = touch_s.flatten().at[max_idx].set(True).reshape(touch_v.shape)\n                    return touch_v, new_s\n\n                return jax.lax.cond(\n                    jnp.max(values_solid) &gt; jnp.max(values_void),\n                    select_solid,\n                    select_void,\n                )\n\n            # case 3\n            def select_best_valid_touch():\n                values_solid = jnp.where(touch_valid_solid, arr, -jnp.inf)\n                values_void = jnp.where(touch_valid_void, -arr, -jnp.inf)\n\n                def select_void():\n                    max_idx = jnp.argmax(values_void)\n                    new_v = touch_v.flatten().at[max_idx].set(True).reshape(touch_s.shape)\n                    return new_v, touch_s\n\n                def select_solid():\n                    max_idx = jnp.argmax(values_solid)\n                    new_s = touch_s.flatten().at[max_idx].set(True).reshape(touch_v.shape)\n                    return touch_v, new_s\n\n                return jax.lax.cond(\n                    jnp.max(values_solid) &gt; jnp.max(values_void),\n                    select_solid,\n                    select_void,\n                )\n\n            # case 2 and 3\n            def case_2_and_3_function():\n                resolving_exists = jnp.any(touch_resolving_solid | touch_resolving_void)\n\n                return jax.lax.cond(\n                    resolving_exists,\n                    select_best_resolving_touch,\n                    select_best_valid_touch,\n                )\n\n            free_touches_exist = jnp.any(touch_free_solid | touch_free_void)\n            new_v, new_s = jax.lax.cond(\n                free_touches_exist,\n                select_all_free_touches,\n                case_2_and_3_function,\n            )\n            return new_v, new_s\n\n        arrs = (touches_void, touches_solid)\n\n        res_arrs = eqxi.while_loop(\n            cond_fun=cond_fn,\n            body_fun=body_fn,\n            init_val=arrs,\n            kind=\"lax\",\n        )\n        pixel_existing_solid = dilate_jax(res_arrs[1], self.brush)\n        return pixel_existing_solid.astype(jnp.int32)\n\n    def input_interface(\n        self,\n        output_interface: ConstraintInterface,\n    ) -&gt; ConstraintInterface:\n        if len(self._allowed_permittivities) &gt; 2:\n            raise Exception(\"BrushConstraint2D currently only implemented for single material and air\")\n        if output_interface.type != \"index\":\n            raise Exception(\"BrushConstraint2D has to be followed by a module using indices\")\n        for s in output_interface.shapes.values():\n            if len(s) != 3:\n                raise Exception(\n                    f\"BrushConstraint2D Generator can only work with 2D-Arrays, got {output_interface.shapes=}\"\n                )\n            if s[self.axis] != 1:\n                raise Exception(\n                    f\"BrushConstraint2D Generator needs array size 1 in axis, but got {output_interface.shapes=}\"\n                )\n        return ConstraintInterface(\n            type=\"latent\",\n            shapes=output_interface.shapes,\n        )\n</code></pre>"},{"location":"api/constraints/discrete/#smoothing-and-filtering","title":"Smoothing and Filtering","text":""},{"location":"api/constraints/discrete/#fdtdx.constraints.discrete.BinaryMedianFilterModule","title":"<code>fdtdx.constraints.discrete.BinaryMedianFilterModule</code>","text":"<p>               Bases: <code>ConstraintModule</code></p> <p>Performs 3D binary median filtering on the design.</p> <p>Applies a 3D median filter to smooth and clean up binary material distributions. This helps remove small features and noise while preserving larger structures.</p> <p>Attributes:</p> Name Type Description <code>padding_cfg</code> <code>PaddingConfig</code> <p>Configuration for padding behavior at boundaries.</p> <code>kernel_sizes</code> <code>tuple[int, int, int]</code> <p>3-tuple of kernel sizes for each dimension.</p> <code>num_repeats</code> <code>int</code> <p>Number of times to apply the filter consecutively.</p> Source code in <code>src/fdtdx/constraints/discrete.py</code> <pre><code>@extended_autoinit\nclass BinaryMedianFilterModule(ConstraintModule):\n    \"\"\"Performs 3D binary median filtering on the design.\n\n    Applies a 3D median filter to smooth and clean up binary material distributions.\n    This helps remove small features and noise while preserving larger structures.\n\n    Attributes:\n        padding_cfg: Configuration for padding behavior at boundaries.\n        kernel_sizes: 3-tuple of kernel sizes for each dimension.\n        num_repeats: Number of times to apply the filter consecutively.\n    \"\"\"\n\n    padding_cfg: PaddingConfig = frozen_field()\n    kernel_sizes: tuple[int, int, int] = frozen_field()\n    num_repeats: int = frozen_field(default=1)\n\n    def input_interface(\n        self,\n        output_interface: ConstraintInterface,\n    ) -&gt; ConstraintInterface:\n        if output_interface.type != \"index\":\n            raise Exception(\"BinaryMedianFilterModule has to be followed by a module using indices\")\n        if len(self._allowed_permittivities) != 2:\n            raise Exception(\"BinaryMedianFilterModule only works for single materials\")\n        for s in output_interface.shapes.values():\n            if len(s) != 3:\n                raise Exception(f\"Parameter shape has to have 3 dims, got {output_interface.shapes=}\")\n        return output_interface\n\n    def transform(\n        self,\n        input_params: dict[str, jax.Array],\n    ) -&gt; dict[str, jax.Array]:\n        result = {}\n        for k, v in input_params.items():\n            cur_arr = v\n            for _ in range(self.num_repeats):\n                cur_arr = binary_median_filter(\n                    arr_3d=cur_arr,\n                    kernel_sizes=self.kernel_sizes,\n                    padding_cfg=self.padding_cfg,\n                )\n            result[k] = straight_through_estimator(v, cur_arr)\n        return result\n</code></pre>"},{"location":"api/constraints/discrete/#fdtdx.constraints.discrete.BOTTOM_Z_PADDING_CONFIG","title":"<code>fdtdx.constraints.discrete.BOTTOM_Z_PADDING_CONFIG = PaddingConfig(modes=('constant', 'constant', 'constant', 'constant', 'constant', 'constant'), widths=(10), values=(1, 0, 1, 1, 1, 0))</code>  <code>module-attribute</code>","text":""},{"location":"api/constraints/discrete/#fdtdx.constraints.discrete.BOTTOM_Z_PADDING_CONFIG_REPEAT","title":"<code>fdtdx.constraints.discrete.BOTTOM_Z_PADDING_CONFIG_REPEAT = PaddingConfig(modes=('edge', 'edge', 'edge', 'edge', 'constant', 'edge'), widths=(20), values=(1))</code>  <code>module-attribute</code>","text":""},{"location":"api/constraints/discrete/#pillar-constraints","title":"Pillar Constraints","text":""},{"location":"api/constraints/discrete/#fdtdx.constraints.pillars.PillarMapping","title":"<code>fdtdx.constraints.pillars.PillarMapping</code>","text":"<p>               Bases: <code>ConstraintModule</code></p> <p>Constraint module for mapping pillar structures to allowed configurations.</p> <p>Maps arbitrary pillar structures to the nearest allowed configurations based on material constraints and geometry requirements. Ensures structures meet fabrication rules like single polymer columns and no trapped air holes.</p> <p>Attributes:</p> Name Type Description <code>axis</code> <code>int</code> <p>Axis along which to enforce pillar constraints (0=x, 1=y, 2=z).</p> <code>single_polymer_columns</code> <code>bool</code> <p>If True, restrict to single polymer columns.</p> <code>distance_metric</code> <code>Literal['euclidean', 'permittivity_differences_plus_average_permittivity']</code> <p>Method to compute distances between material distributions: - \"euclidean\": Standard Euclidean distance between permittivity values - \"permittivity_differences_plus_average_permittivity\": Weighted combination   of permittivity differences and average permittivity values, optimized   for material distribution comparisons</p> <code>_allowed_indices</code> <code>Array</code> <p>Private array of allowed index combinations.</p> Source code in <code>src/fdtdx/constraints/pillars.py</code> <pre><code>@extended_autoinit\nclass PillarMapping(ConstraintModule):\n    \"\"\"Constraint module for mapping pillar structures to allowed configurations.\n\n    Maps arbitrary pillar structures to the nearest allowed configurations based on\n    material constraints and geometry requirements. Ensures structures meet fabrication\n    rules like single polymer columns and no trapped air holes.\n\n    Attributes:\n        axis: Axis along which to enforce pillar constraints (0=x, 1=y, 2=z).\n        single_polymer_columns: If True, restrict to single polymer columns.\n        distance_metric: Method to compute distances between material distributions:\n            - \"euclidean\": Standard Euclidean distance between permittivity values\n            - \"permittivity_differences_plus_average_permittivity\": Weighted combination\n              of permittivity differences and average permittivity values, optimized\n              for material distribution comparisons\n        _allowed_indices: Private array of allowed index combinations.\n    \"\"\"\n\n    axis: int = frozen_field(init=True, kind=\"KW_ONLY\")\n    single_polymer_columns: bool = frozen_field(init=True, kind=\"KW_ONLY\")\n\n    distance_metric: Literal[\"euclidean\", \"permittivity_differences_plus_average_permittivity\"] = frozen_field(\n        default=\"permittivity_differences_plus_average_permittivity\",\n    )\n    _allowed_indices: jax.Array = frozen_private_field()\n\n    def input_interface(\n        self,\n        output_interface: ConstraintInterface,\n    ) -&gt; ConstraintInterface:\n        \"\"\"Define input interface requirements for this constraint module.\n\n        Args:\n            output_interface: Interface specification from previous module.\n\n        Returns:\n            ConstraintInterface: Required input interface specification.\n\n        Raises:\n            Exception: If output interface type is not inverse permittivity.\n            Exception: If output interface has multiple shapes.\n        \"\"\"\n        if output_interface.type != \"inv_permittivity\":\n            raise Exception(\"After PillarMapping can only follow a module using\" \"Inverse permittivities\")\n        if len(output_interface.shapes) != 1:\n            raise Exception(f\"Output of PillarMapping needs to be single array, \" f\"but got {output_interface.shapes=}\")\n        return output_interface\n\n    def init_module(\n        self: Self,\n        config: SimulationConfig,\n        permittivity_config: dict[str, float],\n        output_interface: ConstraintInterface,\n    ) -&gt; Self:\n        \"\"\"Initialize the pillar mapping module.\n\n        Sets up allowed index combinations based on material constraints and geometry\n        requirements. Computes valid pillar configurations that satisfy fabrication rules.\n\n        Args:\n            config: Global simulation configuration.\n            permittivity_config: Material permittivity configurations.\n            output_interface: Interface specification from previous module.\n\n        Returns:\n            Self: Initialized module instance.\n        \"\"\"\n        self = super().init_module(\n            config=config,\n            permittivity_config=permittivity_config,\n            output_interface=output_interface,\n        )\n\n        air_name = get_air_name(self._permittivity_config)\n        air_index = self._permittivity_names.index(air_name)\n        allowed_columns = compute_allowed_indices(\n            num_layers=list(self._output_interface.shapes.values())[0][self.axis],\n            indices=list(range(self._allowed_permittivities.shape[0])),\n            fill_holes_with_index=[air_index],\n            single_polymer_columns=self.single_polymer_columns,\n        )\n        self = self.aset(\"_allowed_indices\", allowed_columns)\n        logger.info(f\"{allowed_columns=}\")\n        return self\n\n    def transform(\n        self,\n        input_params: dict[str, jax.Array],\n    ) -&gt; dict[str, jax.Array]:\n        \"\"\"Transform input parameters to satisfy pillar constraints.\n\n        Maps arbitrary material distributions to nearest allowed pillar configurations\n        using straight-through estimation for gradient computation.\n\n        Args:\n            input_params: Dictionary of input parameter arrays.\n\n        Returns:\n            dict[str, jax.Array]: Transformed parameter arrays satisfying constraints.\n\n        Raises:\n            Exception: If invalid axis specified.\n        \"\"\"\n        p = list(input_params.values())[0]\n        nearest_allowed_index = nearest_index(\n            values=p,\n            allowed_values=self._allowed_inverse_permittivities,\n            axis=self.axis,\n            distance_metric=self.distance_metric,\n            allowed_indices=self._allowed_indices,\n            return_distances=False,\n        )\n        latents = self._allowed_inverse_permittivities[self._allowed_indices]\n        quantized_latents = latents[nearest_allowed_index]\n        if self.axis == 2:\n            pass  # no transposition needed\n        elif self.axis == 1:\n            quantized_latents = jnp.transpose(quantized_latents, axes=(0, 2, 1))\n        elif self.axis == 0:\n            quantized_latents = jnp.transpose(quantized_latents, axes=(2, 0, 1))\n        else:\n            raise Exception(f\"invalid axis: {self.axis}\")\n\n        result = {k: straight_through_estimator(input_params[k], quantized_latents) for k in input_params.keys()}\n        return result\n</code></pre>"},{"location":"api/constraints/discrete/#fdtdx.constraints.pillars.PillarMapping.init_module","title":"<code>init_module(config, permittivity_config, output_interface)</code>","text":"<p>Initialize the pillar mapping module.</p> <p>Sets up allowed index combinations based on material constraints and geometry requirements. Computes valid pillar configurations that satisfy fabrication rules.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>Global simulation configuration.</p> required <code>permittivity_config</code> <code>dict[str, float]</code> <p>Material permittivity configurations.</p> required <code>output_interface</code> <code>ConstraintInterface</code> <p>Interface specification from previous module.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Initialized module instance.</p> Source code in <code>src/fdtdx/constraints/pillars.py</code> <pre><code>def init_module(\n    self: Self,\n    config: SimulationConfig,\n    permittivity_config: dict[str, float],\n    output_interface: ConstraintInterface,\n) -&gt; Self:\n    \"\"\"Initialize the pillar mapping module.\n\n    Sets up allowed index combinations based on material constraints and geometry\n    requirements. Computes valid pillar configurations that satisfy fabrication rules.\n\n    Args:\n        config: Global simulation configuration.\n        permittivity_config: Material permittivity configurations.\n        output_interface: Interface specification from previous module.\n\n    Returns:\n        Self: Initialized module instance.\n    \"\"\"\n    self = super().init_module(\n        config=config,\n        permittivity_config=permittivity_config,\n        output_interface=output_interface,\n    )\n\n    air_name = get_air_name(self._permittivity_config)\n    air_index = self._permittivity_names.index(air_name)\n    allowed_columns = compute_allowed_indices(\n        num_layers=list(self._output_interface.shapes.values())[0][self.axis],\n        indices=list(range(self._allowed_permittivities.shape[0])),\n        fill_holes_with_index=[air_index],\n        single_polymer_columns=self.single_polymer_columns,\n    )\n    self = self.aset(\"_allowed_indices\", allowed_columns)\n    logger.info(f\"{allowed_columns=}\")\n    return self\n</code></pre>"},{"location":"api/constraints/discrete/#fdtdx.constraints.pillars.PillarMapping.input_interface","title":"<code>input_interface(output_interface)</code>","text":"<p>Define input interface requirements for this constraint module.</p> <p>Parameters:</p> Name Type Description Default <code>output_interface</code> <code>ConstraintInterface</code> <p>Interface specification from previous module.</p> required <p>Returns:</p> Name Type Description <code>ConstraintInterface</code> <code>ConstraintInterface</code> <p>Required input interface specification.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If output interface type is not inverse permittivity.</p> <code>Exception</code> <p>If output interface has multiple shapes.</p> Source code in <code>src/fdtdx/constraints/pillars.py</code> <pre><code>def input_interface(\n    self,\n    output_interface: ConstraintInterface,\n) -&gt; ConstraintInterface:\n    \"\"\"Define input interface requirements for this constraint module.\n\n    Args:\n        output_interface: Interface specification from previous module.\n\n    Returns:\n        ConstraintInterface: Required input interface specification.\n\n    Raises:\n        Exception: If output interface type is not inverse permittivity.\n        Exception: If output interface has multiple shapes.\n    \"\"\"\n    if output_interface.type != \"inv_permittivity\":\n        raise Exception(\"After PillarMapping can only follow a module using\" \"Inverse permittivities\")\n    if len(output_interface.shapes) != 1:\n        raise Exception(f\"Output of PillarMapping needs to be single array, \" f\"but got {output_interface.shapes=}\")\n    return output_interface\n</code></pre>"},{"location":"api/constraints/discrete/#fdtdx.constraints.pillars.PillarMapping.transform","title":"<code>transform(input_params)</code>","text":"<p>Transform input parameters to satisfy pillar constraints.</p> <p>Maps arbitrary material distributions to nearest allowed pillar configurations using straight-through estimation for gradient computation.</p> <p>Parameters:</p> Name Type Description Default <code>input_params</code> <code>dict[str, Array]</code> <p>Dictionary of input parameter arrays.</p> required <p>Returns:</p> Type Description <code>dict[str, Array]</code> <p>dict[str, jax.Array]: Transformed parameter arrays satisfying constraints.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If invalid axis specified.</p> Source code in <code>src/fdtdx/constraints/pillars.py</code> <pre><code>def transform(\n    self,\n    input_params: dict[str, jax.Array],\n) -&gt; dict[str, jax.Array]:\n    \"\"\"Transform input parameters to satisfy pillar constraints.\n\n    Maps arbitrary material distributions to nearest allowed pillar configurations\n    using straight-through estimation for gradient computation.\n\n    Args:\n        input_params: Dictionary of input parameter arrays.\n\n    Returns:\n        dict[str, jax.Array]: Transformed parameter arrays satisfying constraints.\n\n    Raises:\n        Exception: If invalid axis specified.\n    \"\"\"\n    p = list(input_params.values())[0]\n    nearest_allowed_index = nearest_index(\n        values=p,\n        allowed_values=self._allowed_inverse_permittivities,\n        axis=self.axis,\n        distance_metric=self.distance_metric,\n        allowed_indices=self._allowed_indices,\n        return_distances=False,\n    )\n    latents = self._allowed_inverse_permittivities[self._allowed_indices]\n    quantized_latents = latents[nearest_allowed_index]\n    if self.axis == 2:\n        pass  # no transposition needed\n    elif self.axis == 1:\n        quantized_latents = jnp.transpose(quantized_latents, axes=(0, 2, 1))\n    elif self.axis == 0:\n        quantized_latents = jnp.transpose(quantized_latents, axes=(2, 0, 1))\n    else:\n        raise Exception(f\"invalid axis: {self.axis}\")\n\n    result = {k: straight_through_estimator(input_params[k], quantized_latents) for k in input_params.keys()}\n    return result\n</code></pre>"},{"location":"api/constraints/mapping/","title":"Constraint Mapping","text":""},{"location":"api/constraints/mapping/#fdtdx.constraints.mapping.ConstraintMapping","title":"<code>fdtdx.constraints.mapping.ConstraintMapping</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>A mapping that chains multiple constraint modules together.</p> <p>Manages a sequence of constraint modules that transform parameters between different representations while enforcing constraints. Each module's output must match the input interface of the next module in the chain.</p> <p>Attributes:</p> Name Type Description <code>modules</code> <code>Sequence[ConstraintModule]</code> <p>Sequence of ConstraintModule instances to apply in order.</p> <code>_input_interface</code> <code>ConstraintInterface</code> <p>Interface specification for input parameters.</p> Source code in <code>src/fdtdx/constraints/mapping.py</code> <pre><code>@extended_autoinit\nclass ConstraintMapping(ExtendedTreeClass):\n    \"\"\"A mapping that chains multiple constraint modules together.\n\n    Manages a sequence of constraint modules that transform parameters between different\n    representations while enforcing constraints. Each module's output must match the input\n    interface of the next module in the chain.\n\n    Attributes:\n        modules: Sequence of ConstraintModule instances to apply in order.\n        _input_interface: Interface specification for input parameters.\n    \"\"\"\n\n    modules: Sequence[ConstraintModule] = frozen_field(\n        kind=\"KW_ONLY\",\n    )\n    _input_interface: ConstraintInterface = frozen_private_field()\n\n    def __call__(\n        self,\n        input_params: dict[str, jax.Array],\n    ) -&gt; jax.Array:\n        \"\"\"Transform input parameters through the chain of constraint modules.\n\n        Applies each constraint module in sequence to transform the input parameters,\n        validating interface compliance between modules.\n\n        Args:\n            input_params: Dictionary mapping parameter names to JAX arrays.\n\n        Returns:\n            The final transformed array from the last module.\n\n        Raises:\n            Exception: If input parameters don't match module interfaces.\n        \"\"\"\n        check_interface_compliance(input_params, self._input_interface)\n        # walk through modules\n        x = input_params\n        for m in self.modules:\n            check_interface_compliance(x, m._input_interface)\n            x = m.transform(x)\n            check_interface_compliance(x, m._output_interface)\n        return list(x.values())[0]\n\n    def init_modules(\n        self: Self,\n        config: SimulationConfig,\n        permittivity_config: dict[str, float],\n        output_interface: ConstraintInterface,\n    ) -&gt; Self:\n        \"\"\"Initialize all constraint modules in the mapping chain.\n\n        Sets up each module with the simulation configuration and ensures proper interface\n        matching between modules. The last module must output inverse permittivity values.\n\n        Args:\n            config: Global simulation configuration.\n            permittivity_config: Material permittivity values.\n            output_interface: Interface specification for final output.\n\n        Returns:\n            Self with initialized modules.\n\n        Raises:\n            Exception: If output interface is invalid or modules can't form valid chain.\n        \"\"\"\n        # sanity checks\n        if len(output_interface.shapes) != 1:\n            raise Exception(f\"Output of parameter mapping needs to have length 1, but got {output_interface.shapes=}\")\n        if output_interface.type != \"inv_permittivity\":\n            raise Exception(\"Output of last module in constraint mapping needs to be Inverse Permittivity\")\n\n        # init list of modules\n        cur_output_interface, new_modules = output_interface, []\n        for m in self.modules[::-1]:\n            m_new = m.init_module(\n                config=config,\n                permittivity_config=permittivity_config,\n                output_interface=cur_output_interface,\n            )\n            new_modules.append(m_new)\n            cur_output_interface = m_new._input_interface\n\n        if cur_output_interface.type != \"latent\":\n            raise Exception(\n                \"First Module of Constraint Mapping needs to be able to work with latent parameters as Input\"\n            )\n\n        # set own input shape dtype\n        self = self.aset(\"_input_interface\", cur_output_interface)\n        self = self.aset(\"modules\", new_modules[::-1])\n        return self\n</code></pre>"},{"location":"api/constraints/mapping/#fdtdx.constraints.mapping.ConstraintMapping.__call__","title":"<code>__call__(input_params)</code>","text":"<p>Transform input parameters through the chain of constraint modules.</p> <p>Applies each constraint module in sequence to transform the input parameters, validating interface compliance between modules.</p> <p>Parameters:</p> Name Type Description Default <code>input_params</code> <code>dict[str, Array]</code> <p>Dictionary mapping parameter names to JAX arrays.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>The final transformed array from the last module.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If input parameters don't match module interfaces.</p> Source code in <code>src/fdtdx/constraints/mapping.py</code> <pre><code>def __call__(\n    self,\n    input_params: dict[str, jax.Array],\n) -&gt; jax.Array:\n    \"\"\"Transform input parameters through the chain of constraint modules.\n\n    Applies each constraint module in sequence to transform the input parameters,\n    validating interface compliance between modules.\n\n    Args:\n        input_params: Dictionary mapping parameter names to JAX arrays.\n\n    Returns:\n        The final transformed array from the last module.\n\n    Raises:\n        Exception: If input parameters don't match module interfaces.\n    \"\"\"\n    check_interface_compliance(input_params, self._input_interface)\n    # walk through modules\n    x = input_params\n    for m in self.modules:\n        check_interface_compliance(x, m._input_interface)\n        x = m.transform(x)\n        check_interface_compliance(x, m._output_interface)\n    return list(x.values())[0]\n</code></pre>"},{"location":"api/constraints/mapping/#fdtdx.constraints.mapping.ConstraintMapping.init_modules","title":"<code>init_modules(config, permittivity_config, output_interface)</code>","text":"<p>Initialize all constraint modules in the mapping chain.</p> <p>Sets up each module with the simulation configuration and ensures proper interface matching between modules. The last module must output inverse permittivity values.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>Global simulation configuration.</p> required <code>permittivity_config</code> <code>dict[str, float]</code> <p>Material permittivity values.</p> required <code>output_interface</code> <code>ConstraintInterface</code> <p>Interface specification for final output.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Self with initialized modules.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If output interface is invalid or modules can't form valid chain.</p> Source code in <code>src/fdtdx/constraints/mapping.py</code> <pre><code>def init_modules(\n    self: Self,\n    config: SimulationConfig,\n    permittivity_config: dict[str, float],\n    output_interface: ConstraintInterface,\n) -&gt; Self:\n    \"\"\"Initialize all constraint modules in the mapping chain.\n\n    Sets up each module with the simulation configuration and ensures proper interface\n    matching between modules. The last module must output inverse permittivity values.\n\n    Args:\n        config: Global simulation configuration.\n        permittivity_config: Material permittivity values.\n        output_interface: Interface specification for final output.\n\n    Returns:\n        Self with initialized modules.\n\n    Raises:\n        Exception: If output interface is invalid or modules can't form valid chain.\n    \"\"\"\n    # sanity checks\n    if len(output_interface.shapes) != 1:\n        raise Exception(f\"Output of parameter mapping needs to have length 1, but got {output_interface.shapes=}\")\n    if output_interface.type != \"inv_permittivity\":\n        raise Exception(\"Output of last module in constraint mapping needs to be Inverse Permittivity\")\n\n    # init list of modules\n    cur_output_interface, new_modules = output_interface, []\n    for m in self.modules[::-1]:\n        m_new = m.init_module(\n            config=config,\n            permittivity_config=permittivity_config,\n            output_interface=cur_output_interface,\n        )\n        new_modules.append(m_new)\n        cur_output_interface = m_new._input_interface\n\n    if cur_output_interface.type != \"latent\":\n        raise Exception(\n            \"First Module of Constraint Mapping needs to be able to work with latent parameters as Input\"\n        )\n\n    # set own input shape dtype\n    self = self.aset(\"_input_interface\", cur_output_interface)\n    self = self.aset(\"modules\", new_modules[::-1])\n    return self\n</code></pre>"},{"location":"api/constraints/modules/","title":"Constraint Modules","text":""},{"location":"api/constraints/modules/#base-classes","title":"Base Classes","text":""},{"location":"api/constraints/modules/#fdtdx.constraints.module.ConstraintInterface","title":"<code>fdtdx.constraints.module.ConstraintInterface</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Interface specification for constraint module inputs/outputs.</p> <p>Defines the type and shapes of arrays that a constraint module accepts or produces.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['latent', 'index', 'inv_permittivity']</code> <p>The type of constraint interface - one of: - \"latent\": Raw latent parameters - \"index\": Discrete material indices - \"inv_permittivity\": Inverse permittivity values</p> <code>shapes</code> <code>dict[str, tuple[int, ...]]</code> <p>Dictionary mapping array names to their expected shapes</p> Source code in <code>src/fdtdx/constraints/module.py</code> <pre><code>@extended_autoinit\nclass ConstraintInterface(ExtendedTreeClass):\n    \"\"\"Interface specification for constraint module inputs/outputs.\n\n    Defines the type and shapes of arrays that a constraint module accepts or produces.\n\n    Attributes:\n        type: The type of constraint interface - one of:\n            - \"latent\": Raw latent parameters\n            - \"index\": Discrete material indices\n            - \"inv_permittivity\": Inverse permittivity values\n        shapes: Dictionary mapping array names to their expected shapes\n    \"\"\"\n\n    type: Literal[\"latent\", \"index\", \"inv_permittivity\"] = frozen_field()\n    shapes: dict[str, tuple[int, ...]] = frozen_field()\n</code></pre>"},{"location":"api/constraints/modules/#fdtdx.constraints.module.ConstraintModule","title":"<code>fdtdx.constraints.module.ConstraintModule</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code>, <code>ABC</code></p> <p>Abstract base class for constraint modules.</p> <p>Constraint modules transform parameters between different representations while enforcing physical and fabrication constraints. They form a chain of transformations from latent parameters to final inverse permittivity values.</p> <p>Attributes:</p> Name Type Description <code>_permittivity_config</code> <code>dict[str, float]</code> <p>Dictionary mapping material names to permittivity values</p> <code>_config</code> <code>SimulationConfig</code> <p>Global simulation configuration</p> <code>_output_interface</code> <code>ConstraintInterface</code> <p>Interface specification for module outputs</p> <code>_input_interface</code> <code>ConstraintInterface</code> <p>Interface specification for module inputs</p> Source code in <code>src/fdtdx/constraints/module.py</code> <pre><code>@extended_autoinit\nclass ConstraintModule(ExtendedTreeClass, ABC):\n    \"\"\"Abstract base class for constraint modules.\n\n    Constraint modules transform parameters between different representations while\n    enforcing physical and fabrication constraints. They form a chain of transformations\n    from latent parameters to final inverse permittivity values.\n\n    Attributes:\n        _permittivity_config: Dictionary mapping material names to permittivity values\n        _config: Global simulation configuration\n        _output_interface: Interface specification for module outputs\n        _input_interface: Interface specification for module inputs\n    \"\"\"\n\n    _permittivity_config: dict[str, float] = frozen_private_field()\n    _config: SimulationConfig = frozen_private_field()\n    _output_interface: ConstraintInterface = frozen_private_field()\n    _input_interface: ConstraintInterface = frozen_private_field()\n\n    @property\n    def _ordered_permittivity_tuples(self) -&gt; list[tuple[str, float]]:\n        kv = list(self._permittivity_config.items())\n        kv_sorted = sorted(kv, key=lambda x: x[1])\n        return kv_sorted\n\n    @property\n    def _allowed_permittivities(self) -&gt; jax.Array:\n        name_val_list = self._ordered_permittivity_tuples\n        perms = jnp.asarray([v[1] for v in name_val_list], dtype=jnp.float32)\n        return perms\n\n    @property\n    def _allowed_inverse_permittivities(self):\n        return 1.0 / self._allowed_permittivities\n\n    @property\n    def _permittivity_names(self) -&gt; list[str]:\n        name_val_list = self._ordered_permittivity_tuples\n        names = [v[0] for v in name_val_list]\n        return names\n\n    @abstractmethod\n    def transform(\n        self,\n        input_params: dict[str, jax.Array],\n    ) -&gt; dict[str, jax.Array]:\n        del input_params\n        raise NotImplementedError()\n\n    @abstractmethod\n    def input_interface(\n        self,\n        output_interface: ConstraintInterface,\n    ) -&gt; ConstraintInterface:\n        del output_interface\n        raise NotImplementedError()\n\n    def init_module(\n        self: Self,\n        config: SimulationConfig,\n        permittivity_config: dict[str, float],\n        output_interface: ConstraintInterface,\n    ) -&gt; Self:\n        self = self.aset(\"_config\", config)\n        self = self.aset(\"_permittivity_config\", permittivity_config)\n        self = self.aset(\"_output_interface\", output_interface)\n        input_interface = self.input_interface(self._output_interface)\n        self = self.aset(\"_input_interface\", input_interface)\n        return self\n</code></pre>"},{"location":"api/constraints/modules/#value-range-transformations","title":"Value Range Transformations","text":""},{"location":"api/constraints/modules/#fdtdx.constraints.module.StandardToInversePermittivityRange","title":"<code>fdtdx.constraints.module.StandardToInversePermittivityRange</code>","text":"<p>               Bases: <code>ConstraintModule</code></p> <p>Maps standard [0,1] range to inverse permittivity range.</p> <p>Linearly maps values from [0,1] to the range between minimum and maximum inverse permittivity values allowed by the material configuration.</p> Source code in <code>src/fdtdx/constraints/module.py</code> <pre><code>@extended_autoinit\nclass StandardToInversePermittivityRange(ConstraintModule):\n    \"\"\"Maps standard [0,1] range to inverse permittivity range.\n\n    Linearly maps values from [0,1] to the range between minimum and maximum\n    inverse permittivity values allowed by the material configuration.\n    \"\"\"\n\n    def transform(\n        self,\n        input_params: dict[str, jax.Array],\n    ) -&gt; dict[str, jax.Array]:\n        max_inv_perm = self._allowed_inverse_permittivities.max()\n        min_inv_perm = self._allowed_inverse_permittivities.min()\n\n        result = {}\n        for k, v in input_params.items():\n            mapped = v * (max_inv_perm - min_inv_perm) + min_inv_perm\n            result[k] = mapped\n        return result\n\n    def input_interface(\n        self,\n        output_interface: ConstraintInterface,\n    ) -&gt; ConstraintInterface:\n        if output_interface.type != \"latent\":\n            raise Exception(\"Range Conversion only works on latent Parameters!\")\n        return output_interface\n</code></pre>"},{"location":"api/constraints/modules/#fdtdx.constraints.module.StandardToCustomRange","title":"<code>fdtdx.constraints.module.StandardToCustomRange</code>","text":"<p>               Bases: <code>ConstraintModule</code></p> <p>Maps standard [0,1] range to custom range [min_value, max_value].</p> <p>Linearly maps values from [0,1] to a custom range specified by min_value and max_value parameters.</p> <p>Attributes:</p> Name Type Description <code>min_value</code> <code>float</code> <p>Minimum value of target range</p> <code>max_value</code> <code>float</code> <p>Maximum value of target range</p> Source code in <code>src/fdtdx/constraints/module.py</code> <pre><code>@extended_autoinit\nclass StandardToCustomRange(ConstraintModule):\n    \"\"\"Maps standard [0,1] range to custom range [min_value, max_value].\n\n    Linearly maps values from [0,1] to a custom range specified by min_value\n    and max_value parameters.\n\n    Attributes:\n        min_value: Minimum value of target range\n        max_value: Maximum value of target range\n    \"\"\"\n\n    min_value: float = frozen_field(default=0)\n    max_value: float = frozen_field(default=1)\n\n    def transform(\n        self,\n        input_params: dict[str, jax.Array],\n    ) -&gt; dict[str, jax.Array]:\n        result = {}\n        for k, v in input_params.items():\n            mapped = v * (self.max_value - self.min_value) + self.min_value\n            result[k] = mapped\n        return result\n\n    def input_interface(\n        self,\n        output_interface: ConstraintInterface,\n    ) -&gt; ConstraintInterface:\n        if output_interface.type != \"latent\":\n            raise Exception(\"Range Conversion only works on latent Parameters!\")\n        return output_interface\n</code></pre>"},{"location":"api/constraints/modules/#fdtdx.constraints.module.StandardToPlusOneMinusOneRange","title":"<code>fdtdx.constraints.module.StandardToPlusOneMinusOneRange</code>","text":"<p>               Bases: <code>StandardToCustomRange</code></p> <p>Maps standard [0,1] range to [-1,1] range.</p> <p>Special case of StandardToCustomRange that maps to [-1,1] range. Used for symmetric value ranges around zero.</p> <p>Attributes:</p> Name Type Description <code>min_value</code> <code>float</code> <p>Fixed to -1</p> <code>max_value</code> <code>float</code> <p>Fixed to 1</p> Source code in <code>src/fdtdx/constraints/module.py</code> <pre><code>@extended_autoinit\nclass StandardToPlusOneMinusOneRange(StandardToCustomRange):\n    \"\"\"Maps standard [0,1] range to [-1,1] range.\n\n    Special case of StandardToCustomRange that maps to [-1,1] range.\n    Used for symmetric value ranges around zero.\n\n    Attributes:\n        min_value: Fixed to -1\n        max_value: Fixed to 1\n    \"\"\"\n\n    min_value: float = frozen_field(default=-1, init=False)\n    max_value: float = frozen_field(default=1, init=False)\n</code></pre>"},{"location":"api/constraints/modules/#material-index-transformations","title":"Material Index Transformations","text":""},{"location":"api/constraints/modules/#fdtdx.constraints.module.ClosestIndex","title":"<code>fdtdx.constraints.module.ClosestIndex</code>","text":"<p>               Bases: <code>ConstraintModule</code></p> <p>Maps continuous values to nearest allowed material indices.</p> <p>For each input value, finds the index of the closest allowed inverse permittivity value. Uses straight-through gradient estimation to maintain differentiability.</p> Source code in <code>src/fdtdx/constraints/module.py</code> <pre><code>@extended_autoinit\nclass ClosestIndex(ConstraintModule):\n    \"\"\"Maps continuous values to nearest allowed material indices.\n\n    For each input value, finds the index of the closest allowed inverse\n    permittivity value. Uses straight-through gradient estimation to maintain\n    differentiability.\n    \"\"\"\n\n    def transform(\n        self,\n        input_params: dict[str, jax.Array],\n    ) -&gt; dict[str, jax.Array]:\n        result = {}\n        for k, v in input_params.items():\n            dist = jnp.abs(v[..., None] - self._allowed_inverse_permittivities)\n            discrete = jnp.argmin(dist, axis=-1)\n            result[k] = straight_through_estimator(v, discrete)\n        return result\n\n    def input_interface(\n        self,\n        output_interface: ConstraintInterface,\n    ) -&gt; ConstraintInterface:\n        if output_interface.type != \"index\":\n            raise Exception(\"After ClosestIndex a Module using indices has to follow!\")\n        return ConstraintInterface(\n            type=\"latent\",\n            shapes=output_interface.shapes,\n        )\n</code></pre>"},{"location":"api/constraints/modules/#fdtdx.constraints.module.IndicesToInversePermittivities","title":"<code>fdtdx.constraints.module.IndicesToInversePermittivities</code>","text":"<p>               Bases: <code>ConstraintModule</code></p> <p>Maps material indices to their inverse permittivity values.</p> <p>Converts discrete material indices into their corresponding inverse permittivity values from the allowed materials list. Uses straight-through gradient estimation to maintain differentiability.</p> Source code in <code>src/fdtdx/constraints/module.py</code> <pre><code>@extended_autoinit\nclass IndicesToInversePermittivities(ConstraintModule):\n    \"\"\"Maps material indices to their inverse permittivity values.\n\n    Converts discrete material indices into their corresponding inverse\n    permittivity values from the allowed materials list. Uses straight-through\n    gradient estimation to maintain differentiability.\n    \"\"\"\n\n    def transform(\n        self,\n        input_params: dict[str, jax.Array],\n    ) -&gt; dict[str, jax.Array]:\n        result = {}\n        for k, v in input_params.items():\n            out = self._allowed_inverse_permittivities[v.astype(jnp.int32)]\n            out = out.astype(self._config.dtype)\n            result[k] = straight_through_estimator(v, out)\n        return result\n\n    def input_interface(\n        self,\n        output_interface: ConstraintInterface,\n    ) -&gt; ConstraintInterface:\n        if output_interface.type != \"inv_permittivity\":\n            raise Exception(\n                \"After IndicesToInversePermittivities can only follow a module using\" \"Inverse permittivities\"\n            )\n        return ConstraintInterface(\n            type=\"index\",\n            shapes=output_interface.shapes,\n        )\n</code></pre>"},{"location":"api/constraints/utils/","title":"Constraint Utilities","text":""},{"location":"api/constraints/utils/#index-generation","title":"Index Generation","text":""},{"location":"api/constraints/utils/#fdtdx.constraints.utils.compute_allowed_indices","title":"<code>fdtdx.constraints.utils.compute_allowed_indices(num_layers, indices, fill_holes_with_index, single_polymer_columns=False)</code>","text":"<p>Compute allowed index combinations for multi-layer structures.</p> <p>Parameters:</p> Name Type Description Default <code>num_layers</code> <code>int</code> <p>Number of vertical layers in the structure.</p> required <code>indices</code> <code>Sequence[int]</code> <p>Sequence of allowed material indices.</p> required <code>fill_holes_with_index</code> <code>Sequence[int]</code> <p>Indices that can be used to fill holes/gaps.</p> required <code>single_polymer_columns</code> <code>bool</code> <p>If True, restrict to single polymer columns.</p> <code>False</code> <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: Array of allowed index combinations, shape (n_combinations, num_layers).</p> Source code in <code>src/fdtdx/constraints/utils.py</code> <pre><code>def compute_allowed_indices(\n    num_layers: int,\n    indices: Sequence[int],\n    fill_holes_with_index: Sequence[int],\n    single_polymer_columns: bool = False,\n) -&gt; jax.Array:\n    \"\"\"Compute allowed index combinations for multi-layer structures.\n\n    Args:\n        num_layers: Number of vertical layers in the structure.\n        indices: Sequence of allowed material indices.\n        fill_holes_with_index: Indices that can be used to fill holes/gaps.\n        single_polymer_columns: If True, restrict to single polymer columns.\n\n    Returns:\n        jax.Array: Array of allowed index combinations, shape (n_combinations, num_layers).\n    \"\"\"\n    if single_polymer_columns:\n        return compute_allowed_indices_without_holes_single_polymer_columns(num_layers, indices, fill_holes_with_index)\n    else:\n        return compute_allowed_indices_without_holes(num_layers, indices, fill_holes_with_index)\n</code></pre>"},{"location":"api/constraints/utils/#fdtdx.constraints.utils.compute_allowed_indices_without_holes","title":"<code>fdtdx.constraints.utils.compute_allowed_indices_without_holes(num_layers, indices, fill_holes_with_index)</code>","text":"<p>Compute allowed indices for multi-layer structures without holes.</p> <p>Generates valid index combinations ensuring no trapped air holes by filling gaps with specified indices. Shows progress with a tqdm progress bar.</p> <p>Parameters:</p> Name Type Description Default <code>num_layers</code> <code>int</code> <p>Number of vertical layers in the structure.</p> required <code>indices</code> <code>Sequence[int]</code> <p>Sequence of allowed material indices.</p> required <code>fill_holes_with_index</code> <code>Sequence[int]</code> <p>Indices that can be used to fill holes/gaps.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: Array of valid index combinations, shape (n_combinations, num_layers).</p> Source code in <code>src/fdtdx/constraints/utils.py</code> <pre><code>def compute_allowed_indices_without_holes(\n    num_layers: int,\n    indices: Sequence[int],\n    fill_holes_with_index: Sequence[int],\n) -&gt; jax.Array:\n    \"\"\"Compute allowed indices for multi-layer structures without holes.\n\n    Generates valid index combinations ensuring no trapped air holes by filling\n    gaps with specified indices. Shows progress with a tqdm progress bar.\n\n    Args:\n        num_layers: Number of vertical layers in the structure.\n        indices: Sequence of allowed material indices.\n        fill_holes_with_index: Indices that can be used to fill holes/gaps.\n\n    Returns:\n        jax.Array: Array of valid index combinations, shape (n_combinations, num_layers).\n    \"\"\"\n    valid_indices = [idx for idx in indices if idx not in fill_holes_with_index]\n    unique_permutations = set()\n    pbar = tqdm.tqdm(total=len(valid_indices) ** num_layers)\n\n    for perm in itertools.product(valid_indices, repeat=num_layers):\n        for fill_index in fill_holes_with_index:\n            for i in range(num_layers + 1):\n                filled_perm = perm[: num_layers - i] + (fill_index,) * i\n                unique_permutations.add(filled_perm)\n        pbar.update(1)\n\n    # Convert the set of unique permutations to a JAX array\n    final_permutations = jnp.array(list(unique_permutations))\n    return final_permutations\n</code></pre>"},{"location":"api/constraints/utils/#fdtdx.constraints.utils.compute_allowed_indices_without_holes_single_polymer_columns","title":"<code>fdtdx.constraints.utils.compute_allowed_indices_without_holes_single_polymer_columns(num_layers, indices, fill_holes_with_index)</code>","text":"<p>Compute allowed indices for single polymer column structures without holes.</p> <p>Parameters:</p> Name Type Description Default <code>num_layers</code> <code>int</code> <p>Number of vertical layers in the structure.</p> required <code>indices</code> <code>Sequence[int]</code> <p>Sequence of allowed material indices.</p> required <code>fill_holes_with_index</code> <code>Sequence[int]</code> <p>Indices that can be used to fill holes/gaps.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: Array of valid index combinations, shape (n_combinations, num_layers).</p> Source code in <code>src/fdtdx/constraints/utils.py</code> <pre><code>def compute_allowed_indices_without_holes_single_polymer_columns(\n    num_layers: int,\n    indices: Sequence[int],\n    fill_holes_with_index: Sequence[int],\n) -&gt; jax.Array:\n    \"\"\"Compute allowed indices for single polymer column structures without holes.\n\n    Args:\n        num_layers: Number of vertical layers in the structure.\n        indices: Sequence of allowed material indices.\n        fill_holes_with_index: Indices that can be used to fill holes/gaps.\n\n    Returns:\n        jax.Array: Array of valid index combinations, shape (n_combinations, num_layers).\n    \"\"\"\n    \"\"\"Compute allowed indices for single polymer column structures without holes.\n\n    Generates valid index combinations ensuring single polymer columns without trapped\n    air holes by filling gaps with specified indices.\n\n    Args:\n        num_layers: Number of vertical layers in the structure.\n        indices: Sequence of allowed material indices.\n        fill_holes_with_index: Indices that can be used to fill holes/gaps.\n\n    Returns:\n        jax.Array: Array of valid index combinations, shape (n_combinations, num_layers).\n    \"\"\"\n    if not fill_holes_with_index:\n        all_permutations = list(itertools.product(indices, repeat=num_layers))\n        return jnp.array(all_permutations)\n    valid_indices = [idx for idx in indices if idx not in fill_holes_with_index]\n    all_permutations = list(itertools.product(valid_indices, repeat=num_layers))\n    all_valid_permutations = []\n    for perm in all_permutations:\n        for fill_index in fill_holes_with_index:\n            for i in range(num_layers + 1):\n                filled_perm = perm[: num_layers - i] + (fill_index,) * i\n                unique_elements = set(filled_perm)\n                if len(unique_elements) == 1 or len(unique_elements - set(fill_holes_with_index)) &lt;= 1:\n                    all_valid_permutations.append(filled_perm)\n    return jnp.unique(jnp.array(all_valid_permutations), axis=0)\n</code></pre>"},{"location":"api/constraints/utils/#value-matching","title":"Value Matching","text":""},{"location":"api/constraints/utils/#fdtdx.constraints.utils.nearest_index","title":"<code>fdtdx.constraints.utils.nearest_index(values, allowed_values, axis=None, allowed_indices=None, return_distances=False, distance_metric='permittivity_differences_plus_average_permittivity')</code>","text":"<p>Find nearest allowed indices for given values based on distance metrics.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Array</code> <p>Input array of values to match.</p> required <code>allowed_values</code> <code>Array</code> <p>Array of allowed values to match against.</p> required <code>axis</code> <code>int | None</code> <p>Axis along which to compute distances. Required if using allowed_indices.</p> <code>None</code> <code>allowed_indices</code> <code>Array | None</code> <p>Optional array of allowed indices per position.</p> <code>None</code> <code>return_distances</code> <code>bool</code> <p>If True, return both indices and distances.</p> <code>False</code> <code>distance_metric</code> <code>Literal['euclidean', 'permittivity_differences_plus_average_permittivity']</code> <p>Method to compute distances between values: - \"euclidean\": Standard Euclidean distance - \"permittivity_differences_plus_average_permittivity\": Special metric for   permittivity optimization combining differences and averages.</p> <code>'permittivity_differences_plus_average_permittivity'</code> <p>Returns:</p> Type Description <code>Array | tuple[Array, Array]</code> <p>If return_distances is False: jax.Array: Array of indices of nearest allowed values.</p> <code>Array | tuple[Array, Array]</code> <p>If return_distances is True: Tuple[jax.Array, jax.Array]: (indices, distances)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If axis not provided when using allowed_indices option.</p> <code>Exception</code> <p>If values array is not 3D when using allowed_indices.</p> <code>Exception</code> <p>If invalid axis specified.</p> <code>ValueError</code> <p>If unknown distance metric specified.</p> Source code in <code>src/fdtdx/constraints/utils.py</code> <pre><code>def nearest_index(\n    values: jax.Array,\n    allowed_values: jax.Array,\n    axis: int | None = None,\n    allowed_indices: jax.Array | None = None,\n    return_distances: bool = False,\n    distance_metric: Literal[\n        \"euclidean\", \"permittivity_differences_plus_average_permittivity\"\n    ] = \"permittivity_differences_plus_average_permittivity\",\n) -&gt; jax.Array | tuple[jax.Array, jax.Array]:\n    \"\"\"Find nearest allowed indices for given values based on distance metrics.\n\n    Args:\n        values: Input array of values to match.\n        allowed_values: Array of allowed values to match against.\n        axis: Axis along which to compute distances. Required if using allowed_indices.\n        allowed_indices: Optional array of allowed indices per position.\n        return_distances: If True, return both indices and distances.\n        distance_metric: Method to compute distances between values:\n            - \"euclidean\": Standard Euclidean distance\n            - \"permittivity_differences_plus_average_permittivity\": Special metric for\n              permittivity optimization combining differences and averages.\n\n    Returns:\n        If return_distances is False:\n            jax.Array: Array of indices of nearest allowed values.\n        If return_distances is True:\n            Tuple[jax.Array, jax.Array]: (indices, distances)\n\n    Raises:\n        Exception: If axis not provided when using allowed_indices option.\n        Exception: If values array is not 3D when using allowed_indices.\n        Exception: If invalid axis specified.\n        ValueError: If unknown distance metric specified.\n    \"\"\"\n    if allowed_indices is None:\n        distances = jnp.square(values[..., None] - allowed_values)\n    else:\n        if axis is None:\n            raise Exception(\"Need axis when using allowed indices option\")\n        if values.ndim != 3:\n            raise Exception(f\"Invalid array shape: {values.shape}\")\n\n        def _index_helper(values, idx):\n            return values[idx]\n\n        vmap_idx_fn = jax.vmap(_index_helper, in_axes=(None, 0))\n        allowed_values_per_index = vmap_idx_fn(allowed_values, allowed_indices)\n\n        if axis == 0:\n            allowed_values_per_index = allowed_values_per_index[:, :, None, None]\n        elif axis == 1:\n            allowed_values_per_index = allowed_values_per_index[:, None, :, None]\n        elif axis == 2:\n            allowed_values_per_index = allowed_values_per_index[:, None, None, :]\n        else:\n            raise Exception(f\"Invalid axis: {axis}\")\n\n        if distance_metric == \"euclidean\" or values.shape[axis] == 1:\n            distances = jnp.linalg.norm(\n                values[None, ...] - allowed_values_per_index,\n                axis=axis + 1,\n            )\n        elif distance_metric == \"permittivity_differences_plus_average_permittivity\":\n            distances = jnp.mean(\n                jnp.abs(jnp.diff(values[None, ...], axis=axis + 1) - jnp.diff(allowed_values_per_index, axis=axis + 1)),\n                axis=axis + 1,\n            ) + jnp.abs(values[None, ...].mean(axis=axis + 1) - allowed_values_per_index.mean(axis=axis + 1))\n        else:\n            raise ValueError(f\"Unknown distance metric {distance_metric}\")\n\n    indices = jnp.argmin(distances, axis=0)\n    if allowed_indices is None:\n        indices = jnp.reshape(indices, values.shape)\n    if return_distances:\n        return indices, distances\n    return indices\n</code></pre>"},{"location":"api/core/","title":"Core Package","text":"<p>The core package provides fundamental functionality for FDTD simulations.</p>"},{"location":"api/core/#components","title":"Components","text":"<ul> <li>Types - Shape and slice type definitions</li> <li>Configuration - Simulation and gradient configuration</li> <li>PyTree Utilities - Tree class utilities and fields</li> <li>JAX Utilities - JAX-specific utilities</li> <li>Array Operations - Array manipulation functions</li> <li>Distributed Computing - Sharding and distributed computation</li> </ul>"},{"location":"api/core/arrays/","title":"Array Operations","text":""},{"location":"api/core/arrays/#fdtdx.core.misc.expand_matrix","title":"<code>fdtdx.core.misc.expand_matrix(matrix, grid_points_per_voxel, add_channels=True)</code>","text":"<p>Expands a matrix by repeating values along spatial dimensions and optionally adding channels.</p> <p>Used to upsample a coarse grid to a finer simulation grid by repeating values. Can also add vector field components as channels.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Array</code> <p>Input matrix to expand</p> required <code>grid_points_per_voxel</code> <code>tuple[int, ...]</code> <p>Number of grid points to expand each voxel into along each dimension</p> required <code>add_channels</code> <code>bool</code> <p>If True, adds and tiles 3 channels for vector field components</p> <code>True</code> <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: Expanded matrix with repeated values and optional channels</p> Source code in <code>src/fdtdx/core/misc.py</code> <pre><code>def expand_matrix(matrix: jax.Array, grid_points_per_voxel: tuple[int, ...], add_channels: bool = True) -&gt; jax.Array:\n    \"\"\"Expands a matrix by repeating values along spatial dimensions and optionally adding channels.\n\n    Used to upsample a coarse grid to a finer simulation grid by repeating values. Can also add\n    vector field components as channels.\n\n    Args:\n        matrix: Input matrix to expand\n        grid_points_per_voxel: Number of grid points to expand each voxel into along each dimension\n        add_channels: If True, adds and tiles 3 channels for vector field components\n\n    Returns:\n        jax.Array: Expanded matrix with repeated values and optional channels\n    \"\"\"\n    \"\"\"Expands a matrix by repeating values along spatial dimensions and optionally adding channels.\n\n    Args:\n        matrix: Input matrix to expand\n        grid_points_per_voxel: Number of grid points to expand each voxel into along each dimension\n        add_channels: If True, adds and tiles 3 channels for vector field components\n\n    Returns:\n        jax.Array: Expanded matrix with repeated values and optional channels\n    \"\"\"\n    if matrix.ndim == 2:\n        matrix = jnp.expand_dims(matrix, axis=-1)\n    expanded_matrix = jnp.repeat(matrix, grid_points_per_voxel[0], axis=0)\n    expanded_matrix = jnp.repeat(expanded_matrix, grid_points_per_voxel[1], axis=1)\n    expanded_matrix = jnp.repeat(expanded_matrix, grid_points_per_voxel[2], axis=2)\n    if add_channels:\n        if matrix.ndim == 3:\n            expanded_matrix = jnp.expand_dims(expanded_matrix, axis=-1)\n        expanded_matrix = jnp.tile(expanded_matrix, tuple(1 for _ in grid_points_per_voxel) + (3,))\n    return expanded_matrix\n</code></pre>"},{"location":"api/core/arrays/#fdtdx.core.misc.ensure_slice_tuple","title":"<code>fdtdx.core.misc.ensure_slice_tuple(t)</code>","text":"<p>Ensures that all elements of the input sequence are converted to slices.</p> <p>This function takes a sequence of elements that can be slices, integers, or tuples of integers and returns a tuple of slices. Integers are converted to slices that select a single item, and tuples are converted to slices that select a range of items.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Sequence[slice | int | Tuple[int, int]]</code> <p>A sequence of elements where each element is either a slice, an integer, or a tuple of two integers representing the start and end of a slice range.</p> required <p>Returns:</p> Type Description <code>Tuple[slice, ...]</code> <p>A tuple of slices corresponding to the input sequence.</p> Source code in <code>src/fdtdx/core/misc.py</code> <pre><code>def ensure_slice_tuple(t: Sequence[slice | int | Tuple[int, int]]) -&gt; Tuple[slice, ...]:\n    \"\"\"\n    Ensures that all elements of the input sequence are converted to slices.\n\n    This function takes a sequence of elements that can be slices, integers,\n    or tuples of integers and returns a tuple of slices. Integers are converted\n    to slices that select a single item, and tuples are converted to slices\n    that select a range of items.\n\n    Args:\n        t: A sequence of elements where each element is either a slice, an\n            integer, or a tuple of two integers representing the start and end\n            of a slice range.\n\n    Returns:\n        A tuple of slices corresponding to the input sequence.\n    \"\"\"\n\n    def to_slice(loc):\n        if isinstance(loc, int):\n            return slice(loc, loc + 1)\n        elif isinstance(loc, slice):\n            return loc\n        elif isinstance(loc, (tuple, list)) and len(loc) == 2 and all(isinstance(i, int) for i in loc):\n            return slice(*loc)\n        else:\n            raise ValueError(f\"Invalid location type: {type(loc)}. Expected int, slice, or tuple of ints.\")\n\n    return tuple(to_slice(loc) for loc in t)\n</code></pre>"},{"location":"api/core/arrays/#fdtdx.core.misc.index_1d_array","title":"<code>fdtdx.core.misc.index_1d_array(arr, val)</code>","text":"<p>Finds the first index where a 1D array equals a given value.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>1D input array to search</p> required <code>val</code> <code>Array</code> <p>Value to find in the array</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>Array</code> <p>Index of first occurrence of val in arr</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If input array is not 1D</p> Source code in <code>src/fdtdx/core/misc.py</code> <pre><code>def index_1d_array(arr: jax.Array, val: jax.Array) -&gt; jax.Array:\n    \"\"\"Finds the first index where a 1D array equals a given value.\n\n    Args:\n        arr: 1D input array to search\n        val: Value to find in the array\n\n    Returns:\n        int: Index of first occurrence of val in arr\n\n    Raises:\n        Exception: If input array is not 1D\n    \"\"\"\n    if len(arr.shape) != 1:\n        raise Exception(f\"index only works on 1d-array, got shape: {arr.shape}\")\n    first_idx = jnp.argmax(arr == val)\n    return first_idx\n</code></pre>"},{"location":"api/core/arrays/#fdtdx.core.misc.index_by_slice","title":"<code>fdtdx.core.misc.index_by_slice(arr, start, stop, axis, step=1)</code>","text":"<p>Indexes an array along a specified axis using slice notation.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>Input array to slice</p> required <code>start</code> <code>int | None</code> <p>Starting index</p> required <code>stop</code> <code>int | None</code> <p>Stopping index</p> required <code>axis</code> <code>int</code> <p>Axis along which to slice</p> required <code>step</code> <code>int</code> <p>Step size between elements</p> <code>1</code> <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: Sliced array</p> Source code in <code>src/fdtdx/core/misc.py</code> <pre><code>def index_by_slice(\n    arr: jax.Array,\n    start: int | None,\n    stop: int | None,\n    axis: int,\n    step: int = 1,\n) -&gt; jax.Array:\n    \"\"\"Indexes an array along a specified axis using slice notation.\n\n    Args:\n        arr: Input array to slice\n        start: Starting index\n        stop: Stopping index\n        axis: Axis along which to slice\n        step: Step size between elements\n\n    Returns:\n        jax.Array: Sliced array\n    \"\"\"\n    slice_list = [slice(None) for _ in range(arr.ndim)]\n    slice_list[axis] = slice(start, stop, step)\n    return arr[tuple(slice_list)]\n</code></pre>"},{"location":"api/core/arrays/#fdtdx.core.misc.index_by_slice_take_1d","title":"<code>fdtdx.core.misc.index_by_slice_take_1d(arr, slice, axis)</code>","text":"<p>Takes elements from an array along one axis using a slice and JAX's take operation.</p> <p>Optimized version of array slicing that uses JAX's take operation for better performance when taking elements along a single axis.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>Input array</p> required <code>slice</code> <code>slice</code> <p>Slice object specifying which elements to take</p> required <code>axis</code> <code>int</code> <p>Axis along which to take elements</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: Array with selected elements</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If slice would result in empty array</p> Source code in <code>src/fdtdx/core/misc.py</code> <pre><code>def index_by_slice_take_1d(\n    arr: jax.Array,\n    slice: slice,\n    axis: int,\n) -&gt; jax.Array:\n    \"\"\"Takes elements from an array along one axis using a slice and JAX's take operation.\n\n    Optimized version of array slicing that uses JAX's take operation for better performance\n    when taking elements along a single axis.\n\n    Args:\n        arr: Input array\n        slice: Slice object specifying which elements to take\n        axis: Axis along which to take elements\n\n    Returns:\n        jax.Array: Array with selected elements\n\n    Raises:\n        Exception: If slice would result in empty array\n    \"\"\"\n    \"\"\"Takes elements from an array along one axis using a slice and JAX's take operation.\n\n    Args:\n        arr: Input array\n        slice: Slice object specifying which elements to take\n        axis: Axis along which to take elements\n\n    Returns:\n        jax.Array: Array with selected elements\n\n    Raises:\n        Exception: If slice would result in empty array\n    \"\"\"\n    start, stop, step = slice.indices(arr.shape[axis])\n    if start == 0 and stop == arr.shape[axis] and step == 1:\n        return arr\n    indices = jnp.arange(start, stop, step)\n    if len(indices) == 0:\n        raise Exception(f\"Invalid slice: {slice}\")\n    arr = jnp.take(arr, indices, axis=axis, unique_indices=True, indices_are_sorted=True)\n    return arr\n</code></pre>"},{"location":"api/core/arrays/#fdtdx.core.misc.index_by_slice_take","title":"<code>fdtdx.core.misc.index_by_slice_take(arr, slices)</code>","text":"<p>Takes elements from an array using multiple slices and JAX's take operation.</p> <p>Optimized version of array slicing that uses JAX's take operation for better performance when taking elements along multiple axes.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>Input array</p> required <code>slices</code> <code>Sequence[slice]</code> <p>Sequence of slice objects, one for each dimension</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: Array with selected elements</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If any slice would result in empty array</p> Source code in <code>src/fdtdx/core/misc.py</code> <pre><code>def index_by_slice_take(\n    arr: jax.Array,\n    slices: Sequence[slice],\n) -&gt; jax.Array:\n    \"\"\"Takes elements from an array using multiple slices and JAX's take operation.\n\n    Optimized version of array slicing that uses JAX's take operation for better performance\n    when taking elements along multiple axes.\n\n    Args:\n        arr: Input array\n        slices: Sequence of slice objects, one for each dimension\n\n    Returns:\n        jax.Array: Array with selected elements\n\n    Raises:\n        Exception: If any slice would result in empty array\n    \"\"\"\n    \"\"\"Takes elements from an array using multiple slices and JAX's take operation.\n\n    Args:\n        arr: Input array\n        slices: Sequence of slice objects, one for each dimension\n\n    Returns:\n        jax.Array: Array with selected elements\n\n    Raises:\n        Exception: If any slice would result in empty array\n    \"\"\"\n    for axis, s in enumerate(slices):\n        start, stop, step = s.indices(arr.shape[axis])\n        if start == 0 and stop == arr.shape[axis] and step == 1:\n            continue\n        indices = jnp.arange(start, stop, step)\n        if len(indices) == 0:\n            raise Exception(f\"Invalid slice: {s}\")\n        arr = jnp.take(arr, indices, axis=axis, unique_indices=True, indices_are_sorted=True)\n    return arr\n</code></pre>"},{"location":"api/core/arrays/#fdtdx.core.misc.mask_1d_from_slice","title":"<code>fdtdx.core.misc.mask_1d_from_slice(s, axis_size)</code>","text":"<p>Creates a boolean mask array from a slice specification.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>slice</code> <p>Slice object defining which elements should be True</p> required <code>axis_size</code> <code>int</code> <p>Size of the axis to create mask for</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: Boolean mask array with True values where slice selects elements</p> Source code in <code>src/fdtdx/core/misc.py</code> <pre><code>def mask_1d_from_slice(\n    s: slice,\n    axis_size: int,\n) -&gt; jax.Array:\n    \"\"\"Creates a boolean mask array from a slice specification.\n\n    Args:\n        s: Slice object defining which elements should be True\n        axis_size: Size of the axis to create mask for\n\n    Returns:\n        jax.Array: Boolean mask array with True values where slice selects elements\n    \"\"\"\n    \"\"\"Creates a boolean mask array from a slice specification.\n\n    Args:\n        s: Slice object defining which elements should be True\n        axis_size: Size of the axis to create mask for\n\n    Returns:\n        jax.Array: Boolean mask array with True values where slice selects elements\n    \"\"\"\n    start, stop, step = s.indices(axis_size)\n    mask = jnp.zeros(shape=(axis_size,), dtype=jnp.bool)\n    mask = mask.at[start:stop:step].set(1)\n    return mask\n</code></pre>"},{"location":"api/core/arrays/#fdtdx.core.misc.assimilate_shape","title":"<code>fdtdx.core.misc.assimilate_shape(arr, ref_arr, ref_axes, repeat_single_dims=False)</code>","text":"<p>Reshapes array to match reference array's dimensions for broadcasting.</p> <p>Inserts new dimensions of size 1 such that arr has same dimensions as ref_arr and can be broadcasted. Optionally repeats single dimensions to match ref_arr's shape.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>Array to reshape</p> required <code>ref_arr</code> <code>Array</code> <p>Reference array whose shape to match</p> required <code>ref_axes</code> <code>tuple[int, ...]</code> <p>Tuple mapping arr's axes to ref_arr's axes</p> required <code>repeat_single_dims</code> <code>bool</code> <p>If True, repeats size-1 dimensions to match ref_arr</p> <code>False</code> <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: Reshaped array that can be broadcasted with ref_arr</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If shapes are incompatible or axes mapping is invalid</p> Source code in <code>src/fdtdx/core/misc.py</code> <pre><code>def assimilate_shape(\n    arr: jax.Array,\n    ref_arr: jax.Array,\n    ref_axes: tuple[int, ...],\n    repeat_single_dims: bool = False,\n) -&gt; jax.Array:\n    \"\"\"Reshapes array to match reference array's dimensions for broadcasting.\n\n    Inserts new dimensions of size 1 such that arr has same dimensions as ref_arr\n    and can be broadcasted. Optionally repeats single dimensions to match ref_arr's shape.\n\n    Args:\n        arr: Array to reshape\n        ref_arr: Reference array whose shape to match\n        ref_axes: Tuple mapping arr's axes to ref_arr's axes\n        repeat_single_dims: If True, repeats size-1 dimensions to match ref_arr\n\n    Returns:\n        jax.Array: Reshaped array that can be broadcasted with ref_arr\n\n    Raises:\n        Exception: If shapes are incompatible or axes mapping is invalid\n    \"\"\"\n    \"\"\"\n    Inserts new dimensions of size 1 such that to_change has same dimensions\n    as the reference arr and can be broadcasted.\n    \"\"\"\n    if arr.ndim != len(ref_axes):\n        raise Exception(f\"Invalid axes: {arr.ndim=}, {ref_axes=}\")\n    if max(ref_axes) &gt;= ref_arr.ndim:\n        raise Exception(f\"Invalid axes: {ref_arr.ndim=}, {ref_axes=}\")\n    for a, ra in enumerate(ref_axes):\n        if ref_arr.shape[ra] != arr.shape[a] and arr.shape[a] != 1:\n            raise Exception(f\"Invalid shapes: {arr.shape=}, {ref_arr.shape=}\")\n    new_shape = [1] * len(ref_arr.shape)\n    for a, ra in enumerate(ref_axes):\n        new_shape[ra] = arr.shape[a]\n    arr = jnp.reshape(arr, new_shape)\n    if not repeat_single_dims:\n        return arr\n    for ra in ref_axes:\n        if arr.shape[ra] == 1:\n            arr = jnp.repeat(arr, ref_arr.shape[ra], axis=ra)\n    return arr\n</code></pre>"},{"location":"api/core/arrays/#fdtdx.core.misc.linear_interpolated_indexing","title":"<code>fdtdx.core.misc.linear_interpolated_indexing(point, arr)</code>","text":"<p>Performs linear interpolation at a point in an array.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Array</code> <p>Coordinates at which to interpolate</p> required <code>arr</code> <code>Array</code> <p>Array to interpolate from</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: Interpolated value at the specified point</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If point dimensions don't match array dimensions</p> Source code in <code>src/fdtdx/core/misc.py</code> <pre><code>def linear_interpolated_indexing(\n    point: jax.Array,\n    arr: jax.Array,\n) -&gt; jax.Array:\n    \"\"\"Performs linear interpolation at a point in an array.\n\n    Args:\n        point: Coordinates at which to interpolate\n        arr: Array to interpolate from\n\n    Returns:\n        jax.Array: Interpolated value at the specified point\n\n    Raises:\n        Exception: If point dimensions don't match array dimensions\n    \"\"\"\n    if point.ndim != 1 or point.shape[0] != arr.ndim:\n        raise Exception(f\"Invalid shape of point ({point.shape}) or arr {arr.shape}\")\n    indices = [[jnp.floor(point[a]), jnp.ceil(point[a])] for a in range(point.shape[0])]\n    to_interpolate = jnp.asarray(list(itertools.product(*indices)), dtype=jnp.int32)\n    weights = (1 - jnp.abs(to_interpolate - point[None, :])).prod(axis=-1)\n    for axis in range(arr.ndim):\n        invalid_mask = (to_interpolate[:, axis] &lt; 0) | (to_interpolate[:, axis] &gt;= arr.shape[axis])\n        weights = jnp.where(invalid_mask, 0, weights)\n        to_interpolate = jnp.where(invalid_mask[:, None], 0, to_interpolate)\n    indexed_vals = arr[tuple(to_interpolate.T)]\n    result = (weights * indexed_vals).sum() / (weights.sum() + 1e-8)\n    return result\n</code></pre>"},{"location":"api/core/arrays/#fdtdx.core.misc.advanced_padding","title":"<code>fdtdx.core.misc.advanced_padding(arr, padding_cfg)</code>","text":"<p>Pads the input array with configurable padding modes and widths.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Array</code> <p>Input array to pad</p> required <code>padding_cfg</code> <code>PaddingConfig</code> <p>Configuration object containing: - widths: Padding widths for each edge - modes: Padding modes (constant, edge, reflect etc) - values: Values to use for constant padding</p> required <p>Returns:</p> Type Description <code>tuple[Array, tuple[slice, ...]]</code> <p>tuple[jax.Array, tuple[slice, ...]]: Tuple containing: - Padded array - Slice tuple to extract original array region</p> Source code in <code>src/fdtdx/core/misc.py</code> <pre><code>def advanced_padding(\n    arr: jax.Array,\n    padding_cfg: PaddingConfig,\n) -&gt; tuple[jax.Array, tuple[slice, ...]]:\n    \"\"\"Pads the input array with configurable padding modes and widths.\n\n    Args:\n        arr: Input array to pad\n        padding_cfg: Configuration object containing:\n            - widths: Padding widths for each edge\n            - modes: Padding modes (constant, edge, reflect etc)\n            - values: Values to use for constant padding\n\n    Returns:\n        tuple[jax.Array, tuple[slice, ...]]: Tuple containing:\n            - Padded array\n            - Slice tuple to extract original array region\n    \"\"\"\n    # default values\n    if len(padding_cfg.widths) == 1:\n        padding_cfg = padding_cfg.aset(\"widths\", [padding_cfg.widths[0] for _ in range(2 * arr.ndim)])\n    if len(padding_cfg.modes) == 1:\n        padding_cfg = padding_cfg.aset(\"modes\", [padding_cfg.modes[0] for _ in range(2 * arr.ndim)])\n    if padding_cfg.values is None:\n        padding_cfg = padding_cfg.aset(\"values\", [0 for _ in range(2 * arr.ndim)])\n    if len(padding_cfg.values) == 1:\n        padding_cfg = padding_cfg.aset(\"values\", [padding_cfg.values[0] for _ in range(2 * arr.ndim)])\n\n    # sanity checks\n    if len(padding_cfg.widths) % 2 != 0 or len(padding_cfg.widths) / 2 != arr.ndim:\n        raise Exception(f\"Invalid padding width: {padding_cfg.widths} for array with {arr.ndim} dimensions\")\n    if len(padding_cfg.modes) % 2 != 0 or len(padding_cfg.modes) / 2 != arr.ndim:\n        raise Exception(f\"Invalid padding width: {padding_cfg.modes} for array with {arr.ndim} dimensions\")\n    if len(padding_cfg.values) % 2 != 0 or len(padding_cfg.values) / 2 != arr.ndim:\n        raise Exception(f\"Invalid padding width: {padding_cfg.values} for array with {arr.ndim} dimensions\")\n\n    slices = [[0, arr.shape[ax]] for ax in range(arr.ndim)]\n    for edge in range(2 * arr.ndim):\n        is_end = edge % 2 != 0\n        axis = math.floor(edge / 2)\n        cur_width = padding_cfg.widths[edge]\n        cur_mode = padding_cfg.modes[edge]\n        cur_value = padding_cfg.values[edge]\n\n        kwargs = {}\n        if cur_mode == \"constant\":\n            kwargs[\"constant_values\"] = cur_value\n        pad_width_tuple = tuple(\n            [(0, 0) if ax != axis else ((0, cur_width) if is_end else (cur_width, 0)) for ax in range(arr.ndim)]\n        )\n        if not is_end:\n            slices[axis][0] = cur_width\n            slices[axis][1] += cur_width\n        arr = jnp.pad(array=arr, pad_width=pad_width_tuple, mode=cur_mode, **kwargs)\n    slices = ensure_slice_tuple(slices)  # type: ignore\n    return arr, slices\n</code></pre>"},{"location":"api/core/config/","title":"Configuration","text":""},{"location":"api/core/config/#fdtdx.core.config.GradientConfig","title":"<code>fdtdx.core.config.GradientConfig</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Configuration for gradient computation in simulations.</p> <p>This class handles settings for automatic differentiation, supporting either invertible differentiation with a recorder or checkpointing-based differentiation.</p> <p>Parameters:</p> Name Type Description Default <code>recorder</code> <code>Recorder | None</code> <p>Optional recorder for invertible differentiation. If provided, invertible differentiation will be used.</p> <code>None</code> <code>num_checkpoints</code> <code>int | None</code> <p>Optional number of checkpoints for checkpointing-based differentiation. If provided, checkpointing will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If both recorder and num_checkpoints are provided, or if neither is provided.</p> Source code in <code>src/fdtdx/core/config.py</code> <pre><code>class GradientConfig(ExtendedTreeClass):\n    \"\"\"Configuration for gradient computation in simulations.\n\n    This class handles settings for automatic differentiation, supporting either\n    invertible differentiation with a recorder or checkpointing-based differentiation.\n\n    Args:\n        recorder: Optional recorder for invertible differentiation. If provided,\n            invertible differentiation will be used.\n        num_checkpoints: Optional number of checkpoints for checkpointing-based\n            differentiation. If provided, checkpointing will be used.\n\n    Raises:\n        Exception: If both recorder and num_checkpoints are provided, or if neither\n            is provided.\n    \"\"\"\n\n    def __init__(\n        self,\n        recorder: Recorder | None = None,  # if not none, use invertible diff\n        num_checkpoints: int | None = None,\n    ):\n        self.recorder = recorder\n        self.num_checkpoints = num_checkpoints\n        if self.recorder is not None and self.num_checkpoints is not None:\n            raise Exception(\"Cannot use both invertible and checkpointing autodiff!\")\n        if self.recorder is None and self.num_checkpoints is None:\n            raise Exception(\"Need either recorder or checkpoints to define autograd!\")\n</code></pre>"},{"location":"api/core/config/#fdtdx.core.config.SimulationConfig","title":"<code>fdtdx.core.config.SimulationConfig</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Configuration settings for FDTD simulations.</p> <p>This class contains all the parameters needed to configure and run an FDTD simulation, including spatial and temporal discretization, hardware backend, and gradient computation settings.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>float</code> <p>Total simulation time in seconds.</p> <code>resolution</code> <code>float</code> <p>Spatial resolution of the simulation grid in meters.</p> <code>backend</code> <code>Literal['gpu', 'tpu', 'cpu']</code> <p>Computation backend ('gpu', 'tpu', or 'cpu').</p> <code>dtype</code> <code>dtype</code> <p>Data type for numerical computations.</p> <code>courant_factor</code> <code>float</code> <p>Safety factor for the Courant condition (default: 0.99).</p> <code>gradient_config</code> <code>GradientConfig | None</code> <p>Optional configuration for gradient computation.</p> Source code in <code>src/fdtdx/core/config.py</code> <pre><code>@extended_autoinit\nclass SimulationConfig(ExtendedTreeClass):\n    \"\"\"Configuration settings for FDTD simulations.\n\n    This class contains all the parameters needed to configure and run an FDTD\n    simulation, including spatial and temporal discretization, hardware backend,\n    and gradient computation settings.\n\n    Attributes:\n        time: Total simulation time in seconds.\n        resolution: Spatial resolution of the simulation grid in meters.\n        backend: Computation backend ('gpu', 'tpu', or 'cpu').\n        dtype: Data type for numerical computations.\n        courant_factor: Safety factor for the Courant condition (default: 0.99).\n        gradient_config: Optional configuration for gradient computation.\n    \"\"\"\n\n    time: float\n    resolution: float\n    backend: Literal[\"gpu\", \"tpu\", \"cpu\"] = frozen_field(default=\"gpu\")\n    dtype: jnp.dtype = frozen_field(default=jnp.float32)\n    courant_factor: float = 0.99\n    gradient_config: GradientConfig | None = None\n\n    def __post_init__(self):\n        if self.backend in [\"gpu\", \"tpu\"]:\n            # Try to initialize GPU\n            try:\n                jax.devices(self.backend)\n                logger.info(f\"{str.upper(self.backend)} found and will be used for computations\")\n                jax.config.update(\"jax_platform_name\", self.backend)\n            except RuntimeError:\n                logger.warning(f\"{str.upper(self.backend)} not found, falling back to CPU!\")\n                self.backend = \"cpu\"\n                jax.config.update(\"jax_platform_name\", \"cpu\")\n        else:\n            jax.config.update(\"jax_platform_name\", \"cpu\")\n\n    @property\n    def courant_number(self) -&gt; float:\n        \"\"\"Calculate the Courant number for the simulation.\n\n        The Courant number is a dimensionless quantity that determines stability\n        of the FDTD simulation. It represents the ratio of the physical propagation\n        speed to the numerical propagation speed.\n\n        Returns:\n            float: The Courant number, scaled by the courant_factor and normalized\n                for 3D simulations.\n        \"\"\"\n        return self.courant_factor / math.sqrt(3)\n\n    @property\n    def time_step_duration(self) -&gt; float:\n        \"\"\"Calculate the duration of a single time step.\n\n        The time step duration is determined by the Courant condition to ensure\n        numerical stability. It depends on the spatial resolution and the speed\n        of light.\n\n        Returns:\n            float: Time step duration in seconds, calculated using the Courant\n                condition and spatial resolution.\n        \"\"\"\n        return self.courant_number * self.resolution / constants.c\n\n    @property\n    def time_steps_total(self) -&gt; int:\n        \"\"\"Calculate the total number of time steps for the simulation.\n\n        Determines how many discrete time steps are needed to simulate the\n        specified total simulation time, based on the time step duration.\n\n        Returns:\n            int: Total number of time steps needed to reach the specified\n                simulation time.\n        \"\"\"\n        return round(self.time / self.time_step_duration)\n\n    @property\n    def max_travel_distance(self) -&gt; float:\n        \"\"\"Calculate the maximum distance light can travel during the simulation.\n\n        This represents the theoretical maximum distance that light could travel\n        through the simulation volume, useful for determining if the simulation\n        time is sufficient for light to traverse the entire domain.\n\n        Returns:\n            float: Maximum travel distance in meters, based on the speed of light\n                and total simulation time.\n        \"\"\"\n        return constants.c * self.time\n\n    @property\n    def only_forward(self) -&gt; bool:\n        \"\"\"Check if the simulation is forward-only (no gradient computation).\n\n        Forward-only simulations don't compute gradients and are used when only\n        the forward propagation of electromagnetic fields is needed, without\n        optimization.\n\n        Returns:\n            bool: True if no gradient configuration is specified, False otherwise.\n        \"\"\"\n        return self.gradient_config is None\n\n    @property\n    def invertible_optimization(self) -&gt; bool:\n        \"\"\"Check if invertible optimization is enabled.\n\n        Invertible optimization uses time-reversibility of Maxwell's equations\n        to compute gradients with reduced memory requirements compared to\n        checkpointing-based methods.\n\n        Returns:\n            bool: True if gradient computation uses invertible differentiation\n                (recorder is specified), False otherwise.\n        \"\"\"\n        if self.gradient_config is None:\n            return False\n        return self.gradient_config.recorder is not None\n</code></pre>"},{"location":"api/core/config/#fdtdx.core.config.SimulationConfig.courant_number","title":"<code>courant_number: float</code>  <code>property</code>","text":"<p>Calculate the Courant number for the simulation.</p> <p>The Courant number is a dimensionless quantity that determines stability of the FDTD simulation. It represents the ratio of the physical propagation speed to the numerical propagation speed.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Courant number, scaled by the courant_factor and normalized for 3D simulations.</p>"},{"location":"api/core/config/#fdtdx.core.config.SimulationConfig.invertible_optimization","title":"<code>invertible_optimization: bool</code>  <code>property</code>","text":"<p>Check if invertible optimization is enabled.</p> <p>Invertible optimization uses time-reversibility of Maxwell's equations to compute gradients with reduced memory requirements compared to checkpointing-based methods.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if gradient computation uses invertible differentiation (recorder is specified), False otherwise.</p>"},{"location":"api/core/config/#fdtdx.core.config.SimulationConfig.max_travel_distance","title":"<code>max_travel_distance: float</code>  <code>property</code>","text":"<p>Calculate the maximum distance light can travel during the simulation.</p> <p>This represents the theoretical maximum distance that light could travel through the simulation volume, useful for determining if the simulation time is sufficient for light to traverse the entire domain.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum travel distance in meters, based on the speed of light and total simulation time.</p>"},{"location":"api/core/config/#fdtdx.core.config.SimulationConfig.only_forward","title":"<code>only_forward: bool</code>  <code>property</code>","text":"<p>Check if the simulation is forward-only (no gradient computation).</p> <p>Forward-only simulations don't compute gradients and are used when only the forward propagation of electromagnetic fields is needed, without optimization.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if no gradient configuration is specified, False otherwise.</p>"},{"location":"api/core/config/#fdtdx.core.config.SimulationConfig.time_step_duration","title":"<code>time_step_duration: float</code>  <code>property</code>","text":"<p>Calculate the duration of a single time step.</p> <p>The time step duration is determined by the Courant condition to ensure numerical stability. It depends on the spatial resolution and the speed of light.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Time step duration in seconds, calculated using the Courant condition and spatial resolution.</p>"},{"location":"api/core/config/#fdtdx.core.config.SimulationConfig.time_steps_total","title":"<code>time_steps_total: int</code>  <code>property</code>","text":"<p>Calculate the total number of time steps for the simulation.</p> <p>Determines how many discrete time steps are needed to simulate the specified total simulation time, based on the time step duration.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Total number of time steps needed to reach the specified simulation time.</p>"},{"location":"api/core/distributed/","title":"Distributed Computing","text":""},{"location":"api/core/distributed/#fdtdx.core.jax.sharding.get_named_sharding_from_shape","title":"<code>fdtdx.core.jax.sharding.get_named_sharding_from_shape(shape, sharding_axis)</code>","text":"<p>Creates a NamedSharding object for distributing an array across devices.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple[int, ...]</code> <p>Shape of the array to be sharded</p> required <code>sharding_axis</code> <code>int</code> <p>Which axis to shard the array along</p> required <p>Returns:</p> Type Description <code>NamedSharding</code> <p>NamedSharding object specifying how to distribute the array across available devices</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If shape[sharding_axis] is not divisible by number of devices</p> Source code in <code>src/fdtdx/core/jax/sharding.py</code> <pre><code>def get_named_sharding_from_shape(\n    shape: tuple[int, ...],\n    sharding_axis: int,\n) -&gt; jax.sharding.NamedSharding:\n    \"\"\"Creates a NamedSharding object for distributing an array across devices.\n\n    Args:\n        shape: Shape of the array to be sharded\n        sharding_axis: Which axis to shard the array along\n\n    Returns:\n        NamedSharding object specifying how to distribute the array across available devices\n\n    Raises:\n        ValueError: If shape[sharding_axis] is not divisible by number of devices\n    \"\"\"\n    compute_devices = jax.devices()\n    num_dims = len(shape)\n    device_shape = (len(compute_devices),)\n    axis_names = tuple(SHARD_STR if i == sharding_axis else None for i in range(num_dims))\n    devices = mesh_utils.create_device_mesh(\n        device_shape,\n        devices=compute_devices,\n    )\n    mesh = jax.sharding.Mesh(devices=devices, axis_names=(SHARD_STR,))\n    spec = jax.sharding.PartitionSpec(*axis_names)\n    sharding = jax.sharding.NamedSharding(mesh=mesh, spec=spec)\n    return sharding\n</code></pre>"},{"location":"api/core/distributed/#fdtdx.core.jax.sharding.get_dtype_bytes","title":"<code>fdtdx.core.jax.sharding.get_dtype_bytes(dtype)</code>","text":"<p>Get the size in bytes of a JAX dtype.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>dtype</code> <p>JAX dtype to get size of</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of bytes used by the dtype</p> Source code in <code>src/fdtdx/core/jax/sharding.py</code> <pre><code>def get_dtype_bytes(dtype: jnp.dtype) -&gt; int:\n    \"\"\"Get the size in bytes of a JAX dtype.\n\n    Args:\n        dtype: JAX dtype to get size of\n\n    Returns:\n        Number of bytes used by the dtype\n    \"\"\"\n    return jnp.dtype(dtype).itemsize\n</code></pre>"},{"location":"api/core/distributed/#fdtdx.core.jax.sharding.pretty_print_sharding","title":"<code>fdtdx.core.jax.sharding.pretty_print_sharding(sharding)</code>","text":"<p>Returns a human-readable string representation of a sharding specification.</p> <p>Parameters:</p> Name Type Description Default <code>sharding</code> <code>Sharding</code> <p>JAX sharding object to format</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representation showing the sharding type and configuration</p> Source code in <code>src/fdtdx/core/jax/sharding.py</code> <pre><code>def pretty_print_sharding(sharding: jax.sharding.Sharding) -&gt; str:\n    \"\"\"Returns a human-readable string representation of a sharding specification.\n\n    Args:\n        sharding: JAX sharding object to format\n\n    Returns:\n        String representation showing the sharding type and configuration\n    \"\"\"\n    if isinstance(sharding, jax.sharding.NamedSharding):\n        return f\"NamedSharding({sharding.mesh.devices}, {sharding.spec})\"\n    elif isinstance(sharding, jax.sharding.PositionalSharding):\n        return f\"PositionalSharding({sharding._devices}, {sharding._ids.shape})\"\n    elif isinstance(sharding, jax.sharding.SingleDeviceSharding):\n        return f\"SingleDeviceSharding({sharding._device})\"\n    else:\n        return str(sharding)\n</code></pre>"},{"location":"api/core/distributed/#fdtdx.core.jax.sharding.create_named_sharded_matrix","title":"<code>fdtdx.core.jax.sharding.create_named_sharded_matrix(shape, value, sharding_axis, dtype, backend)</code>","text":"<p>Creates a sharded matrix distributed across available devices.</p> <p>Creates a matrix of the given shape filled with the specified value, sharded across available devices along the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple[int, ...]</code> <p>Shape of the matrix to create</p> required <code>value</code> <code>float</code> <p>Value to fill the matrix with</p> required <code>sharding_axis</code> <code>int</code> <p>Which axis to shard along</p> required <code>dtype</code> <code>dtype</code> <p>Data type of the matrix elements</p> required <code>backend</code> <code>Literal['gpu', 'tpu', 'cpu']</code> <p>Which device backend to use (\"gpu\", \"tpu\", or \"cpu\")</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Sharded matrix distributed across devices</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If shape[sharding_axis] is not divisible by number of devices</p> Source code in <code>src/fdtdx/core/jax/sharding.py</code> <pre><code>def create_named_sharded_matrix(\n    shape: tuple[int, ...],\n    value: float,\n    sharding_axis: int,\n    dtype: jnp.dtype,\n    backend: Literal[\"gpu\", \"tpu\", \"cpu\"],\n) -&gt; jax.Array:\n    \"\"\"Creates a sharded matrix distributed across available devices.\n\n    Creates a matrix of the given shape filled with the specified value,\n    sharded across available devices along the specified axis.\n\n    Args:\n        shape: Shape of the matrix to create\n        value: Value to fill the matrix with\n        sharding_axis: Which axis to shard along\n        dtype: Data type of the matrix elements\n        backend: Which device backend to use (\"gpu\", \"tpu\", or \"cpu\")\n\n    Returns:\n        Sharded matrix distributed across devices\n\n    Raises:\n        ValueError: If shape[sharding_axis] is not divisible by number of devices\n    \"\"\"\n    global counter\n    if shape[sharding_axis] == 1:\n        sharding_axis = next(i for i, dim in enumerate(shape) if dim != 1)\n    named_sharding = get_named_sharding_from_shape(\n        shape=shape,\n        sharding_axis=sharding_axis,\n    )\n    compute_devices = jax.devices(backend=backend)\n    num_devices = len(compute_devices)\n    if shape[sharding_axis] % num_devices != 0:\n        raise ValueError(\n            \"Grid shape in sharding axis must be divisible by num_devices\"\n            f\", got {shape[sharding_axis]=} and {num_devices=}\"\n        )\n    sharding_axis_size = shape[sharding_axis] // num_devices\n\n    per_device_shape = tuple(shape[i] if i != sharding_axis else sharding_axis_size for i in range(len(shape)))\n\n    @partial(jax.jit, donate_argnames=\"arr\")\n    def value_fn(arr, val):\n        return arr * val\n\n    matrices = []\n    for device in compute_devices[::-1]:\n        device_matrix = jnp.ones(\n            per_device_shape,\n            dtype=dtype,\n            device=device,\n        )\n        device_matrix = value_fn(device_matrix, value)\n        matrices.append(device_matrix)\n    num_bytes = get_dtype_bytes(dtype)\n    counter += math.prod(shape) * num_bytes\n    return jax.make_array_from_single_device_arrays(shape, named_sharding, matrices)\n</code></pre>"},{"location":"api/core/jax/","title":"JAX Utilities","text":""},{"location":"api/core/jax/#shape-and-type-checking","title":"Shape and Type Checking","text":""},{"location":"api/core/jax/#fdtdx.core.jax.utils.check_shape_dtype","title":"<code>fdtdx.core.jax.utils.check_shape_dtype(partial_value_dict, shape_dtype_dict)</code>","text":"<p>Validates that arrays match their expected shapes and dtypes.</p> <p>Checks each array in partial_value_dict against its corresponding shape and dtype specification in shape_dtype_dict. This is useful for validating that arrays match their expected specifications before using them in computations.</p> <p>Parameters:</p> Name Type Description Default <code>partial_value_dict</code> <code>dict[str, Array]</code> <p>Dictionary mapping names to JAX arrays to validate</p> required <code>shape_dtype_dict</code> <code>dict[str, ShapeDtypeStruct]</code> <p>Dictionary mapping names to ShapeDtypeStruct objects specifying the expected shape and dtype for each array</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If any array's shape or dtype doesn't match its specification in shape_dtype_dict. The error message indicates which array failed and how its shape/dtype differed from expected.</p> Example <p>shapes = {\"x\": jax.ShapeDtypeStruct((2,3), jnp.float32)} arrays = {\"x\": jnp.zeros((2,3), dtype=jnp.float32)} check_shape_dtype(arrays, shapes)  # Passes bad = {\"x\": jnp.zeros((3,2))}  # Wrong shape check_shape_dtype(bad, shapes)  # Raises Exception</p> Source code in <code>src/fdtdx/core/jax/utils.py</code> <pre><code>def check_shape_dtype(\n    partial_value_dict: dict[str, jax.Array],\n    shape_dtype_dict: dict[str, jax.ShapeDtypeStruct],\n):\n    \"\"\"Validates that arrays match their expected shapes and dtypes.\n\n    Checks each array in partial_value_dict against its corresponding shape and dtype\n    specification in shape_dtype_dict. This is useful for validating that arrays\n    match their expected specifications before using them in computations.\n\n    Args:\n        partial_value_dict: Dictionary mapping names to JAX arrays to validate\n        shape_dtype_dict: Dictionary mapping names to ShapeDtypeStruct objects\n            specifying the expected shape and dtype for each array\n\n    Raises:\n        Exception: If any array's shape or dtype doesn't match its specification\n            in shape_dtype_dict. The error message indicates which array failed\n            and how its shape/dtype differed from expected.\n\n    Example:\n        &gt;&gt;&gt; shapes = {\"x\": jax.ShapeDtypeStruct((2,3), jnp.float32)}\n        &gt;&gt;&gt; arrays = {\"x\": jnp.zeros((2,3), dtype=jnp.float32)}\n        &gt;&gt;&gt; check_shape_dtype(arrays, shapes)  # Passes\n        &gt;&gt;&gt; bad = {\"x\": jnp.zeros((3,2))}  # Wrong shape\n        &gt;&gt;&gt; check_shape_dtype(bad, shapes)  # Raises Exception\n    \"\"\"\n    for k, arr in partial_value_dict.items():\n        shape_dtype = shape_dtype_dict[k]\n        if arr.dtype != shape_dtype.dtype:\n            raise Exception(f\"Wrong dtype: {shape_dtype.dtype} != {arr.dtype}\")\n        if arr.shape != shape_dtype.shape:\n            raise Exception(f\"Wrong shape: {shape_dtype.shape} != {arr.shape}\")\n</code></pre>"},{"location":"api/core/jax/#utility-classes","title":"Utility Classes","text":""},{"location":"api/core/jax/#fdtdx.core.misc.PaddingConfig","title":"<code>fdtdx.core.misc.PaddingConfig</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Padding configuration. The order is: minx, maxx, miny, maxy, minz, maxz, ... or just single value that can be used for all</p> Source code in <code>src/fdtdx/core/misc.py</code> <pre><code>@extended_autoinit\nclass PaddingConfig(ExtendedTreeClass):\n    \"\"\"\n    Padding configuration. The order is:\n    minx, maxx, miny, maxy, minz, maxz, ...\n    or just single value that can be used for all\n    \"\"\"\n\n    widths: Sequence[int] = frozen_field()\n    modes: Sequence[str] = frozen_field()\n    values: Sequence[float] = frozen_field(\n        default=None,  # type: ignore\n    )\n</code></pre>"},{"location":"api/core/jax/#gradient-estimators","title":"Gradient Estimators","text":""},{"location":"api/core/jax/#fdtdx.core.jax.ste.straight_through_estimator","title":"<code>fdtdx.core.jax.ste.straight_through_estimator(x, y)</code>","text":"<p>Straight Through Estimator for gradient estimation with discrete variables.</p> <p>This function applies the straight through estimator (STE) by taking the gradient with respect to the continuous input <code>x</code>, while using the discrete values <code>y</code> in the forward pass. STE is commonly used in training neural networks with discrete/quantized values where standard backpropagation is not possible.</p> <p>The implementation uses JAX's stop_gradient to control gradient flow:     output = x - stop_gradient(x) + stop_gradient(y)</p> <p>This ensures during the forward pass we use y, but during backprop the gradient flows through x.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>jax.Array, the original continuous values before quantization/discretization. Gradients will be computed with respect to these values.</p> required <code>y</code> <code>Array</code> <p>jax.Array, the discrete/quantized values used in the forward pass. Must have the same shape as x.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The result of applying the straight through estimator, which</p> <code>Array</code> <p>is the same shape as <code>x</code> and <code>y</code>. In the forward pass this equals y,</p> <code>Array</code> <p>but gradients flow through x.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If x and y have different shapes.</p> Source code in <code>src/fdtdx/core/jax/ste.py</code> <pre><code>def straight_through_estimator(x: jax.Array, y: jax.Array) -&gt; jax.Array:\n    \"\"\"Straight Through Estimator for gradient estimation with discrete variables.\n\n    This function applies the straight through estimator (STE) by taking the gradient\n    with respect to the continuous input `x`, while using the discrete values `y`\n    in the forward pass. STE is commonly used in training neural networks with\n    discrete/quantized values where standard backpropagation is not possible.\n\n    The implementation uses JAX's stop_gradient to control gradient flow:\n        output = x - stop_gradient(x) + stop_gradient(y)\n\n    This ensures during the forward pass we use y, but during backprop the\n    gradient flows through x.\n\n    Args:\n        x: jax.Array, the original continuous values before quantization/discretization.\n            Gradients will be computed with respect to these values.\n        y: jax.Array, the discrete/quantized values used in the forward pass.\n            Must have the same shape as x.\n\n    Returns:\n        jax.Array: The result of applying the straight through estimator, which\n        is the same shape as `x` and `y`. In the forward pass this equals y,\n        but gradients flow through x.\n\n    Raises:\n        ValueError: If x and y have different shapes.\n    \"\"\"\n\n    return x - jax.lax.stop_gradient(x) + jax.lax.stop_gradient(y)\n</code></pre>"},{"location":"api/core/pytree/","title":"PyTree Utilities","text":""},{"location":"api/core/pytree/#core-utilities","title":"Core Utilities","text":""},{"location":"api/core/pytree/#fdtdx.core.jax.pytrees.extended_autoinit","title":"<code>fdtdx.core.jax.pytrees.extended_autoinit(klass)</code>","text":"<p>Wrapper around tc.autoinit that preserves parameter requirement information</p> Source code in <code>src/fdtdx/core/jax/pytrees.py</code> <pre><code>@dataclass_transform(field_specifiers=(Field, tc_field, frozen_field, frozen_private_field))\ndef extended_autoinit(klass: type[T]) -&gt; type[T]:\n    \"\"\"Wrapper around tc.autoinit that preserves parameter requirement information\"\"\"\n    return (\n        klass\n        # if the class already has a user-defined __init__ method\n        # then return the class as is without any modification\n        if \"__init__\" in vars(klass)\n        # first convert the current class hints to fields\n        # then build the __init__ method from the fields of the current class\n        # and any base classes that are decorated with `autoinit`\n        else build_init_method(convert_hints_to_fields(klass))\n    )\n</code></pre>"},{"location":"api/core/pytree/#fdtdx.core.jax.pytrees.field","title":"<code>fdtdx.core.jax.pytrees.field(*, default=NULL, init=True, repr=True, kind='POS_OR_KW', metadata=None, on_setattr=(), on_getattr=(), alias=None)</code>","text":"<pre><code>field(\n    *,\n    default: T,\n    init: bool = True,\n    repr: bool = True,\n    kind: ArgKindType = \"POS_OR_KW\",\n    metadata: dict[str, Any] | None = None,\n    on_setattr: Sequence[Any] = (),\n    on_getattr: Sequence[Any] = (),\n    alias: str | None = None\n) -&gt; T\n</code></pre><pre><code>field(\n    *,\n    init: bool = True,\n    repr: bool = True,\n    kind: ArgKindType = \"POS_OR_KW\",\n    metadata: dict[str, Any] | None = None,\n    on_setattr: Sequence[Any] = (),\n    on_getattr: Sequence[Any] = (),\n    alias: str | None = None\n) -&gt; Any\n</code></pre> <p>Creates a field that automatically freezes on set and unfreezes on get.</p> <p>This field behaves like a regular pytreeclass field but ensures values are frozen when stored and unfrozen when accessed.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Any</code> <p>The default value for the field</p> <code>NULL</code> <code>init</code> <code>bool</code> <p>Whether to include the field in init</p> <code>True</code> <code>repr</code> <code>bool</code> <p>Whether to include the field in repr</p> <code>True</code> <code>kind</code> <code>ArgKindType</code> <p>The argument kind (POS_ONLY, POS_OR_KW, etc.)</p> <code>'POS_OR_KW'</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Additional metadata for the field</p> <code>None</code> <code>on_setattr</code> <code>Sequence[Any]</code> <p>Additional setattr callbacks (applied after freezing)</p> <code>()</code> <code>on_getattr</code> <code>Sequence[Any]</code> <p>Additional getattr callbacks (applied after unfreezing)</p> <code>()</code> <code>alias</code> <code>str | None</code> <p>Alternative name for the field in init</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A Field instance configured with freeze/unfreeze behavior</p> Source code in <code>src/fdtdx/core/jax/pytrees.py</code> <pre><code>def field(\n    *,\n    default: Any = NULL,\n    init: bool = True,\n    repr: bool = True,\n    kind: ArgKindType = \"POS_OR_KW\",\n    metadata: dict[str, Any] | None = None,\n    on_setattr: Sequence[Any] = (),\n    on_getattr: Sequence[Any] = (),\n    alias: str | None = None,\n) -&gt; Any:\n    \"\"\"Creates a field that automatically freezes on set and unfreezes on get.\n\n    This field behaves like a regular pytreeclass field but ensures values are\n    frozen when stored and unfrozen when accessed.\n\n    Args:\n        default: The default value for the field\n        init: Whether to include the field in __init__\n        repr: Whether to include the field in __repr__\n        kind: The argument kind (POS_ONLY, POS_OR_KW, etc.)\n        metadata: Additional metadata for the field\n        on_setattr: Additional setattr callbacks (applied after freezing)\n        on_getattr: Additional getattr callbacks (applied after unfreezing)\n        alias: Alternative name for the field in __init__\n\n    Returns:\n        A Field instance configured with freeze/unfreeze behavior\n    \"\"\"\n    return tc_field(\n        default=default,\n        init=init,\n        repr=repr,\n        kind=kind,\n        metadata=metadata,\n        on_setattr=on_setattr,\n        on_getattr=on_getattr,\n        alias=alias,\n    )\n</code></pre>"},{"location":"api/core/pytree/#fdtdx.core.jax.pytrees.frozen_field","title":"<code>fdtdx.core.jax.pytrees.frozen_field(*, default=NULL, init=True, repr=True, kind='POS_OR_KW', metadata=None, on_setattr=(), on_getattr=(), alias=None)</code>","text":"<pre><code>frozen_field(\n    *,\n    default: T,\n    init: bool = True,\n    repr: bool = True,\n    kind: ArgKindType = \"POS_OR_KW\",\n    metadata: dict[str, Any] | None = None,\n    on_setattr: Sequence[Any] = (),\n    on_getattr: Sequence[Any] = (),\n    alias: str | None = None\n) -&gt; T\n</code></pre><pre><code>frozen_field(\n    *,\n    init: bool = True,\n    repr: bool = True,\n    kind: ArgKindType = \"POS_OR_KW\",\n    metadata: dict[str, Any] | None = None,\n    on_setattr: Sequence[Any] = (),\n    on_getattr: Sequence[Any] = (),\n    alias: str | None = None\n) -&gt; Any\n</code></pre> <p>Creates a field that automatically freezes on set and unfreezes on get.</p> <p>This field behaves like a regular pytreeclass field but ensures values are frozen when stored and unfrozen when accessed.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Any</code> <p>The default value for the field</p> <code>NULL</code> <code>init</code> <code>bool</code> <p>Whether to include the field in init</p> <code>True</code> <code>repr</code> <code>bool</code> <p>Whether to include the field in repr</p> <code>True</code> <code>kind</code> <code>ArgKindType</code> <p>The argument kind (POS_ONLY, POS_OR_KW, etc.)</p> <code>'POS_OR_KW'</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Additional metadata for the field</p> <code>None</code> <code>on_setattr</code> <code>Sequence[Any]</code> <p>Additional setattr callbacks (applied after freezing)</p> <code>()</code> <code>on_getattr</code> <code>Sequence[Any]</code> <p>Additional getattr callbacks (applied after unfreezing)</p> <code>()</code> <code>alias</code> <code>str | None</code> <p>Alternative name for the field in init</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A Field instance configured with freeze/unfreeze behavior</p> Source code in <code>src/fdtdx/core/jax/pytrees.py</code> <pre><code>def frozen_field(\n    *,\n    default: Any = NULL,\n    init: bool = True,\n    repr: bool = True,\n    kind: ArgKindType = \"POS_OR_KW\",\n    metadata: dict[str, Any] | None = None,\n    on_setattr: Sequence[Any] = (),\n    on_getattr: Sequence[Any] = (),\n    alias: str | None = None,\n) -&gt; Any:\n    \"\"\"Creates a field that automatically freezes on set and unfreezes on get.\n\n    This field behaves like a regular pytreeclass field but ensures values are\n    frozen when stored and unfrozen when accessed.\n\n    Args:\n        default: The default value for the field\n        init: Whether to include the field in __init__\n        repr: Whether to include the field in __repr__\n        kind: The argument kind (POS_ONLY, POS_OR_KW, etc.)\n        metadata: Additional metadata for the field\n        on_setattr: Additional setattr callbacks (applied after freezing)\n        on_getattr: Additional getattr callbacks (applied after unfreezing)\n        alias: Alternative name for the field in __init__\n\n    Returns:\n        A Field instance configured with freeze/unfreeze behavior\n    \"\"\"\n    return tc_field(\n        default=default,\n        init=init,\n        repr=repr,\n        kind=kind,\n        metadata=metadata,\n        on_setattr=list(on_setattr) + [tc.freeze],\n        on_getattr=[tc.unfreeze] + list(on_getattr),\n        alias=alias,\n    )\n</code></pre>"},{"location":"api/core/pytree/#fdtdx.core.jax.pytrees.frozen_private_field","title":"<code>fdtdx.core.jax.pytrees.frozen_private_field(*, default=None, init=False, repr=True, kind='POS_OR_KW', metadata=None, on_setattr=(), on_getattr=(), alias=None)</code>","text":"<pre><code>frozen_private_field(\n    *,\n    default: T,\n    init: bool = False,\n    repr: bool = True,\n    kind: ArgKindType = \"POS_OR_KW\",\n    metadata: dict[str, Any] | None = None,\n    on_setattr: Sequence[Any] = (),\n    on_getattr: Sequence[Any] = (),\n    alias: str | None = None\n) -&gt; T\n</code></pre><pre><code>frozen_private_field(\n    *,\n    init: bool = False,\n    repr: bool = True,\n    kind: ArgKindType = \"POS_OR_KW\",\n    metadata: dict[str, Any] | None = None,\n    on_setattr: Sequence[Any] = (),\n    on_getattr: Sequence[Any] = (),\n    alias: str | None = None\n) -&gt; Any\n</code></pre> <p>Creates a field that automatically freezes on set and unfreezes on get, sets the default to None and init to False.</p> <p>This field behaves like a regular pytreeclass field but ensures values are frozen when stored and unfrozen when accessed.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Any</code> <p>The default value for the field</p> <code>None</code> <code>init</code> <code>bool</code> <p>Whether to include the field in init</p> <code>False</code> <code>repr</code> <code>bool</code> <p>Whether to include the field in repr</p> <code>True</code> <code>kind</code> <code>ArgKindType</code> <p>The argument kind (POS_ONLY, POS_OR_KW, etc.)</p> <code>'POS_OR_KW'</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Additional metadata for the field</p> <code>None</code> <code>on_setattr</code> <code>Sequence[Any]</code> <p>Additional setattr callbacks (applied after freezing)</p> <code>()</code> <code>on_getattr</code> <code>Sequence[Any]</code> <p>Additional getattr callbacks (applied after unfreezing)</p> <code>()</code> <code>alias</code> <code>str | None</code> <p>Alternative name for the field in init</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>A Field instance configured with freeze/unfreeze behavior</p> Source code in <code>src/fdtdx/core/jax/pytrees.py</code> <pre><code>def frozen_private_field(\n    *,\n    default: Any = None,\n    init: bool = False,\n    repr: bool = True,\n    kind: ArgKindType = \"POS_OR_KW\",\n    metadata: dict[str, Any] | None = None,\n    on_setattr: Sequence[Any] = (),\n    on_getattr: Sequence[Any] = (),\n    alias: str | None = None,\n) -&gt; Any:\n    \"\"\"Creates a field that automatically freezes on set and unfreezes on get,\n    sets the default to None and init to False.\n\n    This field behaves like a regular pytreeclass field but ensures values are\n    frozen when stored and unfrozen when accessed.\n\n    Args:\n        default: The default value for the field\n        init: Whether to include the field in __init__\n        repr: Whether to include the field in __repr__\n        kind: The argument kind (POS_ONLY, POS_OR_KW, etc.)\n        metadata: Additional metadata for the field\n        on_setattr: Additional setattr callbacks (applied after freezing)\n        on_getattr: Additional getattr callbacks (applied after unfreezing)\n        alias: Alternative name for the field in __init__\n\n    Returns:\n        A Field instance configured with freeze/unfreeze behavior\n    \"\"\"\n    return frozen_field(\n        default=default,\n        init=init,\n        repr=repr,\n        kind=kind,\n        metadata=metadata,\n        on_setattr=on_setattr,\n        on_getattr=on_getattr,\n        alias=alias,\n    )\n</code></pre>"},{"location":"api/core/pytree/#tree-classes-and-fields","title":"Tree Classes and Fields","text":""},{"location":"api/core/pytree/#fdtdx.core.jax.pytrees.ExtendedTreeClassIndexer","title":"<code>fdtdx.core.jax.pytrees.ExtendedTreeClassIndexer</code>","text":"<p>               Bases: <code>TreeClassIndexer</code></p> <p>Extended indexer for tree class that preserves type information.</p> <p>Extends TreeClassIndexer to properly handle type hints and return Self type.</p> Source code in <code>src/fdtdx/core/jax/pytrees.py</code> <pre><code>class ExtendedTreeClassIndexer(TreeClassIndexer):\n    \"\"\"Extended indexer for tree class that preserves type information.\n\n    Extends TreeClassIndexer to properly handle type hints and return Self type.\n    \"\"\"\n\n    def __getitem__(self, where: Any) -&gt; Self:\n        \"\"\"Gets item at specified index while preserving type information.\n\n        Args:\n            where: Index or key to access\n\n        Returns:\n            Self: The indexed item with proper type information preserved\n        \"\"\"\n        return super().__getitem__(where)  # type: ignore\n</code></pre>"},{"location":"api/core/pytree/#fdtdx.core.jax.pytrees.ExtendedTreeClassIndexer.__getitem__","title":"<code>__getitem__(where)</code>","text":"<p>Gets item at specified index while preserving type information.</p> <p>Parameters:</p> Name Type Description Default <code>where</code> <code>Any</code> <p>Index or key to access</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The indexed item with proper type information preserved</p> Source code in <code>src/fdtdx/core/jax/pytrees.py</code> <pre><code>def __getitem__(self, where: Any) -&gt; Self:\n    \"\"\"Gets item at specified index while preserving type information.\n\n    Args:\n        where: Index or key to access\n\n    Returns:\n        Self: The indexed item with proper type information preserved\n    \"\"\"\n    return super().__getitem__(where)  # type: ignore\n</code></pre>"},{"location":"api/core/pytree/#fdtdx.core.jax.pytrees.ExtendedTreeClass","title":"<code>fdtdx.core.jax.pytrees.ExtendedTreeClass</code>","text":"<p>               Bases: <code>TreeClass</code></p> <p>Extended tree class with improved attribute setting functionality.</p> <p>Extends TreeClass to provide more flexible attribute setting capabilities, particularly for handling non-recursive attribute updates.</p> Source code in <code>src/fdtdx/core/jax/pytrees.py</code> <pre><code>class ExtendedTreeClass(tc.TreeClass):\n    \"\"\"Extended tree class with improved attribute setting functionality.\n\n    Extends TreeClass to provide more flexible attribute setting capabilities,\n    particularly for handling non-recursive attribute updates.\n    \"\"\"\n\n    @property\n    def at(self) -&gt; ExtendedTreeClassIndexer:\n        \"\"\"Gets the extended indexer for this tree.\n\n        Returns:\n            ExtendedTreeClassIndexer: Indexer that preserves type information\n        \"\"\"\n        return super().at  # type: ignore\n\n    def _aset(\n        self,\n        attr_name: str,\n        val: Any,\n    ):\n        \"\"\"Internal helper for setting attributes directly.\n\n        Args:\n            attr_name: Name of attribute to set\n            val: Value to set the attribute to\n        \"\"\"\n        setattr(self, attr_name, val)\n\n    def aset(\n        self,\n        attr_name: str,\n        val: Any,\n    ) -&gt; Self:\n        \"\"\"Sets an attribute directly without recursive application.\n\n        Similar to Self.at[attr_name].set(val), but without recursively\n        applying to each tree leaf. Instead, replaces the full attribute\n        with the new value.\n\n        Args:\n            attr_name: Name of attribute to set\n            val: Value to set the attribute to\n\n        Returns:\n            Self: Updated instance with new attribute value\n        \"\"\"\n        _, self = self.at[\"_aset\"](attr_name, val)\n        return self\n</code></pre>"},{"location":"api/core/pytree/#fdtdx.core.jax.pytrees.ExtendedTreeClass.at","title":"<code>at: ExtendedTreeClassIndexer</code>  <code>property</code>","text":"<p>Gets the extended indexer for this tree.</p> <p>Returns:</p> Name Type Description <code>ExtendedTreeClassIndexer</code> <code>ExtendedTreeClassIndexer</code> <p>Indexer that preserves type information</p>"},{"location":"api/core/pytree/#fdtdx.core.jax.pytrees.ExtendedTreeClass.aset","title":"<code>aset(attr_name, val)</code>","text":"<p>Sets an attribute directly without recursive application.</p> <p>Similar to Self.at[attr_name].set(val), but without recursively applying to each tree leaf. Instead, replaces the full attribute with the new value.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>Name of attribute to set</p> required <code>val</code> <code>Any</code> <p>Value to set the attribute to</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Updated instance with new attribute value</p> Source code in <code>src/fdtdx/core/jax/pytrees.py</code> <pre><code>def aset(\n    self,\n    attr_name: str,\n    val: Any,\n) -&gt; Self:\n    \"\"\"Sets an attribute directly without recursive application.\n\n    Similar to Self.at[attr_name].set(val), but without recursively\n    applying to each tree leaf. Instead, replaces the full attribute\n    with the new value.\n\n    Args:\n        attr_name: Name of attribute to set\n        val: Value to set the attribute to\n\n    Returns:\n        Self: Updated instance with new attribute value\n    \"\"\"\n    _, self = self.at[\"_aset\"](attr_name, val)\n    return self\n</code></pre>"},{"location":"api/core/types/","title":"Types","text":""},{"location":"api/core/types/#shape-types","title":"Shape Types","text":""},{"location":"api/core/types/#fdtdx.core.jax.typing.RealShape3D","title":"<code>fdtdx.core.jax.typing.RealShape3D = tuple[float, float, float]</code>  <code>module-attribute</code>","text":"<p>3D shape with real-valued (physical) dimensions in meters.</p>"},{"location":"api/core/types/#fdtdx.core.jax.typing.PartialRealShape3D","title":"<code>fdtdx.core.jax.typing.PartialRealShape3D = tuple[OptionalAxisSize, OptionalAxisSize, OptionalAxisSize]</code>  <code>module-attribute</code>","text":"<p>Partial 3D shape where some physical dimensions may be undefined (None).</p>"},{"location":"api/core/types/#fdtdx.core.jax.typing.GridShape3D","title":"<code>fdtdx.core.jax.typing.GridShape3D = tuple[int, int, int]</code>  <code>module-attribute</code>","text":"<p>3D shape with integer dimensions in grid points.</p>"},{"location":"api/core/types/#fdtdx.core.jax.typing.PartialGridShape3D","title":"<code>fdtdx.core.jax.typing.PartialGridShape3D = tuple[OptionalGridAxisSize, OptionalGridAxisSize, OptionalGridAxisSize]</code>  <code>module-attribute</code>","text":"<p>Partial 3D grid shape where some dimensions may be undefined (None).</p>"},{"location":"api/core/types/#slice-types","title":"Slice Types","text":""},{"location":"api/core/types/#fdtdx.core.jax.typing.SliceTuple3D","title":"<code>fdtdx.core.jax.typing.SliceTuple3D = tuple[tuple[int, int], tuple[int, int], tuple[int, int]]</code>  <code>module-attribute</code>","text":"<p>3D slice specification using (start, stop) integer tuples for each axis.</p>"},{"location":"api/core/types/#fdtdx.core.jax.typing.PartialSliceTuple3D","title":"<code>fdtdx.core.jax.typing.PartialSliceTuple3D = tuple[OptionalAxisSliceTuple, OptionalAxisSliceTuple, OptionalAxisSliceTuple]</code>  <code>module-attribute</code>","text":"<p>Partial 3D slice where some axes may be undefined (None).</p>"},{"location":"api/core/types/#fdtdx.core.jax.typing.Slice3D","title":"<code>fdtdx.core.jax.typing.Slice3D = tuple[slice, slice, slice]</code>  <code>module-attribute</code>","text":"<p>3D slice specification using Python slice objects for each axis.</p>"},{"location":"api/core/types/#fdtdx.core.jax.typing.PartialSlice3D","title":"<code>fdtdx.core.jax.typing.PartialSlice3D = tuple[OptionalAxisSlice, OptionalAxisSlice, OptionalAxisSlice]</code>  <code>module-attribute</code>","text":"<p>Partial 3D slice where some axes may be undefined (None).</p>"},{"location":"api/fdtd/","title":"FDTD Implementations","text":"<p>This section documents the FDTD (Finite-Difference Time-Domain) implementations available in the package.</p>"},{"location":"api/fdtd/#contents","title":"Contents","text":"<ul> <li>Core FDTD Algorithms - Memory-efficient and customizable FDTD implementations</li> <li>Field Operations - Field interpolation and curl operations</li> <li>Field Updates - Electric and magnetic field update functions</li> <li>Interface Management - Detector and interface handling</li> </ul>"},{"location":"api/fdtd/core/","title":"Core FDTD Algorithms","text":""},{"location":"api/fdtd/core/#memory-efficient-implementations","title":"Memory-Efficient Implementations","text":""},{"location":"api/fdtd/core/#reversible-fdtd","title":"Reversible FDTD","text":"<p>Time-reversal symmetric FDTD implementation with O(1) memory usage.</p>"},{"location":"api/fdtd/core/#fdtdx.fdtd.reversible_fdtd","title":"<code>fdtdx.fdtd.reversible_fdtd(arrays, objects, config, key)</code>","text":"<p>Run a memory-efficient differentiable FDTD simulation leveraging time-reversal symmetry.</p> <p>This implementation exploits the time-reversal symmetry of Maxwell's equations to perform backpropagation without storing the electromagnetic fields at each time step. During the backward pass, the fields are reconstructed by running the simulation in reverse, only requiring O(1) memory storage instead of O(T) where T is the number of time steps.</p> <p>The only exception is boundary conditions which break time-reversal symmetry - these are recorded during the forward pass and replayed during backpropagation.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>ArrayContainer</code> <p>Initial state of the simulation containing: - E, H: Electric and magnetic field arrays - inv_permittivities, inv_permeabilities: Material properties - boundary_states: Dictionary of boundary conditions - detector_states: Dictionary of field detectors - recording_state: Optional state for recording field evolution</p> required <code>objects</code> <code>ObjectContainer</code> <p>Collection of physical objects in the simulation (sources, detectors, boundaries, etc.)</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation parameters including: - time_steps_total: Total number of steps to simulate - invertible_optimization: Whether to record boundaries for backprop</p> required <code>key</code> <code>Array</code> <p>JAX PRNGKey for any stochastic operations</p> required <p>Returns:</p> Name Type Description <code>SimulationState</code> <code>SimulationState</code> <p>Tuple containing: - Final time step (int) - ArrayContainer with the final state of all fields and components</p> Notes <p>The implementation uses custom vector-Jacobian products (VJPs) to enable efficient backpropagation through the entire simulation while maintaining numerical stability. This makes it suitable for gradient-based optimization of electromagnetic designs.</p> Source code in <code>src/fdtdx/fdtd/fdtd.py</code> <pre><code>def reversible_fdtd(\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    config: SimulationConfig,\n    key: jax.Array,\n) -&gt; SimulationState:\n    \"\"\"Run a memory-efficient differentiable FDTD simulation leveraging time-reversal symmetry.\n\n    This implementation exploits the time-reversal symmetry of Maxwell's equations to perform\n    backpropagation without storing the electromagnetic fields at each time step. During the\n    backward pass, the fields are reconstructed by running the simulation in reverse, only\n    requiring O(1) memory storage instead of O(T) where T is the number of time steps.\n\n    The only exception is boundary conditions which break time-reversal symmetry - these are\n    recorded during the forward pass and replayed during backpropagation.\n\n    Args:\n        arrays (ArrayContainer): Initial state of the simulation containing:\n            - E, H: Electric and magnetic field arrays\n            - inv_permittivities, inv_permeabilities: Material properties\n            - boundary_states: Dictionary of boundary conditions\n            - detector_states: Dictionary of field detectors\n            - recording_state: Optional state for recording field evolution\n        objects (ObjectContainer): Collection of physical objects in the simulation\n            (sources, detectors, boundaries, etc.)\n        config (SimulationConfig): Simulation parameters including:\n            - time_steps_total: Total number of steps to simulate\n            - invertible_optimization: Whether to record boundaries for backprop\n        key (jax.Array): JAX PRNGKey for any stochastic operations\n\n    Returns:\n        SimulationState: Tuple containing:\n            - Final time step (int)\n            - ArrayContainer with the final state of all fields and components\n\n    Notes:\n        The implementation uses custom vector-Jacobian products (VJPs) to enable\n        efficient backpropagation through the entire simulation while maintaining\n        numerical stability. This makes it suitable for gradient-based optimization\n        of electromagnetic designs.\n    \"\"\"\n    arrays = reset_array_container(\n        arrays,\n        objects,\n    )\n\n    def reversible_fdtd_base(\n        arr: ArrayContainer,\n    ) -&gt; SimulationState:\n        \"\"\"Core implementation of reversible FDTD simulation.\n\n        Performs the main FDTD time-stepping loop using a while loop that respects\n        JAX's functional programming model.\n\n        Args:\n            arr: ArrayContainer with initial field state and material properties\n\n        Returns:\n            SimulationState tuple containing:\n                - Final time step\n                - ArrayContainer with final simulation state\n        \"\"\"\n        state = (jnp.asarray(0, dtype=jnp.int32), arr)\n        state = eqxi.while_loop(\n            max_steps=config.time_steps_total,\n            cond_fun=lambda s: config.time_steps_total &gt; s[0],\n            body_fun=partial(\n                forward,\n                config=config,\n                objects=objects,\n                key=key,\n                record_detectors=True,\n                record_boundaries=config.invertible_optimization,\n                simulate_boundaries=True,\n            ),\n            init_val=state,\n            kind=\"lax\",\n        )\n        return (state[0], state[1])\n\n    @jax.custom_vjp\n    def reversible_fdtd_primal(\n        E: jax.Array,\n        H: jax.Array,\n        inv_permittivities: jax.Array,\n        inv_permeabilities: jax.Array,\n        boundary_states: dict[str, BoundaryState],\n        detector_states: dict[str, DetectorState],\n        recording_state: RecordingState | None,\n    ):\n        arr = ArrayContainer(\n            E=E,\n            H=H,\n            inv_permittivities=inv_permittivities,\n            inv_permeabilities=inv_permeabilities,\n            boundary_states=boundary_states,\n            detector_states=detector_states,\n            recording_state=recording_state,\n        )\n        state = reversible_fdtd_base(arr)\n        return (\n            state[0],\n            state[1].E,\n            state[1].H,\n            state[1].inv_permittivities,\n            state[1].inv_permeabilities,\n            state[1].boundary_states,\n            state[1].detector_states,\n            state[1].recording_state,\n        )\n\n    def body_fn(\n        sr_tuple,\n    ):\n        state, cot = sr_tuple\n        state = backward(\n            state=state,\n            config=config,\n            objects=objects,\n            key=key,\n            record_detectors=False,\n            reset_fields=False,\n        )\n        _, update_vjp = jax.vjp(\n            partial(\n                forward_single_args_wrapper,\n                config=config,\n                objects=objects,\n                key=key,\n                record_detectors=True,\n                record_boundaries=False,\n                simulate_boundaries=True,\n            ),\n            state[0],\n            state[1].E,\n            state[1].H,\n            state[1].inv_permittivities,\n            state[1].inv_permeabilities,\n            state[1].boundary_states,\n            state[1].detector_states,\n            state[1].recording_state,\n        )\n\n        cot = update_vjp(cot)\n        return state, cot\n\n    def cond_fun(\n        sr_tuple,\n        start_time_step: int,\n    ):\n        s_k, r_k = sr_tuple\n        del r_k\n        time_step = s_k[0]\n        return time_step &gt;= start_time_step\n\n    def fdtd_bwd(\n        residual,\n        cot,\n    ):\n        \"\"\"Backward pass for reversible FDTD simulation.\n\n        Implements the custom vector-Jacobian product for backpropagation through\n        the FDTD simulation by leveraging time-reversibility.\n\n        Args:\n            residual: Tuple containing the final simulation state including:\n                - Time step\n                - E, H field arrays\n                - Material properties\n                - Boundary and detector states\n                - Recording state\n            cot: Cotangent values for gradient computation\n\n        Returns:\n            Tuple of cotangent values for each input parameter\n        \"\"\"\n        (\n            res_time_step,\n            res_E,\n            res_H,\n            res_inv_permittivities,\n            res_inv_permeabilities,\n            res_boundary_states,\n            res_detector_states,\n            res_recording_state,\n        ) = residual\n\n        s_k = ArrayContainer(\n            E=res_E,\n            H=res_H,\n            inv_permittivities=res_inv_permittivities,\n            inv_permeabilities=res_inv_permeabilities,\n            boundary_states=res_boundary_states,\n            detector_states=res_detector_states,\n            recording_state=res_recording_state,\n        )\n\n        _, cot = eqxi.while_loop(\n            cond_fun=partial(cond_fun, start_time_step=0),\n            body_fun=body_fn,\n            init_val=((res_time_step, s_k), cot),\n            kind=\"lax\",\n        )\n        return (\n            None,  # cot[1],\n            None,  # cot[2],\n            cot[3],\n            cot[4],\n            None,  # cot[5]\n            None,  # cot[6],\n            None,  # cot[7],\n        )\n\n    def fdtd_fwd(\n        E: jax.Array,\n        H: jax.Array,\n        inv_permittivities: jax.Array,\n        inv_permeabilities: jax.Array,\n        boundary_states: dict[str, BoundaryState],\n        detector_states: dict[str, DetectorState],\n        recording_state: RecordingState | None,\n    ):\n        \"\"\"Forward pass for reversible FDTD simulation.\n\n        Performs the forward FDTD simulation and prepares residuals for the backward pass.\n\n        Args:\n            E: Electric field array\n            H: Magnetic field array\n            inv_permittivities: Inverse permittivity values\n            inv_permeabilities: Inverse permeability values\n            boundary_states: Dictionary mapping boundary names to their states\n            detector_states: Dictionary mapping detector names to their states\n            recording_state: Optional state for recording field evolution\n\n        Returns:\n            Tuple containing:\n                - Primal outputs (final simulation state)\n                - Residuals for backward pass\n        \"\"\"\n        arr = ArrayContainer(\n            E=E,\n            H=H,\n            inv_permittivities=inv_permittivities,\n            inv_permeabilities=inv_permeabilities,\n            boundary_states=boundary_states,\n            detector_states=detector_states,\n            recording_state=recording_state,\n        )\n        s_k = reversible_fdtd_base(arr)\n\n        primal_out = (\n            s_k[0],\n            s_k[1].E,\n            s_k[1].H,\n            s_k[1].inv_permittivities,\n            s_k[1].inv_permeabilities,\n            s_k[1].boundary_states,\n            s_k[1].detector_states,\n            s_k[1].recording_state,  # None\n        )\n        residual = (\n            s_k[0],\n            s_k[1].E,\n            s_k[1].H,\n            s_k[1].inv_permittivities,\n            s_k[1].inv_permeabilities,\n            s_k[1].boundary_states,\n            s_k[1].detector_states,\n            s_k[1].recording_state,\n        )\n        return primal_out, residual\n\n    reversible_fdtd_primal.defvjp(fdtd_fwd, fdtd_bwd)\n\n    (\n        time_step,\n        E,\n        H,\n        inv_permittivities,\n        inv_permeabilities,\n        boundary_states,\n        detector_states,\n        recording_state,\n    ) = reversible_fdtd_primal(\n        E=arrays.E,\n        H=arrays.H,\n        inv_permittivities=arrays.inv_permittivities,\n        inv_permeabilities=arrays.inv_permeabilities,\n        boundary_states=arrays.boundary_states,\n        detector_states=arrays.detector_states,\n        recording_state=arrays.recording_state,\n    )\n    out_arrs = ArrayContainer(\n        E=E,\n        H=H,\n        inv_permittivities=inv_permittivities,\n        inv_permeabilities=inv_permeabilities,\n        boundary_states=boundary_states,\n        detector_states=detector_states,\n        recording_state=recording_state,\n    )\n    return time_step, out_arrs\n</code></pre>"},{"location":"api/fdtd/core/#checkpointed-fdtd","title":"Checkpointed FDTD","text":"<p>Gradient checkpointing FDTD implementation for memory-performance tradeoff.</p>"},{"location":"api/fdtd/core/#fdtdx.fdtd.checkpointed_fdtd","title":"<code>fdtdx.fdtd.checkpointed_fdtd(arrays, objects, config, key)</code>","text":"<p>Run an FDTD simulation with gradient checkpointing for memory efficiency.</p> <p>This implementation uses checkpointing to reduce memory usage during backpropagation by only storing the field state at certain intervals and recomputing intermediate states as needed.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>ArrayContainer</code> <p>Initial state of the simulation containing fields and materials</p> required <code>objects</code> <code>ObjectContainer</code> <p>Collection of physical objects in the simulation</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation parameters including checkpointing settings</p> required <code>key</code> <code>Array</code> <p>JAX PRNGKey for any stochastic operations</p> required <p>Returns:</p> Name Type Description <code>SimulationState</code> <code>SimulationState</code> <p>Tuple containing final time step and ArrayContainer with final state</p> Notes <p>The number of checkpoints can be configured through config.gradient_config.num_checkpoints. More checkpoints reduce recomputation but increase memory usage.</p> Source code in <code>src/fdtdx/fdtd/fdtd.py</code> <pre><code>def checkpointed_fdtd(\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    config: SimulationConfig,\n    key: jax.Array,\n) -&gt; SimulationState:\n    \"\"\"Run an FDTD simulation with gradient checkpointing for memory efficiency.\n\n    This implementation uses checkpointing to reduce memory usage during backpropagation\n    by only storing the field state at certain intervals and recomputing intermediate\n    states as needed.\n\n    Args:\n        arrays (ArrayContainer): Initial state of the simulation containing fields and materials\n        objects (ObjectContainer): Collection of physical objects in the simulation\n        config (SimulationConfig): Simulation parameters including checkpointing settings\n        key (jax.Array): JAX PRNGKey for any stochastic operations\n\n    Returns:\n        SimulationState: Tuple containing final time step and ArrayContainer with final state\n\n    Notes:\n        The number of checkpoints can be configured through config.gradient_config.num_checkpoints.\n        More checkpoints reduce recomputation but increase memory usage.\n    \"\"\"\n    arrays = reset_array_container(arrays, objects)\n    state = (jnp.asarray(0, dtype=jnp.int32), arrays)\n    state = eqxi.while_loop(\n        max_steps=config.time_steps_total,\n        cond_fun=lambda s: config.time_steps_total &gt; s[0],\n        body_fun=partial(\n            forward,\n            config=config,\n            objects=objects,\n            key=key,\n            record_detectors=True,\n            record_boundaries=config.invertible_optimization,\n            simulate_boundaries=True,\n        ),\n        init_val=state,\n        kind=\"lax\" if config.only_forward is None else \"checkpointed\",\n        checkpoints=(None if config.gradient_config is None else config.gradient_config.num_checkpoints),\n    )\n\n    return state\n</code></pre>"},{"location":"api/fdtd/core/#custom-time-evolution","title":"Custom Time Evolution","text":"<p>Customizable FDTD implementation for partial time evolution and analysis.</p>"},{"location":"api/fdtd/core/#fdtdx.fdtd.custom_fdtd_forward","title":"<code>fdtdx.fdtd.custom_fdtd_forward(arrays, objects, config, key, reset_container, record_detectors, start_time, end_time)</code>","text":"<p>Run a customizable forward FDTD simulation between specified time steps.</p> <p>This function provides fine-grained control over the simulation execution, allowing partial time evolution and customization of recording behavior.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>ArrayContainer</code> <p>Initial state of the simulation</p> required <code>objects</code> <code>ObjectContainer</code> <p>Collection of physical objects</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation parameters</p> required <code>key</code> <code>Array</code> <p>JAX PRNGKey for stochastic operations</p> required <code>reset_container</code> <code>bool</code> <p>Whether to reset the array container before starting</p> required <code>record_detectors</code> <code>bool</code> <p>Whether to record detector readings</p> required <code>start_time</code> <code>int | Array</code> <p>Time step to start from</p> required <code>end_time</code> <code>int | Array</code> <p>Time step to end at</p> required <p>Returns:</p> Name Type Description <code>SimulationState</code> <code>SimulationState</code> <p>Tuple containing final time step and ArrayContainer with final state</p> Notes <p>This function is useful for implementing custom simulation strategies or running partial simulations for analysis purposes.</p> Source code in <code>src/fdtdx/fdtd/fdtd.py</code> <pre><code>def custom_fdtd_forward(\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    config: SimulationConfig,\n    key: jax.Array,\n    reset_container: bool,\n    record_detectors: bool,\n    start_time: int | jax.Array,\n    end_time: int | jax.Array,\n) -&gt; SimulationState:\n    \"\"\"Run a customizable forward FDTD simulation between specified time steps.\n\n    This function provides fine-grained control over the simulation execution,\n    allowing partial time evolution and customization of recording behavior.\n\n    Args:\n        arrays (ArrayContainer): Initial state of the simulation\n        objects (ObjectContainer): Collection of physical objects\n        config (SimulationConfig): Simulation parameters\n        key (jax.Array): JAX PRNGKey for stochastic operations\n        reset_container (bool): Whether to reset the array container before starting\n        record_detectors (bool): Whether to record detector readings\n        start_time (int | jax.Array): Time step to start from\n        end_time (int | jax.Array): Time step to end at\n\n    Returns:\n        SimulationState: Tuple containing final time step and ArrayContainer with final state\n\n    Notes:\n        This function is useful for implementing custom simulation strategies or\n        running partial simulations for analysis purposes.\n    \"\"\"\n    if reset_container:\n        arrays = reset_array_container(arrays, objects)\n    state = (jnp.asarray(start_time, dtype=jnp.int32), arrays)\n    state = eqxi.while_loop(\n        max_steps=config.time_steps_total,\n        cond_fun=lambda s: end_time &gt; s[0],\n        body_fun=partial(\n            forward,\n            config=config,\n            objects=objects,\n            key=key,\n            record_detectors=record_detectors,\n            record_boundaries=False,\n            simulate_boundaries=True,\n        ),\n        init_val=state,\n        kind=\"lax\",\n        checkpoints=None,\n    )\n\n    return state\n</code></pre>"},{"location":"api/fdtd/core/#forward-propagation","title":"Forward Propagation","text":"<p>Standard forward FDTD time stepping implementation.</p> <p>JAX-compatible wrapper for forward propagation.</p>"},{"location":"api/fdtd/core/#fdtdx.fdtd.forward.forward","title":"<code>fdtdx.fdtd.forward.forward(state, config, objects, key, record_detectors, record_boundaries, simulate_boundaries)</code>","text":"<p>Performs one forward time step of the FDTD simulation.</p> <p>Implements the core FDTD update scheme based on Maxwell's equations discretized on the Yee grid. Updates include: 1. Electric field update using curl of H field 2. Magnetic field update using curl of E field 3. Optional PML boundary conditions 4. Optional detector state updates 5. Optional recording of boundary values for gradient computation</p> <p>The implementation leverages JAX for automatic compilation and GPU acceleration. Field updates follow the standard staggered time stepping of the Yee scheme.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>SimulationState</code> <p>Current simulation state (time step and field values)</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration parameters</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with sources, PML and other simulation objects</p> required <code>key</code> <code>Array</code> <p>Random key for compression</p> required <code>record_detectors</code> <code>bool</code> <p>Whether to record detector values</p> required <code>record_boundaries</code> <code>bool</code> <p>Whether to record boundary values for gradients</p> required <code>simulate_boundaries</code> <code>bool</code> <p>Whether to apply PML boundary conditions</p> required <p>Returns:</p> Type Description <code>SimulationState</code> <p>Updated simulation state for the next time step</p> Source code in <code>src/fdtdx/fdtd/forward.py</code> <pre><code>def forward(\n    state: SimulationState,\n    config: SimulationConfig,\n    objects: ObjectContainer,\n    key: jax.Array,\n    record_detectors: bool,\n    record_boundaries: bool,\n    simulate_boundaries: bool,\n) -&gt; SimulationState:\n    \"\"\"Performs one forward time step of the FDTD simulation.\n\n    Implements the core FDTD update scheme based on Maxwell's equations discretized on the Yee grid.\n    Updates include:\n    1. Electric field update using curl of H field\n    2. Magnetic field update using curl of E field\n    3. Optional PML boundary conditions\n    4. Optional detector state updates\n    5. Optional recording of boundary values for gradient computation\n\n    The implementation leverages JAX for automatic compilation and GPU acceleration.\n    Field updates follow the standard staggered time stepping of the Yee scheme.\n\n    Args:\n        state: Current simulation state (time step and field values)\n        config: Simulation configuration parameters\n        objects: Container with sources, PML and other simulation objects\n        key: Random key for compression\n        record_detectors: Whether to record detector values\n        record_boundaries: Whether to record boundary values for gradients\n        simulate_boundaries: Whether to apply PML boundary conditions\n\n    Returns:\n        Updated simulation state for the next time step\n    \"\"\"\n    time_step, arrays = state\n    H_prev = arrays.H\n    arrays = update_E(\n        time_step=time_step,\n        arrays=arrays,\n        objects=objects,\n        config=config,\n        simulate_boundaries=simulate_boundaries,\n    )\n    arrays = update_H(\n        time_step=time_step,\n        arrays=arrays,\n        objects=objects,\n        config=config,\n        simulate_boundaries=simulate_boundaries,\n    )\n\n    if record_boundaries:\n        arrays = jax.lax.stop_gradient(\n            collect_interfaces(\n                time_step=time_step,\n                arrays=arrays,\n                objects=objects,\n                config=config,\n                key=key,\n            )\n        )\n\n    if record_detectors:\n        arrays = update_detector_states(\n            time_step=time_step,\n            arrays=arrays,\n            objects=objects,\n            H_prev=H_prev,\n            inverse=False,\n        )\n\n    next_state = (time_step + 1, arrays)\n    return next_state\n</code></pre>"},{"location":"api/fdtd/core/#fdtdx.fdtd.forward.forward_single_args_wrapper","title":"<code>fdtdx.fdtd.forward.forward_single_args_wrapper(time_step, E, H, inv_permittivities, inv_permeabilities, boundary_states, detector_states, recording_state, config, objects, key, record_detectors, record_boundaries, simulate_boundaries)</code>","text":"<p>Wrapper function that unpacks ArrayContainer into individual arrays for JAX transformations.</p> <p>This function provides a JAX-compatible interface by handling individual arrays instead of container objects. It converts between the array-based interface required by JAX and the object-oriented ArrayContainer interface used by the rest of the FDTD implementation.</p> <p>Parameters:</p> Name Type Description Default <code>time_step</code> <code>Array</code> <p>Current simulation time step</p> required <code>E</code> <code>Array</code> <p>Electric field array</p> required <code>H</code> <code>Array</code> <p>Magnetic field array</p> required <code>inv_permittivities</code> <code>Array</code> <p>Inverse permittivity values</p> required <code>inv_permeabilities</code> <code>Array</code> <p>Inverse permeability values</p> required <code>boundary_states</code> <code>dict[str, BoundaryState]</code> <p>PML boundary conditions state</p> required <code>detector_states</code> <code>dict[str, DetectorState]</code> <p>States of field detectors</p> required <code>recording_state</code> <code>RecordingState | None</code> <p>Optional state for recording field values</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration parameters</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with sources and other simulation objects</p> required <code>key</code> <code>Array</code> <p>Random key for compression</p> required <code>record_detectors</code> <code>bool</code> <p>Whether to record detector values</p> required <code>record_boundaries</code> <code>bool</code> <p>Whether to record boundary values</p> required <code>simulate_boundaries</code> <code>bool</code> <p>Whether to apply PML boundary conditions</p> required <p>Returns:</p> Type Description <code>tuple[Array, Array, Array, Array, Array, dict[str, BoundaryState], dict[str, DetectorState], RecordingState | None]</code> <p>Tuple containing: - Updated time step - Updated E field array - Updated H field array - Updated inverse permittivities - Updated inverse permeabilities - Updated boundary states - Updated detector states - Updated recording state</p> Source code in <code>src/fdtdx/fdtd/forward.py</code> <pre><code>def forward_single_args_wrapper(\n    time_step: jax.Array,\n    E: jax.Array,\n    H: jax.Array,\n    inv_permittivities: jax.Array,\n    inv_permeabilities: jax.Array,\n    boundary_states: dict[str, BoundaryState],\n    detector_states: dict[str, DetectorState],\n    recording_state: RecordingState | None,\n    config: SimulationConfig,\n    objects: ObjectContainer,\n    key: jax.Array,\n    record_detectors: bool,\n    record_boundaries: bool,\n    simulate_boundaries: bool,\n) -&gt; tuple[\n    jax.Array,\n    jax.Array,\n    jax.Array,\n    jax.Array,\n    jax.Array,\n    dict[str, BoundaryState],\n    dict[str, DetectorState],\n    RecordingState | None,\n]:\n    \"\"\"Wrapper function that unpacks ArrayContainer into individual arrays for JAX transformations.\n\n    This function provides a JAX-compatible interface by handling individual arrays instead of\n    container objects. It converts between the array-based interface required by JAX and the\n    object-oriented ArrayContainer interface used by the rest of the FDTD implementation.\n\n    Args:\n        time_step: Current simulation time step\n        E: Electric field array\n        H: Magnetic field array\n        inv_permittivities: Inverse permittivity values\n        inv_permeabilities: Inverse permeability values\n        boundary_states: PML boundary conditions state\n        detector_states: States of field detectors\n        recording_state: Optional state for recording field values\n        config: Simulation configuration parameters\n        objects: Container with sources and other simulation objects\n        key: Random key for compression\n        record_detectors: Whether to record detector values\n        record_boundaries: Whether to record boundary values\n        simulate_boundaries: Whether to apply PML boundary conditions\n\n    Returns:\n        Tuple containing:\n            - Updated time step\n            - Updated E field array\n            - Updated H field array\n            - Updated inverse permittivities\n            - Updated inverse permeabilities\n            - Updated boundary states\n            - Updated detector states\n            - Updated recording state\n    \"\"\"\n    \"\"\"Wrapper function that unpacks ArrayContainer into individual arrays for JAX transformations.\n\n    This function provides a JAX-compatible interface by handling individual arrays instead of\n    container objects. It converts between the array-based interface required by JAX and the\n    object-oriented ArrayContainer interface used by the rest of the FDTD implementation.\n\n    Args:\n        time_step: Current simulation time step\n        E: Electric field array\n        H: Magnetic field array \n        inv_permittivities: Inverse permittivity values\n        inv_permeabilities: Inverse permeability values\n        boundary_states: PML boundary conditions state\n        detector_states: States of field detectors\n        recording_state: Optional state for recording field values\n        config: Simulation configuration parameters\n        objects: Container with sources and other simulation objects\n        key: Random key for compression\n        record_detectors: Whether to record detector values\n        record_boundaries: Whether to record boundary values\n        simulate_boundaries: Whether to apply PML boundary conditions\n\n    Returns:\n        Tuple containing the updated time step and field arrays\n    \"\"\"\n    arr = ArrayContainer(\n        E=E,\n        H=H,\n        inv_permittivities=inv_permittivities,\n        inv_permeabilities=inv_permeabilities,\n        boundary_states=boundary_states,\n        detector_states=detector_states,\n        recording_state=recording_state,\n    )\n    state = forward(\n        state=(time_step, arr),\n        config=config,\n        objects=objects,\n        key=key,\n        record_detectors=record_detectors,\n        record_boundaries=record_boundaries,\n        simulate_boundaries=simulate_boundaries,\n    )\n    return (\n        state[0],\n        state[1].E,\n        state[1].H,\n        state[1].inv_permittivities,\n        state[1].inv_permeabilities,\n        state[1].boundary_states,\n        state[1].detector_states,\n        state[1].recording_state,\n    )\n</code></pre>"},{"location":"api/fdtd/core/#backward-propagation","title":"Backward Propagation","text":"<p>Complete backward FDTD propagation from current state to start time.</p> <p>Single step backward FDTD propagation.</p>"},{"location":"api/fdtd/core/#fdtdx.fdtd.backward.full_backward","title":"<code>fdtdx.fdtd.backward.full_backward(state, objects, config, key, record_detectors, reset_fields, start_time_step=0)</code>","text":"<p>Perform full backward FDTD propagation from current state to start time.</p> <p>Uses a while loop to repeatedly call backward() until reaching start_time_step. Leverages time-reversibility of Maxwell's equations.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>SimulationState</code> <p>Current simulation state tuple (time_step, arrays)</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with simulation objects (sources, detectors, etc)</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration parameters</p> required <code>key</code> <code>Array</code> <p>JAX PRNG key for random operations</p> required <code>record_detectors</code> <code>bool</code> <p>Whether to record detector states</p> required <code>reset_fields</code> <code>bool</code> <p>Whether to reset fields after each step</p> required <code>start_time_step</code> <code>int</code> <p>Time step to propagate back to (default: 0)</p> <code>0</code> <p>Returns:</p> Name Type Description <code>SimulationState</code> <code>SimulationState</code> <p>Final state after backward propagation</p> Source code in <code>src/fdtdx/fdtd/backward.py</code> <pre><code>def full_backward(\n    state: SimulationState,\n    objects: ObjectContainer,\n    config: SimulationConfig,\n    key: jax.Array,\n    record_detectors: bool,\n    reset_fields: bool,\n    start_time_step: int = 0,\n) -&gt; SimulationState:\n    \"\"\"Perform full backward FDTD propagation from current state to start time.\n\n    Uses a while loop to repeatedly call backward() until reaching start_time_step.\n    Leverages time-reversibility of Maxwell's equations.\n\n    Args:\n        state: Current simulation state tuple (time_step, arrays)\n        objects: Container with simulation objects (sources, detectors, etc)\n        config: Simulation configuration parameters\n        key: JAX PRNG key for random operations\n        record_detectors: Whether to record detector states\n        reset_fields: Whether to reset fields after each step\n        start_time_step: Time step to propagate back to (default: 0)\n\n    Returns:\n        SimulationState: Final state after backward propagation\n    \"\"\"\n    s0 = eqxi.while_loop(\n        cond_fun=partial(cond_fn, start_time_step=start_time_step),\n        body_fun=partial(\n            backward,\n            config=config,\n            objects=objects,\n            key=key,\n            record_detectors=record_detectors,\n            reset_fields=reset_fields,\n        ),\n        init_val=state,\n        kind=\"lax\",\n    )\n    return s0\n</code></pre>"},{"location":"api/fdtd/core/#fdtdx.fdtd.backward.backward","title":"<code>fdtdx.fdtd.backward.backward(state, config, objects, key, record_detectors, reset_fields, fields_to_reset=('E', 'H'))</code>","text":"<p>Perform one step of backward FDTD propagation.</p> <p>Updates fields from time step t to t-1 using time-reversed Maxwell's equations. Handles interfaces, field updates, optional field resetting, and detector recording.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>SimulationState</code> <p>Current simulation state tuple (time_step, arrays)</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration parameters</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with simulation objects (sources, detectors, etc)</p> required <code>key</code> <code>Array</code> <p>JAX PRNG key for random operations</p> required <code>record_detectors</code> <code>bool</code> <p>Whether to record detector states</p> required <code>reset_fields</code> <code>bool</code> <p>Whether to reset fields after updates</p> required <code>fields_to_reset</code> <code>Sequence[str]</code> <p>Which fields to reset if reset_fields is True</p> <code>('E', 'H')</code> <p>Returns:</p> Name Type Description <code>SimulationState</code> <code>SimulationState</code> <p>Updated state after one backward step</p> Source code in <code>src/fdtdx/fdtd/backward.py</code> <pre><code>def backward(\n    state: SimulationState,\n    config: SimulationConfig,\n    objects: ObjectContainer,\n    key: jax.Array,\n    record_detectors: bool,\n    reset_fields: bool,\n    fields_to_reset: Sequence[str] = (\"E\", \"H\"),\n) -&gt; SimulationState:\n    \"\"\"Perform one step of backward FDTD propagation.\n\n    Updates fields from time step t to t-1 using time-reversed Maxwell's equations.\n    Handles interfaces, field updates, optional field resetting, and detector recording.\n\n    Args:\n        state: Current simulation state tuple (time_step, arrays)\n        config: Simulation configuration parameters\n        objects: Container with simulation objects (sources, detectors, etc)\n        key: JAX PRNG key for random operations\n        record_detectors: Whether to record detector states\n        reset_fields: Whether to reset fields after updates\n        fields_to_reset: Which fields to reset if reset_fields is True\n\n    Returns:\n        SimulationState: Updated state after one backward step\n    \"\"\"\n    time_step, arrays = state\n    time_step = time_step - 1\n\n    arrays = add_interfaces(\n        time_step=time_step,\n        arrays=arrays,\n        objects=objects,\n        config=config,\n        key=key,\n    )\n\n    H = arrays.H\n\n    arrays = update_H_reverse(\n        time_step=time_step,\n        arrays=arrays,\n        config=config,\n        objects=objects,\n    )\n\n    arrays = update_E_reverse(\n        time_step=time_step,\n        arrays=arrays,\n        config=config,\n        objects=objects,\n    )\n\n    if reset_fields:\n        new_fields = {f: getattr(arrays, f) for f in fields_to_reset}\n        for pml in objects.pml_objects:\n            for name in fields_to_reset:\n                new_fields[name] = new_fields[name].at[:, *pml.grid_slice].set(0)\n        for name, f in new_fields.items():\n            arrays = arrays.aset(name, f)\n\n    if record_detectors:\n        arrays = update_detector_states(\n            time_step=time_step,\n            arrays=arrays,\n            objects=objects,\n            H_prev=H,\n            inverse=True,\n        )\n\n    next_state = (time_step, arrays)\n    return next_state\n</code></pre>"},{"location":"api/fdtd/fields/","title":"Field Operations","text":""},{"location":"api/fdtd/fields/#field-interpolation","title":"Field Interpolation","text":""},{"location":"api/fdtd/fields/#fdtdx.fdtd.curl.interpolate_fields","title":"<code>fdtdx.fdtd.curl.interpolate_fields(E_field, H_field)</code>","text":"<p>Interpolates E and H fields onto E_z in a FDTD grid with PEC boundary conditions.</p> <p>Performs spatial interpolation of the electric and magnetic fields to align them onto the same grid points as E_z. This is necessary because E and H fields are naturally staggered in the Yee grid.</p> <p>Parameters:</p> Name Type Description Default <code>E_field</code> <code>Array</code> <p>4D tensor representing the electric field.     Dimensions are (width, depth, height, direction).</p> required <code>H_field</code> <code>Array</code> <p>4D tensor representing the magnetic field.     Dimensions are (width, depth, height, direction).</p> required <p>Returns:</p> Type Description <code>tuple[Array, Array]</code> <p>tuple[jax.Array, jax.Array]: A tuple (E_interp, H_interp) containing: - E_interp: Interpolated electric field as 4D tensor - H_interp: Interpolated magnetic field as 4D tensor</p> Note <p>Uses PEC (Perfect Electric Conductor) boundary conditions where fields at boundaries are set to zero.</p> Source code in <code>src/fdtdx/fdtd/curl.py</code> <pre><code>def interpolate_fields(\n    E_field: jax.Array,\n    H_field: jax.Array,\n) -&gt; tuple[jax.Array, jax.Array]:\n    \"\"\"Interpolates E and H fields onto E_z in a FDTD grid with PEC boundary conditions.\n\n    Performs spatial interpolation of the electric and magnetic fields to align them\n    onto the same grid points as E_z. This is necessary because E and H fields are\n    naturally staggered in the Yee grid.\n\n    Args:\n        E_field: 4D tensor representing the electric field.\n                Dimensions are (width, depth, height, direction).\n        H_field: 4D tensor representing the magnetic field.\n                Dimensions are (width, depth, height, direction).\n\n    Returns:\n        tuple[jax.Array, jax.Array]: A tuple (E_interp, H_interp) containing:\n            - E_interp: Interpolated electric field as 4D tensor\n            - H_interp: Interpolated magnetic field as 4D tensor\n\n    Note:\n        Uses PEC (Perfect Electric Conductor) boundary conditions where fields\n        at boundaries are set to zero.\n    \"\"\"\n    # Apply PEC boundary conditions: fields at boundaries are zero, TODO: wrapped boundaries\n    E_field = jnp.pad(E_field, ((0, 0), (1, 1), (1, 1), (1, 1)), mode=\"constant\")\n    H_field = jnp.pad(H_field, ((0, 0), (1, 1), (1, 1), (1, 1)), mode=\"constant\")\n\n    E_x, E_y, E_z = E_field[0], E_field[1], E_field[2]\n    H_x, H_y, H_z = H_field[0], H_field[1], H_field[2]\n\n    E_x = (E_x[1:-1, 1:-1, 1:-1] + E_x[1:-1, 1:-1, :-2] + E_x[2:, 1:-1, 1:-1] + E_x[2:, 1:-1, :-2]) / 4.0\n    E_y = (E_y[1:-1, 1:-1, 1:-1] + E_y[1:-1, :-2, 1:-1] + E_y[2:, 1:-1, 1:-1] + E_y[2:, :-2, 1:-1]) / 4.0\n    E_z = E_z[1:-1, 1:-1, 1:-1]  # leave as is since we project onto the E_z\n\n    H_x = (H_x[1:-1, 2:, 1:-1] + H_x[1:-1, :-2, 1:-1]) / 2.0\n    H_y = (H_y[1:-1, 1:-1, 2:] + H_y[1:-1, 1:-1, :-2]) / 2.0\n    H_z = (\n        H_z[:-2, 2:, 2:]\n        + H_z[:-2, 2:, :-2]\n        + H_z[:-2, :-2, 2:]\n        + H_z[:-2, :-2, :-2]\n        + H_z[2:, 2:, 2:]\n        + H_z[2:, 2:, :-2]\n        + H_z[2:, :-2, 2:]\n        + H_z[2:, :-2, :-2]\n    ) / 8.0\n\n    # Constructing the interpolated fields\n    E_interp = jnp.stack([E_x, E_y, E_z], axis=0)\n    H_interp = jnp.stack([H_x, H_y, H_z], axis=0)\n\n    return E_interp, H_interp\n</code></pre>"},{"location":"api/fdtd/fields/#curl-operations","title":"Curl Operations","text":""},{"location":"api/fdtd/fields/#fdtdx.fdtd.curl.curl_E","title":"<code>fdtdx.fdtd.curl.curl_E(E)</code>","text":"<p>Transforms an E-type field into an H-type field by performing a curl operation.</p> <p>Computes the discrete curl of the electric field to obtain the corresponding magnetic field components. The input E-field is defined on the edges of the Yee grid cells (integer grid points), while the output H-field is defined on the faces (half-integer grid points).</p> <p>Parameters:</p> Name Type Description Default <code>E</code> <code>Array</code> <p>Electric field to take the curl of. A 4D tensor representing the E-type field located on the edges of the grid cell (integer gridpoints). Shape is (3, nx, ny, nz) for the 3 field components.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The curl of E - an H-type field located on the faces of the grid       (half-integer grid points). Has same shape as input (3, nx, ny, nz).</p> Note <p>Uses edge padding and roll operations to compute centered differences for the curl.</p> Source code in <code>src/fdtdx/fdtd/curl.py</code> <pre><code>def curl_E(E: jax.Array) -&gt; jax.Array:\n    \"\"\"Transforms an E-type field into an H-type field by performing a curl operation.\n\n    Computes the discrete curl of the electric field to obtain the corresponding\n    magnetic field components. The input E-field is defined on the edges of the Yee grid\n    cells (integer grid points), while the output H-field is defined on the faces\n    (half-integer grid points).\n\n    Args:\n        E: Electric field to take the curl of. A 4D tensor representing the E-type field\n            located on the edges of the grid cell (integer gridpoints).\n            Shape is (3, nx, ny, nz) for the 3 field components.\n\n    Returns:\n        jax.Array: The curl of E - an H-type field located on the faces of the grid\n                  (half-integer grid points). Has same shape as input (3, nx, ny, nz).\n\n    Note:\n        Uses edge padding and roll operations to compute centered differences for the curl.\n    \"\"\"\n\n    E_pad = jnp.pad(E, ((0, 0), (1, 1), (1, 1), (1, 1)), mode=\"edge\")\n\n    curl_x = jnp.roll(E_pad[2], -1, axis=1) - E_pad[2] + E_pad[1] - jnp.roll(E_pad[1], -1, axis=2)\n    curl_y = jnp.roll(E_pad[0], -1, axis=2) - E_pad[0] + E_pad[2] - jnp.roll(E_pad[2], -1, axis=0)\n    curl_z = jnp.roll(E_pad[1], -1, axis=0) - E_pad[1] + E_pad[0] - jnp.roll(E_pad[0], -1, axis=1)\n    curl = jnp.stack((curl_x, curl_y, curl_z), axis=0)[:, 1:-1, 1:-1, 1:-1]\n\n    return curl\n</code></pre>"},{"location":"api/fdtd/fields/#fdtdx.fdtd.curl.curl_H","title":"<code>fdtdx.fdtd.curl.curl_H(H)</code>","text":"<p>Transforms an H-type field into an E-type field by performing a curl operation.</p> <p>Computes the discrete curl of the magnetic field to obtain the corresponding electric field components. The input H-field is defined on the faces of the Yee grid cells (half-integer grid points), while the output E-field is defined on the edges (integer grid points).</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>Array</code> <p>Magnetic field to take the curl of. A 4D tensor representing the H-type field located on the faces of the grid (half-integer grid points). Shape is (3, nx, ny, nz) for the 3 field components.</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The curl of H - an E-type field located on the edges of the grid       (integer grid points). Has same shape as input (3, nx, ny, nz).</p> Note <p>Uses edge padding and roll operations to compute centered differences for the curl. The operation is complementary to curl_E(), allowing field updates in both directions.</p> Source code in <code>src/fdtdx/fdtd/curl.py</code> <pre><code>def curl_H(H: jax.Array) -&gt; jax.Array:\n    \"\"\"Transforms an H-type field into an E-type field by performing a curl operation.\n\n    Computes the discrete curl of the magnetic field to obtain the corresponding\n    electric field components. The input H-field is defined on the faces of the Yee grid\n    cells (half-integer grid points), while the output E-field is defined on the edges\n    (integer grid points).\n\n    Args:\n        H: Magnetic field to take the curl of. A 4D tensor representing the H-type field\n            located on the faces of the grid (half-integer grid points).\n            Shape is (3, nx, ny, nz) for the 3 field components.\n\n    Returns:\n        jax.Array: The curl of H - an E-type field located on the edges of the grid\n                  (integer grid points). Has same shape as input (3, nx, ny, nz).\n\n    Note:\n        Uses edge padding and roll operations to compute centered differences for the curl.\n        The operation is complementary to curl_E(), allowing field updates in both directions.\n    \"\"\"\n    H_pad = jnp.pad(H, ((0, 0), (1, 1), (1, 1), (1, 1)), mode=\"edge\")\n\n    curl_x = H_pad[2] - jnp.roll(H_pad[2], 1, axis=1) - H_pad[1] + jnp.roll(H_pad[1], 1, axis=2)\n    curl_y = H_pad[0] - jnp.roll(H_pad[0], 1, axis=2) - H_pad[2] + jnp.roll(H_pad[2], 1, axis=0)\n    curl_z = H_pad[1] - jnp.roll(H_pad[1], 1, axis=0) - H_pad[0] + jnp.roll(H_pad[0], 1, axis=1)\n    curl = jnp.stack((curl_x, curl_y, curl_z), axis=0)[:, 1:-1, 1:-1, 1:-1]\n\n    return curl\n</code></pre>"},{"location":"api/fdtd/interfaces/","title":"Detector and Interface Management","text":""},{"location":"api/fdtd/interfaces/#detector-updates","title":"Detector Updates","text":""},{"location":"api/fdtd/interfaces/#fdtdx.fdtd.update.update_detector_states","title":"<code>fdtdx.fdtd.update.update_detector_states(time_step, arrays, objects, H_prev, inverse)</code>","text":"<p>Updates detector states based on current field values.</p> <p>Handles field interpolation for accurate detector measurements. By default, interpolation is disabled for performance during optimization, but can be enabled for final evaluation. Interpolation is needed due to the staggered nature of E and H fields on the Yee grid.</p> <p>Parameters:</p> Name Type Description Default <code>time_step</code> <code>Array</code> <p>Current simulation time step</p> required <code>arrays</code> <code>ArrayContainer</code> <p>Container with E, H fields and material properties</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with detectors and other simulation objects</p> required <code>H_prev</code> <code>Array</code> <p>Previous H field values for interpolation</p> required <code>inverse</code> <code>bool</code> <p>Whether this is a forward or reverse update</p> required <p>Returns:</p> Type Description <code>ArrayContainer</code> <p>Updated ArrayContainer with new detector states</p> Source code in <code>src/fdtdx/fdtd/update.py</code> <pre><code>def update_detector_states(\n    time_step: jax.Array,\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    H_prev: jax.Array,\n    inverse: bool,\n) -&gt; ArrayContainer:\n    \"\"\"Updates detector states based on current field values.\n\n    Handles field interpolation for accurate detector measurements. By default,\n    interpolation is disabled for performance during optimization, but can be\n    enabled for final evaluation. Interpolation is needed due to the staggered\n    nature of E and H fields on the Yee grid.\n\n    Args:\n        time_step: Current simulation time step\n        arrays: Container with E, H fields and material properties\n        objects: Container with detectors and other simulation objects\n        H_prev: Previous H field values for interpolation\n        inverse: Whether this is a forward or reverse update\n\n    Returns:\n        Updated ArrayContainer with new detector states\n    \"\"\"\n    \"\"\"Updates detector states based on current field values.\n\n    Handles field interpolation for accurate detector measurements. By default,\n    interpolation is disabled for performance during optimization, but can be\n    enabled for final evaluation. Interpolation is needed due to the staggered\n    nature of E and H fields on the Yee grid.\n\n    Args:\n        time_step: Current simulation time step\n        arrays: Container with E, H fields and material properties\n        objects: Container with detectors and other simulation objects\n        H_prev: Previous H field values for interpolation\n        inverse: Whether this is a forward or reverse update\n\n    Returns:\n        Updated ArrayContainer with new detector states\n    \"\"\"\n    interpolated_E, interpolated_H = interpolate_fields(\n        E_field=arrays.E,\n        H_field=(H_prev + arrays.H) / 2,\n    )\n\n    def helper_fn(E_input, H_input, detector: Detector):\n        detector = tc.unfreeze(detector)\n        return detector.update(\n            time_step=time_step,\n            E=E_input,\n            H=H_input,\n            state=arrays.detector_states[detector.name],\n            inv_permittivity=arrays.inv_permittivities,\n            inv_permeability=arrays.inv_permeabilities,\n        )\n\n    state = arrays.detector_states\n    to_update = objects.backward_detectors if inverse else objects.forward_detectors\n    for d in to_update:\n        state[d.name] = jax.lax.cond(\n            d._is_on_at_time_step_arr[time_step],\n            helper_fn,\n            lambda e, h, _: state[d.name],\n            interpolated_E if d.exact_interpolation else arrays.E,\n            interpolated_H if d.exact_interpolation else arrays.H,\n            tc.freeze(d),\n        )\n    arrays = arrays.aset(\"detector_states\", state)\n    return arrays\n</code></pre>"},{"location":"api/fdtd/interfaces/#interface-handling","title":"Interface Handling","text":""},{"location":"api/fdtd/interfaces/#fdtdx.fdtd.update.collect_interfaces","title":"<code>fdtdx.fdtd.update.collect_interfaces(time_step, arrays, objects, config, key)</code>","text":"<p>Collects field values at PML interfaces for gradient computation.</p> <p>Part of the memory-efficient automatic differentiation implementation. Saves field values at boundaries between PML and inner simulation volume since PML updates are not time-reversible.</p> <p>Parameters:</p> Name Type Description Default <code>time_step</code> <code>Array</code> <p>Current simulation time step</p> required <code>arrays</code> <code>ArrayContainer</code> <p>Container with fields and material properties</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with PML and other simulation objects</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration with gradient settings</p> required <code>key</code> <code>Array</code> <p>Random key for compression</p> required <p>Returns:</p> Type Description <code>ArrayContainer</code> <p>Updated ArrayContainer with recorded interface values</p> Source code in <code>src/fdtdx/fdtd/update.py</code> <pre><code>def collect_interfaces(\n    time_step: jax.Array,\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    config: SimulationConfig,\n    key: jax.Array,\n) -&gt; ArrayContainer:\n    \"\"\"Collects field values at PML interfaces for gradient computation.\n\n    Part of the memory-efficient automatic differentiation implementation.\n    Saves field values at boundaries between PML and inner simulation volume\n    since PML updates are not time-reversible.\n\n    Args:\n        time_step: Current simulation time step\n        arrays: Container with fields and material properties\n        objects: Container with PML and other simulation objects\n        config: Simulation configuration with gradient settings\n        key: Random key for compression\n\n    Returns:\n        Updated ArrayContainer with recorded interface values\n    \"\"\"\n    \"\"\"Collects field values at PML interfaces for gradient computation.\n\n    Part of the memory-efficient automatic differentiation implementation.\n    Saves field values at boundaries between PML and inner simulation volume\n    since PML updates are not time-reversible.\n\n    Args:\n        time_step: Current simulation time step\n        arrays: Container with fields and material properties\n        objects: Container with PML and other simulation objects\n        config: Simulation configuration with gradient settings\n        key: Random key for compression\n\n    Returns:\n        Updated ArrayContainer with recorded interface values\n    \"\"\"\n    if config.gradient_config is None or config.gradient_config.recorder is None:\n        raise Exception(\"Need recorder to record boundaries\")\n    if arrays.recording_state is None:\n        raise Exception(\"Need recording state to record boundaries\")\n    values = collect_boundary_interfaces(\n        arrays=arrays,\n        pml_objects=objects.pml_objects,\n    )\n    recording_state = config.gradient_config.recorder.compress(\n        values=values,\n        state=arrays.recording_state,\n        time_step=time_step,\n        key=key,\n    )\n    arrays = arrays.aset(\"recording_state\", recording_state)\n    return arrays\n</code></pre>"},{"location":"api/fdtd/interfaces/#fdtdx.fdtd.update.add_interfaces","title":"<code>fdtdx.fdtd.update.add_interfaces(time_step, arrays, objects, config, key)</code>","text":"<p>Adds previously collected interface values back to the fields.</p> <p>Part of the memory-efficient automatic differentiation implementation. Restores saved field values at PML boundaries during reverse propagation since PML updates are not time-reversible.</p> <p>Parameters:</p> Name Type Description Default <code>time_step</code> <code>Array</code> <p>Current simulation time step</p> required <code>arrays</code> <code>ArrayContainer</code> <p>Container with fields and material properties</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with PML and other simulation objects</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration with gradient settings</p> required <code>key</code> <code>Array</code> <p>Random key for decompression</p> required <p>Returns:</p> Type Description <code>ArrayContainer</code> <p>Updated ArrayContainer with restored interface values</p> Source code in <code>src/fdtdx/fdtd/update.py</code> <pre><code>def add_interfaces(\n    time_step: jax.Array,\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    config: SimulationConfig,\n    key: jax.Array,\n) -&gt; ArrayContainer:\n    \"\"\"Adds previously collected interface values back to the fields.\n\n    Part of the memory-efficient automatic differentiation implementation.\n    Restores saved field values at PML boundaries during reverse propagation\n    since PML updates are not time-reversible.\n\n    Args:\n        time_step: Current simulation time step\n        arrays: Container with fields and material properties\n        objects: Container with PML and other simulation objects\n        config: Simulation configuration with gradient settings\n        key: Random key for decompression\n\n    Returns:\n        Updated ArrayContainer with restored interface values\n    \"\"\"\n    \"\"\"Adds previously collected interface values back to the fields.\n\n    Part of the memory-efficient automatic differentiation implementation.\n    Restores saved field values at PML boundaries during reverse propagation\n    since PML updates are not time-reversible.\n\n    Args:\n        time_step: Current simulation time step\n        arrays: Container with fields and material properties\n        objects: Container with PML and other simulation objects\n        config: Simulation configuration with gradient settings\n        key: Random key for decompression\n\n    Returns:\n        Updated ArrayContainer with restored interface values\n    \"\"\"\n    if config.gradient_config is None or config.gradient_config.recorder is None:\n        raise Exception(\"Need recorder to record boundaries\")\n    if arrays.recording_state is None:\n        raise Exception(\"Need recording state to record boundaries\")\n\n    values, state = config.gradient_config.recorder.decompress(\n        state=arrays.recording_state,\n        time_step=time_step,\n        key=key,\n    )\n    arrays = arrays.aset(\"recording_state\", state)\n\n    container = add_boundary_interfaces(\n        arrays=arrays,\n        values=values,\n        pml_objects=objects.pml_objects,\n    )\n\n    return container\n</code></pre>"},{"location":"api/fdtd/updates/","title":"Field Updates","text":""},{"location":"api/fdtd/updates/#electric-field-updates","title":"Electric Field Updates","text":""},{"location":"api/fdtd/updates/#fdtdx.fdtd.update.update_E","title":"<code>fdtdx.fdtd.update.update_E(time_step, arrays, objects, config, simulate_boundaries)</code>","text":"<p>Updates the electric field (E) according to Maxwell's equations using the FDTD method.</p> <p>Implements the discretized form of dE/dt = (1/\u03b5)\u2207\u00d7H on the Yee grid. Updates include: 1. PML boundary conditions if simulate_boundaries=True 2. Source contributions for active sources 3. Field updates based on curl of H field</p> <p>Parameters:</p> Name Type Description Default <code>time_step</code> <code>Array</code> <p>Current simulation time step</p> required <code>arrays</code> <code>ArrayContainer</code> <p>Container with E, H fields and material properties</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with sources, PML and other simulation objects</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration parameters</p> required <code>simulate_boundaries</code> <code>bool</code> <p>Whether to apply PML boundary conditions</p> required <p>Returns:</p> Type Description <code>ArrayContainer</code> <p>Updated ArrayContainer with new E field values</p> Source code in <code>src/fdtdx/fdtd/update.py</code> <pre><code>def update_E(\n    time_step: jax.Array,\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    config: SimulationConfig,\n    simulate_boundaries: bool,\n) -&gt; ArrayContainer:\n    \"\"\"Updates the electric field (E) according to Maxwell's equations using the FDTD method.\n\n    Implements the discretized form of dE/dt = (1/\u03b5)\u2207\u00d7H on the Yee grid. Updates include:\n    1. PML boundary conditions if simulate_boundaries=True\n    2. Source contributions for active sources\n    3. Field updates based on curl of H field\n\n    Args:\n        time_step: Current simulation time step\n        arrays: Container with E, H fields and material properties\n        objects: Container with sources, PML and other simulation objects\n        config: Simulation configuration parameters\n        simulate_boundaries: Whether to apply PML boundary conditions\n\n    Returns:\n        Updated ArrayContainer with new E field values\n    \"\"\"\n    boundary_states = {}\n    if simulate_boundaries:\n        for pml in objects.pml_objects:\n            boundary_states[pml.name] = pml.update_E_boundary_state(\n                boundary_state=arrays.boundary_states[pml.name],\n                H=arrays.H,\n            )\n\n    E = arrays.E + config.courant_number * curl_H(arrays.H) * arrays.inv_permittivities\n\n    for source in objects.sources:\n\n        def _update():\n            return source.update_E(\n                E=E,\n                inv_permittivities=arrays.inv_permittivities,\n                inv_permeabilities=arrays.inv_permeabilities,\n                time_step=time_step,\n                inverse=False,\n            )\n\n        E = jax.lax.cond(\n            source._is_on_at_time_step_arr[time_step],\n            _update,\n            lambda: E,\n        )\n\n    if simulate_boundaries:\n        for pml in objects.pml_objects:\n            E = pml.update_E(\n                E=E,\n                boundary_state=boundary_states[pml.name],\n                inverse_permittivity=arrays.inv_permittivities,\n            )\n\n    arrays = arrays.at[\"E\"].set(E)\n    if simulate_boundaries:\n        arrays = arrays.aset(\"boundary_states\", boundary_states)\n\n    return arrays\n</code></pre>"},{"location":"api/fdtd/updates/#fdtdx.fdtd.update.update_E_reverse","title":"<code>fdtdx.fdtd.update.update_E_reverse(time_step, arrays, objects, config)</code>","text":"<p>Reverse time step update for the electric field used in automatic differentiation.</p> <p>Implements the inverse update step that transforms the electromagnetic field state from time step t+1 to time step t, leveraging the time-reversibility property of Maxwell's equations.</p> <p>Parameters:</p> Name Type Description Default <code>time_step</code> <code>Array</code> <p>Current simulation time step</p> required <code>arrays</code> <code>ArrayContainer</code> <p>Container with E, H fields and material properties</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with sources and other simulation objects</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration parameters</p> required <p>Returns:</p> Type Description <code>ArrayContainer</code> <p>Updated ArrayContainer with reversed E field values</p> Source code in <code>src/fdtdx/fdtd/update.py</code> <pre><code>def update_E_reverse(\n    time_step: jax.Array,\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    config: SimulationConfig,\n) -&gt; ArrayContainer:\n    \"\"\"Reverse time step update for the electric field used in automatic differentiation.\n\n    Implements the inverse update step that transforms the electromagnetic field state\n    from time step t+1 to time step t, leveraging the time-reversibility property of\n    Maxwell's equations.\n\n    Args:\n        time_step: Current simulation time step\n        arrays: Container with E, H fields and material properties\n        objects: Container with sources and other simulation objects\n        config: Simulation configuration parameters\n\n    Returns:\n        Updated ArrayContainer with reversed E field values\n    \"\"\"\n    \"\"\"Reverse time step update for the electric field used in automatic differentiation.\n\n    Implements the inverse update step that transforms the electromagnetic field state \n    from time step t+1 to time step t, leveraging the time-reversibility property of\n    Maxwell's equations.\n\n    Args:\n        time_step: Current simulation time step\n        arrays: Container with E, H fields and material properties\n        objects: Container with sources and other simulation objects\n        config: Simulation configuration parameters\n\n    Returns:\n        Updated ArrayContainer with reversed E field values\n    \"\"\"\n    E = arrays.E\n    for source in objects.sources:\n\n        def _update():\n            return source.update_E(\n                E,\n                inv_permittivities=arrays.inv_permittivities,\n                inv_permeabilities=arrays.inv_permeabilities,\n                time_step=time_step,\n                inverse=True,\n            )\n\n        E = jax.lax.cond(\n            source._is_on_at_time_step_arr[time_step],\n            _update,\n            lambda: E,\n        )\n\n    E = E - config.courant_number * curl_H(arrays.H) * arrays.inv_permittivities\n\n    arrays = arrays.at[\"E\"].set(E)\n\n    return arrays\n</code></pre>"},{"location":"api/fdtd/updates/#magnetic-field-updates","title":"Magnetic Field Updates","text":""},{"location":"api/fdtd/updates/#fdtdx.fdtd.update.update_H","title":"<code>fdtdx.fdtd.update.update_H(time_step, arrays, objects, config, simulate_boundaries)</code>","text":"<p>Updates the magnetic field (H) according to Maxwell's equations using the FDTD method.</p> <p>Implements the discretized form of dH/dt = -(1/\u03bc)\u2207\u00d7E on the Yee grid. Updates include: 1. PML boundary conditions if simulate_boundaries=True 2. Source contributions for active sources 3. Field updates based on curl of E field</p> <p>The H field is updated at time points offset by half steps from the E field updates, following the Yee grid scheme.</p> <p>Parameters:</p> Name Type Description Default <code>time_step</code> <code>Array</code> <p>Current simulation time step</p> required <code>arrays</code> <code>ArrayContainer</code> <p>Container with E, H fields and material properties</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with sources, PML and other simulation objects</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration parameters</p> required <code>simulate_boundaries</code> <code>bool</code> <p>Whether to apply PML boundary conditions</p> required <p>Returns:</p> Type Description <code>ArrayContainer</code> <p>Updated ArrayContainer with new H field values</p> Source code in <code>src/fdtdx/fdtd/update.py</code> <pre><code>def update_H(\n    time_step: jax.Array,\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    config: SimulationConfig,\n    simulate_boundaries: bool,\n) -&gt; ArrayContainer:\n    \"\"\"Updates the magnetic field (H) according to Maxwell's equations using the FDTD method.\n\n    Implements the discretized form of dH/dt = -(1/\u03bc)\u2207\u00d7E on the Yee grid. Updates include:\n    1. PML boundary conditions if simulate_boundaries=True\n    2. Source contributions for active sources\n    3. Field updates based on curl of E field\n\n    The H field is updated at time points offset by half steps from the E field updates,\n    following the Yee grid scheme.\n\n    Args:\n        time_step: Current simulation time step\n        arrays: Container with E, H fields and material properties\n        objects: Container with sources, PML and other simulation objects\n        config: Simulation configuration parameters\n        simulate_boundaries: Whether to apply PML boundary conditions\n\n    Returns:\n        Updated ArrayContainer with new H field values\n    \"\"\"\n    boundary_states = {}\n    if simulate_boundaries:\n        for pml in objects.pml_objects:\n            boundary_states[pml.name] = pml.update_H_boundary_state(\n                boundary_state=arrays.boundary_states[pml.name],\n                E=arrays.E,\n            )\n\n    H = arrays.H - config.courant_number * curl_E(arrays.E) * arrays.inv_permeabilities\n\n    for source in objects.sources:\n\n        def _update():\n            return source.update_H(\n                H=H,\n                inv_permittivities=arrays.inv_permittivities,\n                inv_permeabilities=arrays.inv_permeabilities,\n                time_step=time_step + 0.5,\n                inverse=False,\n            )\n\n        H = jax.lax.cond(\n            source._is_on_at_time_step_arr[time_step],\n            _update,\n            lambda: H,\n        )\n\n    if simulate_boundaries:\n        for pml in objects.pml_objects:\n            H = pml.update_H(\n                H=H,\n                boundary_state=boundary_states[pml.name],\n                inverse_permeability=arrays.inv_permeabilities,\n            )\n\n    arrays = arrays.at[\"H\"].set(H)\n    if simulate_boundaries:\n        arrays = arrays.aset(\"boundary_states\", boundary_states)\n\n    return arrays\n</code></pre>"},{"location":"api/fdtd/updates/#fdtdx.fdtd.update.update_H_reverse","title":"<code>fdtdx.fdtd.update.update_H_reverse(time_step, arrays, objects, config)</code>","text":"<p>Reverse time step update for the magnetic field used in automatic differentiation.</p> <p>Implements the inverse update step that transforms the electromagnetic field state from time step t+1 to time step t, leveraging the time-reversibility property of Maxwell's equations.</p> <p>Parameters:</p> Name Type Description Default <code>time_step</code> <code>Array</code> <p>Current simulation time step</p> required <code>arrays</code> <code>ArrayContainer</code> <p>Container with E, H fields and material properties</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with sources and other simulation objects</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration parameters</p> required <p>Returns:</p> Type Description <code>ArrayContainer</code> <p>Updated ArrayContainer with reversed H field values</p> Source code in <code>src/fdtdx/fdtd/update.py</code> <pre><code>def update_H_reverse(\n    time_step: jax.Array,\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    config: SimulationConfig,\n) -&gt; ArrayContainer:\n    \"\"\"Reverse time step update for the magnetic field used in automatic differentiation.\n\n    Implements the inverse update step that transforms the electromagnetic field state\n    from time step t+1 to time step t, leveraging the time-reversibility property of\n    Maxwell's equations.\n\n    Args:\n        time_step: Current simulation time step\n        arrays: Container with E, H fields and material properties\n        objects: Container with sources and other simulation objects\n        config: Simulation configuration parameters\n\n    Returns:\n        Updated ArrayContainer with reversed H field values\n    \"\"\"\n    \"\"\"Reverse time step update for the magnetic field used in automatic differentiation.\n\n    Implements the inverse update step that transforms the electromagnetic field state\n    from time step t+1 to time step t, leveraging the time-reversibility property of\n    Maxwell's equations.\n\n    Args:\n        time_step: Current simulation time step\n        arrays: Container with E, H fields and material properties\n        objects: Container with sources and other simulation objects\n        config: Simulation configuration parameters\n\n    Returns:\n        Updated ArrayContainer with reversed H field values\n    \"\"\"\n    H = arrays.H\n    for source in objects.sources:\n\n        def _update():\n            return source.update_H(\n                H,\n                inv_permittivities=arrays.inv_permittivities,\n                inv_permeabilities=arrays.inv_permeabilities,\n                time_step=time_step + 0.5,\n                inverse=True,\n            )\n\n        H = jax.lax.cond(\n            source._is_on_at_time_step_arr[time_step],\n            _update,\n            lambda: H,\n        )\n\n    H = H + config.courant_number * curl_E(arrays.E) * arrays.inv_permeabilities\n\n    arrays = arrays.at[\"H\"].set(H)\n    return arrays\n</code></pre>"},{"location":"api/objects/","title":"Objects Package","text":"<p>This section documents the core simulation objects and their management in the package.</p>"},{"location":"api/objects/#contents","title":"Contents","text":"<ul> <li>Containers - Object and array containers for simulation management</li> <li>Base Classes - Core object classes and positioning constraints</li> <li>Materials - Material definitions and properties</li> <li>Initialization - Object placement and initialization</li> </ul>"},{"location":"api/objects/base/","title":"Base Classes","text":""},{"location":"api/objects/base/#core-classes","title":"Core Classes","text":"<p>Base class for all simulation objects with positioning and sizing capabilities.</p> <p>Utility for generating unique object identifiers.</p>"},{"location":"api/objects/base/#fdtdx.objects.object.SimulationObject","title":"<code>fdtdx.objects.object.SimulationObject</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code>, <code>ABC</code></p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>@extended_autoinit\nclass SimulationObject(ExtendedTreeClass, ABC):\n    partial_real_shape: PartialRealShape3D = frozen_field(default=UNDEFINED_SHAPE_3D)\n    partial_grid_shape: PartialGridShape3D = frozen_field(default=UNDEFINED_SHAPE_3D)\n    placement_order: int = frozen_field(default=0)\n    color: tuple[float, float, float] | None = frozen_field(default=None)  # RGB, interval[0, 1]\n    name: str = frozen_field(  # type: ignore\n        default=None,\n        on_setattr=[UniqueName()],\n    )\n    max_random_real_offsets: tuple[float, float, float] = frozen_field(default=(0, 0, 0))\n    max_random_grid_offsets: tuple[int, int, int] = frozen_field(default=(0, 0, 0))\n\n    _grid_slice_tuple: SliceTuple3D = frozen_private_field(\n        default=INVALID_SLICE_TUPLE_3D,\n    )\n    _config: SimulationConfig = frozen_private_field(default=DUMMY_SIMULATION_CONFIG)\n\n    @property\n    def grid_slice_tuple(self) -&gt; SliceTuple3D:\n        if self._grid_slice_tuple == INVALID_SLICE_TUPLE_3D:\n            raise Exception(f\"Object is not yet initialized: {self}\")\n        return self._grid_slice_tuple\n\n    @property\n    def grid_slice(self) -&gt; Slice3D:\n        tpl = ensure_slice_tuple(self._grid_slice_tuple)\n        if len(tpl) != 3:\n            raise Exception(f\"Invalid slice tuple, this should never happen: {tpl}\")\n        return tpl[0], tpl[1], tpl[2]\n\n    @property\n    def real_shape(self) -&gt; RealShape3D:\n        grid_shape = self.grid_shape\n        real_shape = (\n            grid_shape[0] * self._config.resolution,\n            grid_shape[1] * self._config.resolution,\n            grid_shape[2] * self._config.resolution,\n        )\n        return real_shape\n\n    @property\n    def grid_shape(self) -&gt; GridShape3D:\n        if self._grid_slice_tuple == INVALID_SLICE_TUPLE_3D:\n            raise Exception(\"Cannot compute shape on non-initialized object\")\n        return (\n            self._grid_slice_tuple[0][1] - self._grid_slice_tuple[0][0],\n            self._grid_slice_tuple[1][1] - self._grid_slice_tuple[1][0],\n            self._grid_slice_tuple[2][1] - self._grid_slice_tuple[2][0],\n        )\n\n    def place_on_grid(\n        self: Self,\n        grid_slice_tuple: SliceTuple3D,\n        config: SimulationConfig,\n        key: jax.Array,\n    ) -&gt; Self:\n        del key\n        if self._grid_slice_tuple != INVALID_SLICE_TUPLE_3D:\n            raise Exception(f\"Object is already compiled to grid: {self}\")\n        for axis in range(3):\n            s1, s2 = grid_slice_tuple[axis]\n            if s1 &lt; 0 or s2 &lt; 0 or s2 &lt;= s1:\n                raise Exception(f\"Invalid placement of object {self} at {grid_slice_tuple}\")\n        self = self.aset(\"_grid_slice_tuple\", grid_slice_tuple)\n        self = self.aset(\"_config\", config)\n\n        return self\n\n    @abc.abstractmethod\n    def get_inv_permittivity(\n        self,\n        prev_inv_permittivity: jax.Array,\n        params: dict[str, jax.Array] | None,\n    ) -&gt; tuple[jax.Array, dict]:  # permittivity and info dict\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def get_inv_permeability(\n        self,\n        prev_inv_permeability: jax.Array,\n        params: dict[str, jax.Array] | None,\n    ) -&gt; tuple[jax.Array, dict]:  # permeability and info dict\n        raise NotImplementedError()\n\n    def place_relative_to(\n        self,\n        other: \"SimulationObject\",\n        axes: tuple[int, ...] | int,\n        own_positions: tuple[float, ...] | float,\n        other_positions: tuple[float, ...] | float,\n        margins: tuple[float, ...] | float | None = None,\n        grid_margins: tuple[int, ...] | int | None = None,\n    ) -&gt; PositionConstraint:\n        \"\"\"Creates a PositionalConstraint between two objects. The constraint is defined by anchor points on\n        both objects, which are constrainted to be at the same position. Anchors are defined in relative coordinates,\n        i.e. a position of -1 is the left object boundary in the repective axis and a position of +1 the right boundary.\n\n        Args:\n            other: Another object in the simulation scene\n            axes: Eiter a single integer or a tuple describing the axes of the constraints\n            own_positions: The positions of the own anchor in the axes. Must have the same lengths as axes\n            other_positions: The positions of the other objects' anchor in the axes. Must have the same lengths as axes\n            margins: The margins between the anchors of both objects in meters. Must have the same lengths as axes. Defaults to no margin\n            grid_margins: The margins between the anchors of both objects in Yee-grid voxels. Must have the same lengths as axes. Defaults to no margin\n\n        Returns:\n            PositionConstraint: Positional constraint between this object and the other\n        \"\"\"\n        if isinstance(axes, int):\n            axes = tuple(\n                [\n                    axes,\n                ]\n            )\n        if isinstance(own_positions, int | float):\n            own_positions = tuple(\n                [\n                    float(own_positions),\n                ]\n            )\n        if isinstance(other_positions, int | float):\n            other_positions = tuple(\n                [\n                    float(other_positions),\n                ]\n            )\n        if isinstance(margins, int | float):\n            margins = tuple(\n                [\n                    float(margins),\n                ]\n            )\n        if isinstance(grid_margins, int):\n            grid_margins = tuple(\n                [\n                    grid_margins,\n                ]\n            )\n        if margins is None:\n            margins = tuple([0 for _ in axes])\n        if grid_margins is None:\n            grid_margins = tuple([0 for _ in axes])\n        if (\n            len(axes) != len(own_positions)\n            or len(axes) != len(other_positions)\n            or len(axes) != len(margins)\n            or len(axes) != len(grid_margins)\n        ):\n            raise Exception(\"All inputs should have same lengths\")\n        constraint = PositionConstraint(\n            axes=axes,\n            other_object=other,\n            object=self,\n            other_object_positions=other_positions,\n            object_positions=own_positions,\n            margins=margins,\n            grid_margins=grid_margins,\n        )\n        return constraint\n\n    def size_relative_to(\n        self,\n        other: \"SimulationObject\",\n        axes: tuple[int, ...] | int,\n        other_axes: tuple[int, ...] | int | None = None,\n        proportions: tuple[float, ...] | float | None = None,\n        offsets: tuple[float, ...] | float | None = None,\n        grid_offsets: tuple[int, ...] | int | None = None,\n    ) -&gt; SizeConstraint:\n        \"\"\"Creates a SizeConstraint between two objects. The constraint defines the size of this object relative\n        to another object, allowing for proportional scaling and offsets in specified axes.\n\n        Args:\n            other: Another object in the simulation scene\n            axes: Either a single integer or a tuple describing which axes of this object to constrain\n            other_axes: Either a single integer or a tuple describing which axes of the other object to reference.\n                If None, uses the same axes as specified in 'axes'\n            proportions: Scale factors to apply to the other object's dimensions. Must have same length as axes.\n                If None, defaults to 1.0 (same size)\n            offsets: Additional size offsets in meters to apply after scaling. Must have same length as axes.\n                If None, defaults to 0\n            grid_offsets: Additional size offsets in Yee-grid voxels to apply after scaling. Must have same length as axes.\n                If None, defaults to 0\n\n        Returns:\n            SizeConstraint: Size constraint between this object and the other\n        \"\"\"\n        if isinstance(axes, int):\n            axes = tuple(\n                [\n                    axes,\n                ]\n            )\n        if isinstance(other_axes, int):\n            other_axes = tuple(\n                [\n                    other_axes,\n                ]\n            )\n        if isinstance(proportions, int | float):\n            proportions = tuple(\n                [\n                    float(proportions),\n                ]\n            )\n        if isinstance(offsets, int | float):\n            offsets = tuple(\n                [\n                    float(offsets),\n                ]\n            )\n        if isinstance(grid_offsets, int):\n            grid_offsets = tuple(\n                [\n                    grid_offsets,\n                ]\n            )\n        if offsets is None:\n            offsets = tuple([0 for _ in axes])\n        if grid_offsets is None:\n            grid_offsets = tuple([0 for _ in axes])\n        if proportions is None:\n            proportions = tuple([1.0 for _ in axes])\n        if other_axes is None:\n            other_axes = tuple([a for a in axes])\n        if len(axes) != len(proportions) or len(axes) != len(offsets) or len(axes) != len(grid_offsets):\n            raise Exception(\"All inputs should have same lengths\")\n        constraint = SizeConstraint(\n            other_object=other,\n            object=self,\n            axes=axes,\n            other_axes=other_axes,\n            proportions=proportions,\n            offsets=offsets,\n            grid_offsets=grid_offsets,\n        )\n        return constraint\n\n    def same_size(\n        self,\n        other: \"SimulationObject\",\n        axes: tuple[int, ...] | int = (0, 1, 2),\n        offsets: tuple[float, ...] | float | None = None,\n        grid_offsets: tuple[int, ...] | int | None = None,\n    ) -&gt; SizeConstraint:\n        \"\"\"Creates a SizeConstraint that makes this object the same size as another object along specified axes.\n        This is a convenience wrapper around size_relative_to() with proportions set to 1.0.\n\n        Args:\n            other: Another object in the simulation scene\n            axes: Either a single integer or a tuple describing which axes should have the same size.\n                Defaults to all axes (0, 1, 2)\n            offsets: Additional size offsets in meters to apply. Must have same length as axes.\n                If None, defaults to 0\n            grid_offsets: Additional size offsets in Yee-grid voxels to apply. Must have same length as axes.\n                If None, defaults to 0\n\n        Returns:\n            SizeConstraint: Size constraint ensuring equal sizes between objects\n        \"\"\"\n        if isinstance(axes, int):\n            axes = tuple(\n                [\n                    axes,\n                ]\n            )\n        proportions = tuple([1 for _ in axes])\n        constraint = self.size_relative_to(\n            other=other,\n            axes=axes,\n            proportions=proportions,\n            offsets=offsets,\n            grid_offsets=grid_offsets,\n        )\n        return constraint\n\n    def place_at_center(\n        self,\n        other: \"SimulationObject\",\n        axes: tuple[int, ...] | int = (0, 1, 2),\n        own_positions: tuple[float, ...] | float | None = None,\n        other_positions: tuple[float, ...] | float | None = None,\n        margins: tuple[float, ...] | float | None = None,\n        grid_margins: tuple[int, ...] | int | None = None,\n    ) -&gt; PositionConstraint:\n        \"\"\"Creates a PositionConstraint that centers this object relative to another object along specified axes.\n        This is a convenience wrapper around place_relative_to() with default positions at the center (0).\n\n        Args:\n            other: Another object in the simulation scene\n            axes: Either a single integer or a tuple describing which axes to center on.\n                Defaults to all axes (0, 1, 2)\n            own_positions: Relative positions on this object (-1 to 1). If None, defaults to center (0)\n            other_positions: Relative positions on other object (-1 to 1). If None, defaults to center (0)\n            margins: Additional margins in meters between objects. Must have same length as axes.\n                If None, defaults to 0\n            grid_margins: Additional margins in Yee-grid voxels between objects. Must have same length as axes.\n                If None, defaults to 0\n\n        Returns:\n            PositionConstraint: Position constraint centering objects relative to each other\n        \"\"\"\n        if isinstance(axes, int):\n            axes = tuple(\n                [\n                    axes,\n                ]\n            )\n        if isinstance(own_positions, int | float):\n            own_positions = tuple(\n                [\n                    float(own_positions),\n                ]\n            )\n        if isinstance(other_positions, int | float):\n            other_positions = tuple(\n                [\n                    float(other_positions),\n                ]\n            )\n        if own_positions is None:\n            own_positions = tuple([0 for _ in axes])\n        if other_positions is None:\n            other_positions = tuple([0 for _ in axes])\n        constraint = self.place_relative_to(\n            other=other,\n            axes=axes,\n            own_positions=own_positions,\n            other_positions=other_positions,\n            margins=margins,\n            grid_margins=grid_margins,\n        )\n        return constraint\n\n    def same_position_and_size(\n        self,\n        other: \"SimulationObject\",\n        axes: tuple[int, ...] | int = (0, 1, 2),\n    ) -&gt; tuple[PositionConstraint, SizeConstraint]:\n        \"\"\"Creates both position and size constraints to make this object match another object's position and size.\n        This is a convenience wrapper combining place_at_center() and same_size().\n\n        Args:\n            other: Another object in the simulation scene\n            axes: Either a single integer or a tuple describing which axes to match.\n                Defaults to all axes (0, 1, 2)\n\n        Returns:\n            tuple[PositionConstraint, SizeConstraint]: Position and size constraints for matching objects\n        \"\"\"\n        size_constraint = self.same_size(\n            other=other,\n            axes=axes,\n        )\n        pos_constraint = self.place_at_center(\n            other=other,\n            axes=axes,\n        )\n        return pos_constraint, size_constraint\n\n    def face_to_face_positive_direction(\n        self,\n        other: \"SimulationObject\",\n        axes: tuple[int, ...] | int,\n        margins: tuple[float, ...] | float | None = None,\n        grid_margins: tuple[int, ...] | int | None = None,\n    ) -&gt; PositionConstraint:\n        \"\"\"Creates a PositionConstraint that places this object facing another object in the positive direction\n        of specified axes. The objects will touch at their facing boundaries unless margins are specified.\n\n        Args:\n            other: Another object in the simulation scene\n            axes: Either a single integer or a tuple describing which axes to align on\n            margins: Additional margins in meters between the facing surfaces. Must have same length as axes.\n                If None, defaults to 0\n            grid_margins: Additional margins in Yee-grid voxels between the facing surfaces.\n                Must have same length as axes. If None, defaults to 0\n\n        Returns:\n            PositionConstraint: Position constraint aligning objects face-to-face in positive direction\n        \"\"\"\n        if isinstance(axes, int):\n            axes = tuple(\n                [\n                    axes,\n                ]\n            )\n        own_positions = tuple([-1 for _ in axes])\n        other_positions = tuple([1 for _ in axes])\n        constraint = self.place_relative_to(\n            other=other,\n            axes=axes,\n            own_positions=own_positions,\n            other_positions=other_positions,\n            margins=margins,\n            grid_margins=grid_margins,\n        )\n        return constraint\n\n    def face_to_face_negative_direction(\n        self,\n        other: \"SimulationObject\",\n        axes: tuple[int, ...] | int,\n        margins: tuple[float, ...] | float | None = None,\n        grid_margins: tuple[int, ...] | int | None = None,\n    ) -&gt; PositionConstraint:\n        \"\"\"Creates a PositionConstraint that places this object facing another object in the negative direction\n        of specified axes. The objects will touch at their facing boundaries unless margins are specified.\n\n        Args:\n            other: Another object in the simulation scene\n            axes: Either a single integer or a tuple describing which axes to align on\n            margins: Additional margins in meters between the facing surfaces. Must have same length as axes.\n                If None, defaults to 0\n            grid_margins: Additional margins in Yee-grid voxels between the facing surfaces.\n                Must have same length as axes. If None, defaults to 0\n\n        Returns:\n            PositionConstraint: Position constraint aligning objects face-to-face in negative direction\n        \"\"\"\n        if isinstance(axes, int):\n            axes = tuple(\n                [\n                    axes,\n                ]\n            )\n        own_positions = tuple([1 for _ in axes])\n        other_positions = tuple([-1 for _ in axes])\n        constraint = self.place_relative_to(\n            other=other,\n            axes=axes,\n            own_positions=own_positions,\n            other_positions=other_positions,\n            margins=margins,\n            grid_margins=grid_margins,\n        )\n        return constraint\n\n    def place_above(\n        self,\n        other: \"SimulationObject\",\n        margins: tuple[float, ...] | float | None = None,\n        grid_margins: tuple[int, ...] | int | None = None,\n    ) -&gt; PositionConstraint:\n        \"\"\"Creates a PositionConstraint that places this object above another object along the z-axis.\n        This is a convenience wrapper around face_to_face_positive_direction() for axis 2 (z-axis).\n\n        Args:\n            other: Another object in the simulation scene\n            margins: Additional vertical margins in meters between objects. If None, defaults to 0\n            grid_margins: Additional vertical margins in Yee-grid voxels between objects.\n                If None, defaults to 0\n\n        Returns:\n            PositionConstraint: Position constraint placing this object above the other\n        \"\"\"\n        constraint = self.face_to_face_positive_direction(\n            other=other,\n            axes=(2,),\n            margins=margins,\n            grid_margins=grid_margins,\n        )\n        return constraint\n\n    def place_below(\n        self,\n        other: \"SimulationObject\",\n        margins: tuple[float, ...] | float | None = None,\n        grid_margins: tuple[int, ...] | int | None = None,\n    ) -&gt; PositionConstraint:\n        \"\"\"Creates a PositionConstraint that places this object below another object along the z-axis.\n        This is a convenience wrapper around face_to_face_negative_direction() for axis 2 (z-axis).\n\n        Args:\n            other: Another object in the simulation scene\n            margins: Additional vertical margins in meters between objects. If None, defaults to 0\n            grid_margins: Additional vertical margins in Yee-grid voxels between objects.\n                If None, defaults to 0\n\n        Returns:\n            PositionConstraint: Position constraint placing this object below the other\n        \"\"\"\n        constraint = self.face_to_face_negative_direction(\n            other=other,\n            axes=(2,),\n            margins=margins,\n            grid_margins=grid_margins,\n        )\n        return constraint\n\n    def set_grid_coordinates(\n        self,\n        axes: tuple[int, ...] | int,\n        sides: tuple[Literal[\"+\", \"-\"], ...] | Literal[\"+\", \"-\"],\n        coordinates: tuple[int, ...] | int,\n    ) -&gt; GridCoordinateConstraint:\n        \"\"\"Creates a GridCoordinateConstraint that forces specific sides of this object to align with\n        given grid coordinates. Used for precise positioning in the discretized simulation space.\n\n        Args:\n            axes: Either a single integer or a tuple describing which axes to constrain\n            sides: Either a single string or a tuple of strings ('+' or '-') indicating which side\n                of each axis to constrain. Must have same length as axes\n            coordinates: Either a single integer or a tuple of integers specifying the grid coordinates\n                to align with. Must have same length as axes\n\n        Returns:\n            GridCoordinateConstraint: Constraint forcing alignment with specific grid coordinates\n        \"\"\"\n        if isinstance(axes, int):\n            axes = tuple(\n                [\n                    axes,\n                ]\n            )\n        if isinstance(sides, str):\n            sides = (sides,)\n        if isinstance(coordinates, int):\n            coordinates = tuple(\n                [\n                    coordinates,\n                ]\n            )\n        if len(axes) != len(sides) or len(axes) != len(coordinates):\n            raise Exception(\"All inputs need to have the same lengths!\")\n        return GridCoordinateConstraint(\n            object=self,\n            axes=axes,\n            sides=sides,\n            coordinates=coordinates,\n        )\n\n    def set_real_coordinates(\n        self,\n        axes: tuple[int, ...] | int,\n        sides: tuple[Literal[\"+\", \"-\"], ...] | Literal[\"+\", \"-\"],\n        coordinates: tuple[float, ...] | float,\n    ) -&gt; RealCoordinateConstraint:\n        \"\"\"Creates a RealCoordinateConstraint that forces specific sides of this object to align with\n        given real-space coordinates. Used for precise positioning in physical units.\n\n        Args:\n            axes: Either a single integer or a tuple describing which axes to constrain\n            sides: Either a single string or a tuple of strings ('+' or '-') indicating which side\n                of each axis to constrain. Must have same length as axes\n            coordinates: Either a single float or a tuple of floats specifying the real-space coordinates\n                in meters to align with. Must have same length as axes\n\n        Returns:\n            RealCoordinateConstraint: Constraint forcing alignment with specific real-space coordinates\n        \"\"\"\n        if isinstance(axes, int):\n            axes = tuple(\n                [\n                    axes,\n                ]\n            )\n        if isinstance(sides, str):\n            sides = (sides,)\n        if isinstance(coordinates, int | float):\n            coordinates = tuple(\n                [\n                    float(coordinates),\n                ]\n            )\n        if len(axes) != len(sides) or len(axes) != len(coordinates):\n            raise Exception(\"All inputs need to have the same lengths!\")\n        return RealCoordinateConstraint(\n            object=self,\n            axes=axes,\n            sides=sides,\n            coordinates=coordinates,\n        )\n\n    def extend_to(\n        self,\n        other: Optional[\"SimulationObject\"],\n        axis: int,\n        direction: Literal[\"+\", \"-\"],\n        other_position: float | None = None,\n        offset: float = 0,\n        grid_offset: int = 0,\n    ) -&gt; SizeExtensionConstraint:\n        \"\"\"Creates a SizeExtensionConstraint that extends this object along a specified axis until it\n        reaches another object or the simulation boundary. The extension can be in either positive or\n        negative direction.\n\n        Args:\n            other: Target object to extend to, or None to extend to simulation boundary\n            axis: Which axis to extend along (0, 1, or 2)\n            direction: Direction to extend in ('+' or '-')\n            other_position: Relative position on target object (-1 to 1) to extend to.\n                If None, defaults to the corresponding side (-1 for '+' direction, 1 for '-' direction)\n            offset: Additional offset in meters to apply after extension. Ignored when extending to\n                simulation boundary\n            grid_offset: Additional offset in Yee-grid voxels to apply after extension. Ignored when\n                extending to simulation boundary\n\n        Returns:\n            SizeExtensionConstraint: Constraint defining how the object extends\n        \"\"\"\n        # default: extend to corresponding side\n        if other_position is None:\n            other_position = -1 if direction == \"+\" else 1\n        if other is None:\n            if offset != 0 or grid_offset != 0:\n                raise Exception(\"Cannot use offset when extending object to infinity\")\n        return SizeExtensionConstraint(\n            object=self,\n            other_object=other,\n            axis=axis,\n            direction=direction,\n            other_position=other_position,\n            offset=offset,\n            grid_offset=grid_offset,\n        )\n\n    def check_overlap(\n        self,\n        other: \"SimulationObject\",\n    ) -&gt; bool:\n        for axis in range(3):\n            s_start, s_end = self._grid_slice_tuple[axis]\n            o_start, o_end = other._grid_slice_tuple[axis]\n            if o_start &lt;= s_start &lt;= o_end:\n                return True\n            if o_start &lt;= s_end &lt;= o_end:\n                return True\n        return False\n\n    def __eq__(\n        self: Self,\n        other: \"SimulationObject\",\n    ) -&gt; bool:\n        return self.name == other.name\n\n    def __hash__(self) -&gt; int:\n        return hash(self.name)\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.SimulationObject.extend_to","title":"<code>extend_to(other, axis, direction, other_position=None, offset=0, grid_offset=0)</code>","text":"<p>Creates a SizeExtensionConstraint that extends this object along a specified axis until it reaches another object or the simulation boundary. The extension can be in either positive or negative direction.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[SimulationObject]</code> <p>Target object to extend to, or None to extend to simulation boundary</p> required <code>axis</code> <code>int</code> <p>Which axis to extend along (0, 1, or 2)</p> required <code>direction</code> <code>Literal['+', '-']</code> <p>Direction to extend in ('+' or '-')</p> required <code>other_position</code> <code>float | None</code> <p>Relative position on target object (-1 to 1) to extend to. If None, defaults to the corresponding side (-1 for '+' direction, 1 for '-' direction)</p> <code>None</code> <code>offset</code> <code>float</code> <p>Additional offset in meters to apply after extension. Ignored when extending to simulation boundary</p> <code>0</code> <code>grid_offset</code> <code>int</code> <p>Additional offset in Yee-grid voxels to apply after extension. Ignored when extending to simulation boundary</p> <code>0</code> <p>Returns:</p> Name Type Description <code>SizeExtensionConstraint</code> <code>SizeExtensionConstraint</code> <p>Constraint defining how the object extends</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def extend_to(\n    self,\n    other: Optional[\"SimulationObject\"],\n    axis: int,\n    direction: Literal[\"+\", \"-\"],\n    other_position: float | None = None,\n    offset: float = 0,\n    grid_offset: int = 0,\n) -&gt; SizeExtensionConstraint:\n    \"\"\"Creates a SizeExtensionConstraint that extends this object along a specified axis until it\n    reaches another object or the simulation boundary. The extension can be in either positive or\n    negative direction.\n\n    Args:\n        other: Target object to extend to, or None to extend to simulation boundary\n        axis: Which axis to extend along (0, 1, or 2)\n        direction: Direction to extend in ('+' or '-')\n        other_position: Relative position on target object (-1 to 1) to extend to.\n            If None, defaults to the corresponding side (-1 for '+' direction, 1 for '-' direction)\n        offset: Additional offset in meters to apply after extension. Ignored when extending to\n            simulation boundary\n        grid_offset: Additional offset in Yee-grid voxels to apply after extension. Ignored when\n            extending to simulation boundary\n\n    Returns:\n        SizeExtensionConstraint: Constraint defining how the object extends\n    \"\"\"\n    # default: extend to corresponding side\n    if other_position is None:\n        other_position = -1 if direction == \"+\" else 1\n    if other is None:\n        if offset != 0 or grid_offset != 0:\n            raise Exception(\"Cannot use offset when extending object to infinity\")\n    return SizeExtensionConstraint(\n        object=self,\n        other_object=other,\n        axis=axis,\n        direction=direction,\n        other_position=other_position,\n        offset=offset,\n        grid_offset=grid_offset,\n    )\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.SimulationObject.face_to_face_negative_direction","title":"<code>face_to_face_negative_direction(other, axes, margins=None, grid_margins=None)</code>","text":"<p>Creates a PositionConstraint that places this object facing another object in the negative direction of specified axes. The objects will touch at their facing boundaries unless margins are specified.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes to align on</p> required <code>margins</code> <code>tuple[float, ...] | float | None</code> <p>Additional margins in meters between the facing surfaces. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <code>grid_margins</code> <code>tuple[int, ...] | int | None</code> <p>Additional margins in Yee-grid voxels between the facing surfaces. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PositionConstraint</code> <code>PositionConstraint</code> <p>Position constraint aligning objects face-to-face in negative direction</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def face_to_face_negative_direction(\n    self,\n    other: \"SimulationObject\",\n    axes: tuple[int, ...] | int,\n    margins: tuple[float, ...] | float | None = None,\n    grid_margins: tuple[int, ...] | int | None = None,\n) -&gt; PositionConstraint:\n    \"\"\"Creates a PositionConstraint that places this object facing another object in the negative direction\n    of specified axes. The objects will touch at their facing boundaries unless margins are specified.\n\n    Args:\n        other: Another object in the simulation scene\n        axes: Either a single integer or a tuple describing which axes to align on\n        margins: Additional margins in meters between the facing surfaces. Must have same length as axes.\n            If None, defaults to 0\n        grid_margins: Additional margins in Yee-grid voxels between the facing surfaces.\n            Must have same length as axes. If None, defaults to 0\n\n    Returns:\n        PositionConstraint: Position constraint aligning objects face-to-face in negative direction\n    \"\"\"\n    if isinstance(axes, int):\n        axes = tuple(\n            [\n                axes,\n            ]\n        )\n    own_positions = tuple([1 for _ in axes])\n    other_positions = tuple([-1 for _ in axes])\n    constraint = self.place_relative_to(\n        other=other,\n        axes=axes,\n        own_positions=own_positions,\n        other_positions=other_positions,\n        margins=margins,\n        grid_margins=grid_margins,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.SimulationObject.face_to_face_positive_direction","title":"<code>face_to_face_positive_direction(other, axes, margins=None, grid_margins=None)</code>","text":"<p>Creates a PositionConstraint that places this object facing another object in the positive direction of specified axes. The objects will touch at their facing boundaries unless margins are specified.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes to align on</p> required <code>margins</code> <code>tuple[float, ...] | float | None</code> <p>Additional margins in meters between the facing surfaces. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <code>grid_margins</code> <code>tuple[int, ...] | int | None</code> <p>Additional margins in Yee-grid voxels between the facing surfaces. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PositionConstraint</code> <code>PositionConstraint</code> <p>Position constraint aligning objects face-to-face in positive direction</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def face_to_face_positive_direction(\n    self,\n    other: \"SimulationObject\",\n    axes: tuple[int, ...] | int,\n    margins: tuple[float, ...] | float | None = None,\n    grid_margins: tuple[int, ...] | int | None = None,\n) -&gt; PositionConstraint:\n    \"\"\"Creates a PositionConstraint that places this object facing another object in the positive direction\n    of specified axes. The objects will touch at their facing boundaries unless margins are specified.\n\n    Args:\n        other: Another object in the simulation scene\n        axes: Either a single integer or a tuple describing which axes to align on\n        margins: Additional margins in meters between the facing surfaces. Must have same length as axes.\n            If None, defaults to 0\n        grid_margins: Additional margins in Yee-grid voxels between the facing surfaces.\n            Must have same length as axes. If None, defaults to 0\n\n    Returns:\n        PositionConstraint: Position constraint aligning objects face-to-face in positive direction\n    \"\"\"\n    if isinstance(axes, int):\n        axes = tuple(\n            [\n                axes,\n            ]\n        )\n    own_positions = tuple([-1 for _ in axes])\n    other_positions = tuple([1 for _ in axes])\n    constraint = self.place_relative_to(\n        other=other,\n        axes=axes,\n        own_positions=own_positions,\n        other_positions=other_positions,\n        margins=margins,\n        grid_margins=grid_margins,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.SimulationObject.place_above","title":"<code>place_above(other, margins=None, grid_margins=None)</code>","text":"<p>Creates a PositionConstraint that places this object above another object along the z-axis. This is a convenience wrapper around face_to_face_positive_direction() for axis 2 (z-axis).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>margins</code> <code>tuple[float, ...] | float | None</code> <p>Additional vertical margins in meters between objects. If None, defaults to 0</p> <code>None</code> <code>grid_margins</code> <code>tuple[int, ...] | int | None</code> <p>Additional vertical margins in Yee-grid voxels between objects. If None, defaults to 0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PositionConstraint</code> <code>PositionConstraint</code> <p>Position constraint placing this object above the other</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def place_above(\n    self,\n    other: \"SimulationObject\",\n    margins: tuple[float, ...] | float | None = None,\n    grid_margins: tuple[int, ...] | int | None = None,\n) -&gt; PositionConstraint:\n    \"\"\"Creates a PositionConstraint that places this object above another object along the z-axis.\n    This is a convenience wrapper around face_to_face_positive_direction() for axis 2 (z-axis).\n\n    Args:\n        other: Another object in the simulation scene\n        margins: Additional vertical margins in meters between objects. If None, defaults to 0\n        grid_margins: Additional vertical margins in Yee-grid voxels between objects.\n            If None, defaults to 0\n\n    Returns:\n        PositionConstraint: Position constraint placing this object above the other\n    \"\"\"\n    constraint = self.face_to_face_positive_direction(\n        other=other,\n        axes=(2,),\n        margins=margins,\n        grid_margins=grid_margins,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.SimulationObject.place_at_center","title":"<code>place_at_center(other, axes=(0, 1, 2), own_positions=None, other_positions=None, margins=None, grid_margins=None)</code>","text":"<p>Creates a PositionConstraint that centers this object relative to another object along specified axes. This is a convenience wrapper around place_relative_to() with default positions at the center (0).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes to center on. Defaults to all axes (0, 1, 2)</p> <code>(0, 1, 2)</code> <code>own_positions</code> <code>tuple[float, ...] | float | None</code> <p>Relative positions on this object (-1 to 1). If None, defaults to center (0)</p> <code>None</code> <code>other_positions</code> <code>tuple[float, ...] | float | None</code> <p>Relative positions on other object (-1 to 1). If None, defaults to center (0)</p> <code>None</code> <code>margins</code> <code>tuple[float, ...] | float | None</code> <p>Additional margins in meters between objects. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <code>grid_margins</code> <code>tuple[int, ...] | int | None</code> <p>Additional margins in Yee-grid voxels between objects. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PositionConstraint</code> <code>PositionConstraint</code> <p>Position constraint centering objects relative to each other</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def place_at_center(\n    self,\n    other: \"SimulationObject\",\n    axes: tuple[int, ...] | int = (0, 1, 2),\n    own_positions: tuple[float, ...] | float | None = None,\n    other_positions: tuple[float, ...] | float | None = None,\n    margins: tuple[float, ...] | float | None = None,\n    grid_margins: tuple[int, ...] | int | None = None,\n) -&gt; PositionConstraint:\n    \"\"\"Creates a PositionConstraint that centers this object relative to another object along specified axes.\n    This is a convenience wrapper around place_relative_to() with default positions at the center (0).\n\n    Args:\n        other: Another object in the simulation scene\n        axes: Either a single integer or a tuple describing which axes to center on.\n            Defaults to all axes (0, 1, 2)\n        own_positions: Relative positions on this object (-1 to 1). If None, defaults to center (0)\n        other_positions: Relative positions on other object (-1 to 1). If None, defaults to center (0)\n        margins: Additional margins in meters between objects. Must have same length as axes.\n            If None, defaults to 0\n        grid_margins: Additional margins in Yee-grid voxels between objects. Must have same length as axes.\n            If None, defaults to 0\n\n    Returns:\n        PositionConstraint: Position constraint centering objects relative to each other\n    \"\"\"\n    if isinstance(axes, int):\n        axes = tuple(\n            [\n                axes,\n            ]\n        )\n    if isinstance(own_positions, int | float):\n        own_positions = tuple(\n            [\n                float(own_positions),\n            ]\n        )\n    if isinstance(other_positions, int | float):\n        other_positions = tuple(\n            [\n                float(other_positions),\n            ]\n        )\n    if own_positions is None:\n        own_positions = tuple([0 for _ in axes])\n    if other_positions is None:\n        other_positions = tuple([0 for _ in axes])\n    constraint = self.place_relative_to(\n        other=other,\n        axes=axes,\n        own_positions=own_positions,\n        other_positions=other_positions,\n        margins=margins,\n        grid_margins=grid_margins,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.SimulationObject.place_below","title":"<code>place_below(other, margins=None, grid_margins=None)</code>","text":"<p>Creates a PositionConstraint that places this object below another object along the z-axis. This is a convenience wrapper around face_to_face_negative_direction() for axis 2 (z-axis).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>margins</code> <code>tuple[float, ...] | float | None</code> <p>Additional vertical margins in meters between objects. If None, defaults to 0</p> <code>None</code> <code>grid_margins</code> <code>tuple[int, ...] | int | None</code> <p>Additional vertical margins in Yee-grid voxels between objects. If None, defaults to 0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PositionConstraint</code> <code>PositionConstraint</code> <p>Position constraint placing this object below the other</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def place_below(\n    self,\n    other: \"SimulationObject\",\n    margins: tuple[float, ...] | float | None = None,\n    grid_margins: tuple[int, ...] | int | None = None,\n) -&gt; PositionConstraint:\n    \"\"\"Creates a PositionConstraint that places this object below another object along the z-axis.\n    This is a convenience wrapper around face_to_face_negative_direction() for axis 2 (z-axis).\n\n    Args:\n        other: Another object in the simulation scene\n        margins: Additional vertical margins in meters between objects. If None, defaults to 0\n        grid_margins: Additional vertical margins in Yee-grid voxels between objects.\n            If None, defaults to 0\n\n    Returns:\n        PositionConstraint: Position constraint placing this object below the other\n    \"\"\"\n    constraint = self.face_to_face_negative_direction(\n        other=other,\n        axes=(2,),\n        margins=margins,\n        grid_margins=grid_margins,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.SimulationObject.place_relative_to","title":"<code>place_relative_to(other, axes, own_positions, other_positions, margins=None, grid_margins=None)</code>","text":"<p>Creates a PositionalConstraint between two objects. The constraint is defined by anchor points on both objects, which are constrainted to be at the same position. Anchors are defined in relative coordinates, i.e. a position of -1 is the left object boundary in the repective axis and a position of +1 the right boundary.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>axes</code> <code>tuple[int, ...] | int</code> <p>Eiter a single integer or a tuple describing the axes of the constraints</p> required <code>own_positions</code> <code>tuple[float, ...] | float</code> <p>The positions of the own anchor in the axes. Must have the same lengths as axes</p> required <code>other_positions</code> <code>tuple[float, ...] | float</code> <p>The positions of the other objects' anchor in the axes. Must have the same lengths as axes</p> required <code>margins</code> <code>tuple[float, ...] | float | None</code> <p>The margins between the anchors of both objects in meters. Must have the same lengths as axes. Defaults to no margin</p> <code>None</code> <code>grid_margins</code> <code>tuple[int, ...] | int | None</code> <p>The margins between the anchors of both objects in Yee-grid voxels. Must have the same lengths as axes. Defaults to no margin</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PositionConstraint</code> <code>PositionConstraint</code> <p>Positional constraint between this object and the other</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def place_relative_to(\n    self,\n    other: \"SimulationObject\",\n    axes: tuple[int, ...] | int,\n    own_positions: tuple[float, ...] | float,\n    other_positions: tuple[float, ...] | float,\n    margins: tuple[float, ...] | float | None = None,\n    grid_margins: tuple[int, ...] | int | None = None,\n) -&gt; PositionConstraint:\n    \"\"\"Creates a PositionalConstraint between two objects. The constraint is defined by anchor points on\n    both objects, which are constrainted to be at the same position. Anchors are defined in relative coordinates,\n    i.e. a position of -1 is the left object boundary in the repective axis and a position of +1 the right boundary.\n\n    Args:\n        other: Another object in the simulation scene\n        axes: Eiter a single integer or a tuple describing the axes of the constraints\n        own_positions: The positions of the own anchor in the axes. Must have the same lengths as axes\n        other_positions: The positions of the other objects' anchor in the axes. Must have the same lengths as axes\n        margins: The margins between the anchors of both objects in meters. Must have the same lengths as axes. Defaults to no margin\n        grid_margins: The margins between the anchors of both objects in Yee-grid voxels. Must have the same lengths as axes. Defaults to no margin\n\n    Returns:\n        PositionConstraint: Positional constraint between this object and the other\n    \"\"\"\n    if isinstance(axes, int):\n        axes = tuple(\n            [\n                axes,\n            ]\n        )\n    if isinstance(own_positions, int | float):\n        own_positions = tuple(\n            [\n                float(own_positions),\n            ]\n        )\n    if isinstance(other_positions, int | float):\n        other_positions = tuple(\n            [\n                float(other_positions),\n            ]\n        )\n    if isinstance(margins, int | float):\n        margins = tuple(\n            [\n                float(margins),\n            ]\n        )\n    if isinstance(grid_margins, int):\n        grid_margins = tuple(\n            [\n                grid_margins,\n            ]\n        )\n    if margins is None:\n        margins = tuple([0 for _ in axes])\n    if grid_margins is None:\n        grid_margins = tuple([0 for _ in axes])\n    if (\n        len(axes) != len(own_positions)\n        or len(axes) != len(other_positions)\n        or len(axes) != len(margins)\n        or len(axes) != len(grid_margins)\n    ):\n        raise Exception(\"All inputs should have same lengths\")\n    constraint = PositionConstraint(\n        axes=axes,\n        other_object=other,\n        object=self,\n        other_object_positions=other_positions,\n        object_positions=own_positions,\n        margins=margins,\n        grid_margins=grid_margins,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.SimulationObject.same_position_and_size","title":"<code>same_position_and_size(other, axes=(0, 1, 2))</code>","text":"<p>Creates both position and size constraints to make this object match another object's position and size. This is a convenience wrapper combining place_at_center() and same_size().</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes to match. Defaults to all axes (0, 1, 2)</p> <code>(0, 1, 2)</code> <p>Returns:</p> Type Description <code>tuple[PositionConstraint, SizeConstraint]</code> <p>tuple[PositionConstraint, SizeConstraint]: Position and size constraints for matching objects</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def same_position_and_size(\n    self,\n    other: \"SimulationObject\",\n    axes: tuple[int, ...] | int = (0, 1, 2),\n) -&gt; tuple[PositionConstraint, SizeConstraint]:\n    \"\"\"Creates both position and size constraints to make this object match another object's position and size.\n    This is a convenience wrapper combining place_at_center() and same_size().\n\n    Args:\n        other: Another object in the simulation scene\n        axes: Either a single integer or a tuple describing which axes to match.\n            Defaults to all axes (0, 1, 2)\n\n    Returns:\n        tuple[PositionConstraint, SizeConstraint]: Position and size constraints for matching objects\n    \"\"\"\n    size_constraint = self.same_size(\n        other=other,\n        axes=axes,\n    )\n    pos_constraint = self.place_at_center(\n        other=other,\n        axes=axes,\n    )\n    return pos_constraint, size_constraint\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.SimulationObject.same_size","title":"<code>same_size(other, axes=(0, 1, 2), offsets=None, grid_offsets=None)</code>","text":"<p>Creates a SizeConstraint that makes this object the same size as another object along specified axes. This is a convenience wrapper around size_relative_to() with proportions set to 1.0.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes should have the same size. Defaults to all axes (0, 1, 2)</p> <code>(0, 1, 2)</code> <code>offsets</code> <code>tuple[float, ...] | float | None</code> <p>Additional size offsets in meters to apply. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <code>grid_offsets</code> <code>tuple[int, ...] | int | None</code> <p>Additional size offsets in Yee-grid voxels to apply. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SizeConstraint</code> <code>SizeConstraint</code> <p>Size constraint ensuring equal sizes between objects</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def same_size(\n    self,\n    other: \"SimulationObject\",\n    axes: tuple[int, ...] | int = (0, 1, 2),\n    offsets: tuple[float, ...] | float | None = None,\n    grid_offsets: tuple[int, ...] | int | None = None,\n) -&gt; SizeConstraint:\n    \"\"\"Creates a SizeConstraint that makes this object the same size as another object along specified axes.\n    This is a convenience wrapper around size_relative_to() with proportions set to 1.0.\n\n    Args:\n        other: Another object in the simulation scene\n        axes: Either a single integer or a tuple describing which axes should have the same size.\n            Defaults to all axes (0, 1, 2)\n        offsets: Additional size offsets in meters to apply. Must have same length as axes.\n            If None, defaults to 0\n        grid_offsets: Additional size offsets in Yee-grid voxels to apply. Must have same length as axes.\n            If None, defaults to 0\n\n    Returns:\n        SizeConstraint: Size constraint ensuring equal sizes between objects\n    \"\"\"\n    if isinstance(axes, int):\n        axes = tuple(\n            [\n                axes,\n            ]\n        )\n    proportions = tuple([1 for _ in axes])\n    constraint = self.size_relative_to(\n        other=other,\n        axes=axes,\n        proportions=proportions,\n        offsets=offsets,\n        grid_offsets=grid_offsets,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.SimulationObject.set_grid_coordinates","title":"<code>set_grid_coordinates(axes, sides, coordinates)</code>","text":"<p>Creates a GridCoordinateConstraint that forces specific sides of this object to align with given grid coordinates. Used for precise positioning in the discretized simulation space.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes to constrain</p> required <code>sides</code> <code>tuple[Literal['+', '-'], ...] | Literal['+', '-']</code> <p>Either a single string or a tuple of strings ('+' or '-') indicating which side of each axis to constrain. Must have same length as axes</p> required <code>coordinates</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple of integers specifying the grid coordinates to align with. Must have same length as axes</p> required <p>Returns:</p> Name Type Description <code>GridCoordinateConstraint</code> <code>GridCoordinateConstraint</code> <p>Constraint forcing alignment with specific grid coordinates</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def set_grid_coordinates(\n    self,\n    axes: tuple[int, ...] | int,\n    sides: tuple[Literal[\"+\", \"-\"], ...] | Literal[\"+\", \"-\"],\n    coordinates: tuple[int, ...] | int,\n) -&gt; GridCoordinateConstraint:\n    \"\"\"Creates a GridCoordinateConstraint that forces specific sides of this object to align with\n    given grid coordinates. Used for precise positioning in the discretized simulation space.\n\n    Args:\n        axes: Either a single integer or a tuple describing which axes to constrain\n        sides: Either a single string or a tuple of strings ('+' or '-') indicating which side\n            of each axis to constrain. Must have same length as axes\n        coordinates: Either a single integer or a tuple of integers specifying the grid coordinates\n            to align with. Must have same length as axes\n\n    Returns:\n        GridCoordinateConstraint: Constraint forcing alignment with specific grid coordinates\n    \"\"\"\n    if isinstance(axes, int):\n        axes = tuple(\n            [\n                axes,\n            ]\n        )\n    if isinstance(sides, str):\n        sides = (sides,)\n    if isinstance(coordinates, int):\n        coordinates = tuple(\n            [\n                coordinates,\n            ]\n        )\n    if len(axes) != len(sides) or len(axes) != len(coordinates):\n        raise Exception(\"All inputs need to have the same lengths!\")\n    return GridCoordinateConstraint(\n        object=self,\n        axes=axes,\n        sides=sides,\n        coordinates=coordinates,\n    )\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.SimulationObject.set_real_coordinates","title":"<code>set_real_coordinates(axes, sides, coordinates)</code>","text":"<p>Creates a RealCoordinateConstraint that forces specific sides of this object to align with given real-space coordinates. Used for precise positioning in physical units.</p> <p>Parameters:</p> Name Type Description Default <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes to constrain</p> required <code>sides</code> <code>tuple[Literal['+', '-'], ...] | Literal['+', '-']</code> <p>Either a single string or a tuple of strings ('+' or '-') indicating which side of each axis to constrain. Must have same length as axes</p> required <code>coordinates</code> <code>tuple[float, ...] | float</code> <p>Either a single float or a tuple of floats specifying the real-space coordinates in meters to align with. Must have same length as axes</p> required <p>Returns:</p> Name Type Description <code>RealCoordinateConstraint</code> <code>RealCoordinateConstraint</code> <p>Constraint forcing alignment with specific real-space coordinates</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def set_real_coordinates(\n    self,\n    axes: tuple[int, ...] | int,\n    sides: tuple[Literal[\"+\", \"-\"], ...] | Literal[\"+\", \"-\"],\n    coordinates: tuple[float, ...] | float,\n) -&gt; RealCoordinateConstraint:\n    \"\"\"Creates a RealCoordinateConstraint that forces specific sides of this object to align with\n    given real-space coordinates. Used for precise positioning in physical units.\n\n    Args:\n        axes: Either a single integer or a tuple describing which axes to constrain\n        sides: Either a single string or a tuple of strings ('+' or '-') indicating which side\n            of each axis to constrain. Must have same length as axes\n        coordinates: Either a single float or a tuple of floats specifying the real-space coordinates\n            in meters to align with. Must have same length as axes\n\n    Returns:\n        RealCoordinateConstraint: Constraint forcing alignment with specific real-space coordinates\n    \"\"\"\n    if isinstance(axes, int):\n        axes = tuple(\n            [\n                axes,\n            ]\n        )\n    if isinstance(sides, str):\n        sides = (sides,)\n    if isinstance(coordinates, int | float):\n        coordinates = tuple(\n            [\n                float(coordinates),\n            ]\n        )\n    if len(axes) != len(sides) or len(axes) != len(coordinates):\n        raise Exception(\"All inputs need to have the same lengths!\")\n    return RealCoordinateConstraint(\n        object=self,\n        axes=axes,\n        sides=sides,\n        coordinates=coordinates,\n    )\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.SimulationObject.size_relative_to","title":"<code>size_relative_to(other, axes, other_axes=None, proportions=None, offsets=None, grid_offsets=None)</code>","text":"<p>Creates a SizeConstraint between two objects. The constraint defines the size of this object relative to another object, allowing for proportional scaling and offsets in specified axes.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SimulationObject</code> <p>Another object in the simulation scene</p> required <code>axes</code> <code>tuple[int, ...] | int</code> <p>Either a single integer or a tuple describing which axes of this object to constrain</p> required <code>other_axes</code> <code>tuple[int, ...] | int | None</code> <p>Either a single integer or a tuple describing which axes of the other object to reference. If None, uses the same axes as specified in 'axes'</p> <code>None</code> <code>proportions</code> <code>tuple[float, ...] | float | None</code> <p>Scale factors to apply to the other object's dimensions. Must have same length as axes. If None, defaults to 1.0 (same size)</p> <code>None</code> <code>offsets</code> <code>tuple[float, ...] | float | None</code> <p>Additional size offsets in meters to apply after scaling. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <code>grid_offsets</code> <code>tuple[int, ...] | int | None</code> <p>Additional size offsets in Yee-grid voxels to apply after scaling. Must have same length as axes. If None, defaults to 0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SizeConstraint</code> <code>SizeConstraint</code> <p>Size constraint between this object and the other</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def size_relative_to(\n    self,\n    other: \"SimulationObject\",\n    axes: tuple[int, ...] | int,\n    other_axes: tuple[int, ...] | int | None = None,\n    proportions: tuple[float, ...] | float | None = None,\n    offsets: tuple[float, ...] | float | None = None,\n    grid_offsets: tuple[int, ...] | int | None = None,\n) -&gt; SizeConstraint:\n    \"\"\"Creates a SizeConstraint between two objects. The constraint defines the size of this object relative\n    to another object, allowing for proportional scaling and offsets in specified axes.\n\n    Args:\n        other: Another object in the simulation scene\n        axes: Either a single integer or a tuple describing which axes of this object to constrain\n        other_axes: Either a single integer or a tuple describing which axes of the other object to reference.\n            If None, uses the same axes as specified in 'axes'\n        proportions: Scale factors to apply to the other object's dimensions. Must have same length as axes.\n            If None, defaults to 1.0 (same size)\n        offsets: Additional size offsets in meters to apply after scaling. Must have same length as axes.\n            If None, defaults to 0\n        grid_offsets: Additional size offsets in Yee-grid voxels to apply after scaling. Must have same length as axes.\n            If None, defaults to 0\n\n    Returns:\n        SizeConstraint: Size constraint between this object and the other\n    \"\"\"\n    if isinstance(axes, int):\n        axes = tuple(\n            [\n                axes,\n            ]\n        )\n    if isinstance(other_axes, int):\n        other_axes = tuple(\n            [\n                other_axes,\n            ]\n        )\n    if isinstance(proportions, int | float):\n        proportions = tuple(\n            [\n                float(proportions),\n            ]\n        )\n    if isinstance(offsets, int | float):\n        offsets = tuple(\n            [\n                float(offsets),\n            ]\n        )\n    if isinstance(grid_offsets, int):\n        grid_offsets = tuple(\n            [\n                grid_offsets,\n            ]\n        )\n    if offsets is None:\n        offsets = tuple([0 for _ in axes])\n    if grid_offsets is None:\n        grid_offsets = tuple([0 for _ in axes])\n    if proportions is None:\n        proportions = tuple([1.0 for _ in axes])\n    if other_axes is None:\n        other_axes = tuple([a for a in axes])\n    if len(axes) != len(proportions) or len(axes) != len(offsets) or len(axes) != len(grid_offsets):\n        raise Exception(\"All inputs should have same lengths\")\n    constraint = SizeConstraint(\n        other_object=other,\n        object=self,\n        axes=axes,\n        other_axes=other_axes,\n        proportions=proportions,\n        offsets=offsets,\n        grid_offsets=grid_offsets,\n    )\n    return constraint\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.UniqueName","title":"<code>fdtdx.objects.object.UniqueName</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Generates unique names for simulation objects.</p> <p>A utility class that ensures each simulation object gets a unique name by maintaining a global counter. If no name is provided, generates names in the format \"Object_N\" where N is an incrementing counter.</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>@tc.autoinit\nclass UniqueName(ExtendedTreeClass):\n    \"\"\"Generates unique names for simulation objects.\n\n    A utility class that ensures each simulation object gets a unique name by\n    maintaining a global counter. If no name is provided, generates names in\n    the format \"Object_N\" where N is an incrementing counter.\n    \"\"\"\n\n    def __call__(self, x: str | None) -&gt; str:\n        \"\"\"Generate a unique name if none is provided.\n\n        Args:\n            x: The proposed name or None\n\n        Returns:\n            str: Either the input name if provided, or a new unique name\n        \"\"\"\n        global _GLOBAL_COUNTER\n        if x is None:\n            name = f\"Object_{_GLOBAL_COUNTER}\"\n            _GLOBAL_COUNTER += 1\n            return name\n        return x\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.UniqueName.__call__","title":"<code>__call__(x)</code>","text":"<p>Generate a unique name if none is provided.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>str | None</code> <p>The proposed name or None</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Either the input name if provided, or a new unique name</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>def __call__(self, x: str | None) -&gt; str:\n    \"\"\"Generate a unique name if none is provided.\n\n    Args:\n        x: The proposed name or None\n\n    Returns:\n        str: Either the input name if provided, or a new unique name\n    \"\"\"\n    global _GLOBAL_COUNTER\n    if x is None:\n        name = f\"Object_{_GLOBAL_COUNTER}\"\n        _GLOBAL_COUNTER += 1\n        return name\n    return x\n</code></pre>"},{"location":"api/objects/base/#positioning-constraints","title":"Positioning Constraints","text":"<p>Defines relative positioning between simulation objects.</p> <p>Controls size relationships between objects.</p> <p>Extends objects to reach other objects or boundaries.</p> <p>Aligns objects to specific grid coordinates.</p> <p>Positions objects at specific physical coordinates.</p>"},{"location":"api/objects/base/#fdtdx.objects.object.PositionConstraint","title":"<code>fdtdx.objects.object.PositionConstraint</code>  <code>dataclass</code>","text":"<p>Defines a positional relationship between two simulation objects.</p> <p>A constraint that positions one object relative to another, with optional margins and offsets. Used to specify how objects should be placed in the simulation volume relative to each other.</p> <p>Attributes:</p> Name Type Description <code>object</code> <code>SimulationObject</code> <p>The \"child\" object whose position is being adjusted</p> <code>other_object</code> <code>SimulationObject</code> <p>The \"parent\" object that serves as reference</p> <code>axes</code> <code>tuple[int, ...]</code> <p>Which axes (x,y,z) this constraint applies to</p> <code>object_positions</code> <code>tuple[float, ...]</code> <p>Relative positions on child object (-1 to 1)</p> <code>other_object_positions</code> <code>tuple[float, ...]</code> <p>Relative positions on parent object (-1 to 1)</p> <code>margins</code> <code>tuple[float, ...]</code> <p>Optional real-space margins between objects</p> <code>grid_margins</code> <code>tuple[int, ...]</code> <p>Optional grid-space margins between objects</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>@dataclass(kw_only=True, frozen=True)\nclass PositionConstraint:\n    \"\"\"Defines a positional relationship between two simulation objects.\n\n    A constraint that positions one object relative to another, with optional\n    margins and offsets. Used to specify how objects should be placed in the\n    simulation volume relative to each other.\n\n    Attributes:\n        object: The \"child\" object whose position is being adjusted\n        other_object: The \"parent\" object that serves as reference\n        axes: Which axes (x,y,z) this constraint applies to\n        object_positions: Relative positions on child object (-1 to 1)\n        other_object_positions: Relative positions on parent object (-1 to 1)\n        margins: Optional real-space margins between objects\n        grid_margins: Optional grid-space margins between objects\n    \"\"\"\n\n    object: \"SimulationObject\"  # \"child\" object, whose pos is adjusted\n    other_object: \"SimulationObject\"  # \"parent\" object\n    axes: tuple[int, ...]\n    object_positions: tuple[float, ...]\n    other_object_positions: tuple[float, ...]\n    margins: tuple[float, ...]\n    grid_margins: tuple[int, ...]\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.SizeConstraint","title":"<code>fdtdx.objects.object.SizeConstraint</code>  <code>dataclass</code>","text":"<p>Defines a size relationship between two simulation objects.</p> <p>A constraint that sets the size of one object relative to another, with optional proportions and offsets. Used to specify how objects should be sized relative to each other in the simulation.</p> <p>Attributes:</p> Name Type Description <code>object</code> <code>SimulationObject</code> <p>The \"child\" object whose size is being adjusted</p> <code>other_object</code> <code>SimulationObject</code> <p>The \"parent\" object that serves as reference</p> <code>axes</code> <code>tuple[int, ...]</code> <p>Which axes of the child to constrain</p> <code>other_axes</code> <code>tuple[int, ...]</code> <p>Which axes of the parent to reference</p> <code>proportions</code> <code>tuple[float, ...]</code> <p>Size multipliers relative to parent</p> <code>offsets</code> <code>tuple[float, ...]</code> <p>Additional real-space size offsets</p> <code>grid_offsets</code> <code>tuple[int, ...]</code> <p>Additional grid-space size offsets</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>@dataclass(kw_only=True, frozen=True)\nclass SizeConstraint:\n    \"\"\"Defines a size relationship between two simulation objects.\n\n    A constraint that sets the size of one object relative to another, with\n    optional proportions and offsets. Used to specify how objects should be\n    sized relative to each other in the simulation.\n\n    Attributes:\n        object: The \"child\" object whose size is being adjusted\n        other_object: The \"parent\" object that serves as reference\n        axes: Which axes of the child to constrain\n        other_axes: Which axes of the parent to reference\n        proportions: Size multipliers relative to parent\n        offsets: Additional real-space size offsets\n        grid_offsets: Additional grid-space size offsets\n    \"\"\"\n\n    object: \"SimulationObject\"  # \"child\" object, whose size is adjusted\n    other_object: \"SimulationObject\"  # \"parent\" object\n    axes: tuple[int, ...]\n    other_axes: tuple[int, ...]\n    proportions: tuple[float, ...]\n    offsets: tuple[float, ...]\n    grid_offsets: tuple[int, ...]\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.SizeExtensionConstraint","title":"<code>fdtdx.objects.object.SizeExtensionConstraint</code>  <code>dataclass</code>","text":"<p>Defines how an object extends toward another object or boundary.</p> <p>A constraint that extends one object's size until it reaches another object or the simulation boundary. Can extend in positive or negative direction along an axis.</p> <p>Attributes:</p> Name Type Description <code>object</code> <code>SimulationObject</code> <p>The object being extended</p> <code>other_object</code> <code>Optional[SimulationObject]</code> <p>Optional target object to extend to</p> <code>axis</code> <code>int</code> <p>Which axis to extend along</p> <code>direction</code> <code>Literal['+', '-']</code> <p>Direction to extend ('+' or '-')</p> <code>other_position</code> <code>float</code> <p>Relative position on target (-1 to 1)</p> <code>offset</code> <code>float</code> <p>Additional real-space offset</p> <code>grid_offset</code> <code>int</code> <p>Additional grid-space offset</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>@dataclass(kw_only=True, frozen=True)\nclass SizeExtensionConstraint:\n    \"\"\"Defines how an object extends toward another object or boundary.\n\n    A constraint that extends one object's size until it reaches another object\n    or the simulation boundary. Can extend in positive or negative direction\n    along an axis.\n\n    Attributes:\n        object: The object being extended\n        other_object: Optional target object to extend to\n        axis: Which axis to extend along\n        direction: Direction to extend ('+' or '-')\n        other_position: Relative position on target (-1 to 1)\n        offset: Additional real-space offset\n        grid_offset: Additional grid-space offset\n    \"\"\"\n\n    object: \"SimulationObject\"  # \"child\" object, whose size is adjusted\n    other_object: Optional[\"SimulationObject\"]  # \"parent\" object\n    axis: int\n    direction: Literal[\"+\", \"-\"]\n    other_position: float\n    offset: float\n    grid_offset: int\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.GridCoordinateConstraint","title":"<code>fdtdx.objects.object.GridCoordinateConstraint</code>  <code>dataclass</code>","text":"<p>Constrains an object's position to specific grid coordinates.</p> <p>Forces specific sides of an object to align with given grid coordinates. Used for precise positioning in the discretized simulation space.</p> <p>Attributes:</p> Name Type Description <code>object</code> <code>SimulationObject</code> <p>The object to position</p> <code>axes</code> <code>tuple[int, ...]</code> <p>Which axes to constrain</p> <code>sides</code> <code>tuple[Literal['+', '-'], ...]</code> <p>Which side of each axis ('+' or '-')</p> <code>coordinates</code> <code>tuple[int, ...]</code> <p>Grid coordinates to align with</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>@dataclass(kw_only=True, frozen=True)\nclass GridCoordinateConstraint:\n    \"\"\"Constrains an object's position to specific grid coordinates.\n\n    Forces specific sides of an object to align with given grid coordinates.\n    Used for precise positioning in the discretized simulation space.\n\n    Attributes:\n        object: The object to position\n        axes: Which axes to constrain\n        sides: Which side of each axis ('+' or '-')\n        coordinates: Grid coordinates to align with\n    \"\"\"\n\n    object: \"SimulationObject\"\n    axes: tuple[int, ...]\n    sides: tuple[Literal[\"+\", \"-\"], ...]\n    coordinates: tuple[int, ...]\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.object.RealCoordinateConstraint","title":"<code>fdtdx.objects.object.RealCoordinateConstraint</code>  <code>dataclass</code>","text":"<p>Constrains an object's position to specific real-space coordinates.</p> <p>Forces specific sides of an object to align with given real-space coordinates. Used for precise positioning in physical units.</p> <p>Attributes:</p> Name Type Description <code>object</code> <code>SimulationObject</code> <p>The object to position</p> <code>axes</code> <code>tuple[int, ...]</code> <p>Which axes to constrain</p> <code>sides</code> <code>tuple[Literal['+', '-'], ...]</code> <p>Which side of each axis ('+' or '-')</p> <code>coordinates</code> <code>tuple[float, ...]</code> <p>Real-space coordinates to align with</p> Source code in <code>src/fdtdx/objects/object.py</code> <pre><code>@dataclass(kw_only=True, frozen=True)\nclass RealCoordinateConstraint:\n    \"\"\"Constrains an object's position to specific real-space coordinates.\n\n    Forces specific sides of an object to align with given real-space coordinates.\n    Used for precise positioning in physical units.\n\n    Attributes:\n        object: The object to position\n        axes: Which axes to constrain\n        sides: Which side of each axis ('+' or '-')\n        coordinates: Real-space coordinates to align with\n    \"\"\"\n\n    object: \"SimulationObject\"\n    axes: tuple[int, ...]\n    sides: tuple[Literal[\"+\", \"-\"], ...]\n    coordinates: tuple[float, ...]\n</code></pre>"},{"location":"api/objects/base/#wavelength-dependent-objects","title":"Wavelength-Dependent Objects","text":"<p>Base class for objects with wavelength/period-dependent properties.</p> <p>Non-material modifying wavelength-dependent object.</p>"},{"location":"api/objects/base/#fdtdx.objects.wavelength.WaveLengthDependentObject","title":"<code>fdtdx.objects.wavelength.WaveLengthDependentObject</code>","text":"<p>               Bases: <code>SimulationObject</code>, <code>ABC</code></p> <p>Base class for objects whose properties depend on wavelength/period.</p> <p>An abstract base class for simulation objects that have wavelength-dependent behavior. Provides properties to handle either wavelength or period specification, ensuring only one is set at a time.</p> <p>Attributes:</p> Name Type Description <code>_period</code> <code>float | None</code> <p>Optional period in seconds. Mutually exclusive with _wavelength.</p> <code>_wavelength</code> <code>float | None</code> <p>Optional wavelength in meters. Mutually exclusive with _period.</p> Source code in <code>src/fdtdx/objects/wavelength.py</code> <pre><code>@tc.autoinit\nclass WaveLengthDependentObject(SimulationObject, ABC):\n    \"\"\"Base class for objects whose properties depend on wavelength/period.\n\n    An abstract base class for simulation objects that have wavelength-dependent\n    behavior. Provides properties to handle either wavelength or period specification,\n    ensuring only one is set at a time.\n\n    Attributes:\n        _period: Optional period in seconds. Mutually exclusive with _wavelength.\n        _wavelength: Optional wavelength in meters. Mutually exclusive with _period.\n    \"\"\"\n\n    _period: float | None = tc.field(default=None, alias=\"period\")  # type: ignore\n    _wavelength: float | None = tc.field(default=None, alias=\"wavelength\")  # type: ignore\n\n    @property\n    def period(self) -&gt; float:\n        \"\"\"Gets the period in seconds.\n\n        Returns:\n            float: The period in seconds, either directly set or computed from wavelength.\n\n        Raises:\n            Exception: If neither period nor wavelength is set, or if both are set.\n        \"\"\"\n        if self._period is not None and self._wavelength is not None:\n            raise Exception(\"Need to set either wavelength or period\")\n        if self._period is not None:\n            return self._period\n        if self._wavelength is not None:\n            return self._wavelength / constants.c\n        raise Exception(\"Need to set either wavelength or period\")\n\n    @property\n    def wavelength(self) -&gt; float:\n        \"\"\"Gets the wavelength in meters.\n\n        Returns:\n            float: The wavelength in meters, either directly set or computed from period.\n\n        Raises:\n            Exception: If neither period nor wavelength is set, or if both are set.\n        \"\"\"\n        if self._period is not None and self._wavelength is not None:\n            raise Exception(\"Need to set either wavelength or period\")\n        if self._wavelength is not None:\n            return self._wavelength\n        if self._period is not None:\n            return self._period * constants.c\n        raise Exception(\"Need to set either wavelength or period\")\n\n    @property\n    def frequency(self) -&gt; float:\n        \"\"\"Gets the frequency in Hz.\n\n        Returns:\n            float: The frequency in Hz, computed as 1/period.\n        \"\"\"\n        return 1 / self.period\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.wavelength.WaveLengthDependentObject.frequency","title":"<code>frequency: float</code>  <code>property</code>","text":"<p>Gets the frequency in Hz.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The frequency in Hz, computed as 1/period.</p>"},{"location":"api/objects/base/#fdtdx.objects.wavelength.WaveLengthDependentObject.period","title":"<code>period: float</code>  <code>property</code>","text":"<p>Gets the period in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The period in seconds, either directly set or computed from wavelength.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If neither period nor wavelength is set, or if both are set.</p>"},{"location":"api/objects/base/#fdtdx.objects.wavelength.WaveLengthDependentObject.wavelength","title":"<code>wavelength: float</code>  <code>property</code>","text":"<p>Gets the wavelength in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The wavelength in meters, either directly set or computed from period.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If neither period nor wavelength is set, or if both are set.</p>"},{"location":"api/objects/base/#fdtdx.objects.wavelength.WaveLengthDependentNoMaterial","title":"<code>fdtdx.objects.wavelength.WaveLengthDependentNoMaterial</code>","text":"<p>               Bases: <code>WaveLengthDependentObject</code></p> <p>A wavelength-dependent object that doesn't modify material properties.</p> <p>Implements WaveLengthDependentObject for cases where the object doesn't affect the permittivity or permeability of the simulation volume.</p> Source code in <code>src/fdtdx/objects/wavelength.py</code> <pre><code>@tc.autoinit\nclass WaveLengthDependentNoMaterial(WaveLengthDependentObject):\n    \"\"\"A wavelength-dependent object that doesn't modify material properties.\n\n    Implements WaveLengthDependentObject for cases where the object doesn't affect\n    the permittivity or permeability of the simulation volume.\n    \"\"\"\n\n    def get_inv_permittivity(\n        self,\n        prev_inv_permittivity: jax.Array,\n        params: dict[str, jax.Array] | None,\n    ) -&gt; tuple[jax.Array, dict]:  # permittivity and info dict\n        \"\"\"Returns unchanged inverse permittivity.\n\n        Args:\n            prev_inv_permittivity: The existing inverse permittivity array\n            params: Optional parameter dictionary\n\n        Returns:\n            tuple: (Unchanged inverse permittivity array, Empty info dict)\n        \"\"\"\n        del params\n        return prev_inv_permittivity, {}\n\n    def get_inv_permeability(\n        self,\n        prev_inv_permeability: jax.Array,\n        params: dict[str, jax.Array] | None,\n    ) -&gt; tuple[jax.Array, dict]:  # permeability and info dict\n        \"\"\"Returns unchanged inverse permeability.\n\n        Args:\n            prev_inv_permeability: The existing inverse permeability array\n            params: Optional parameter dictionary\n\n        Returns:\n            tuple: (Unchanged inverse permeability array, Empty info dict)\n        \"\"\"\n        del params\n        return prev_inv_permeability, {}\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.wavelength.WaveLengthDependentNoMaterial.get_inv_permeability","title":"<code>get_inv_permeability(prev_inv_permeability, params)</code>","text":"<p>Returns unchanged inverse permeability.</p> <p>Parameters:</p> Name Type Description Default <code>prev_inv_permeability</code> <code>Array</code> <p>The existing inverse permeability array</p> required <code>params</code> <code>dict[str, Array] | None</code> <p>Optional parameter dictionary</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[Array, dict]</code> <p>(Unchanged inverse permeability array, Empty info dict)</p> Source code in <code>src/fdtdx/objects/wavelength.py</code> <pre><code>def get_inv_permeability(\n    self,\n    prev_inv_permeability: jax.Array,\n    params: dict[str, jax.Array] | None,\n) -&gt; tuple[jax.Array, dict]:  # permeability and info dict\n    \"\"\"Returns unchanged inverse permeability.\n\n    Args:\n        prev_inv_permeability: The existing inverse permeability array\n        params: Optional parameter dictionary\n\n    Returns:\n        tuple: (Unchanged inverse permeability array, Empty info dict)\n    \"\"\"\n    del params\n    return prev_inv_permeability, {}\n</code></pre>"},{"location":"api/objects/base/#fdtdx.objects.wavelength.WaveLengthDependentNoMaterial.get_inv_permittivity","title":"<code>get_inv_permittivity(prev_inv_permittivity, params)</code>","text":"<p>Returns unchanged inverse permittivity.</p> <p>Parameters:</p> Name Type Description Default <code>prev_inv_permittivity</code> <code>Array</code> <p>The existing inverse permittivity array</p> required <code>params</code> <code>dict[str, Array] | None</code> <p>Optional parameter dictionary</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[Array, dict]</code> <p>(Unchanged inverse permittivity array, Empty info dict)</p> Source code in <code>src/fdtdx/objects/wavelength.py</code> <pre><code>def get_inv_permittivity(\n    self,\n    prev_inv_permittivity: jax.Array,\n    params: dict[str, jax.Array] | None,\n) -&gt; tuple[jax.Array, dict]:  # permittivity and info dict\n    \"\"\"Returns unchanged inverse permittivity.\n\n    Args:\n        prev_inv_permittivity: The existing inverse permittivity array\n        params: Optional parameter dictionary\n\n    Returns:\n        tuple: (Unchanged inverse permittivity array, Empty info dict)\n    \"\"\"\n    del params\n    return prev_inv_permittivity, {}\n</code></pre>"},{"location":"api/objects/containers/","title":"Containers","text":""},{"location":"api/objects/containers/#object-container","title":"Object Container","text":"<p>Container for managing simulation objects and their relationships.</p> <p>Type alias for parameter dictionaries containing JAX arrays.</p>"},{"location":"api/objects/containers/#fdtdx.objects.container.ObjectContainer","title":"<code>fdtdx.objects.container.ObjectContainer</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Container for managing simulation objects and their relationships.</p> <p>This class provides a structured way to organize and access different types of simulation objects like sources, detectors, PML boundaries and devices. It maintains object lists and provides filtered access to specific object types.</p> <p>Attributes:</p> Name Type Description <code>object_list</code> <code>list[SimulationObject]</code> <p>List of all simulation objects in the container.</p> <code>volume_idx</code> <code>int</code> <p>Index of the volume object in the object list.</p> Source code in <code>src/fdtdx/objects/container.py</code> <pre><code>@tc.autoinit\nclass ObjectContainer(ExtendedTreeClass):\n    \"\"\"Container for managing simulation objects and their relationships.\n\n    This class provides a structured way to organize and access different types of simulation\n    objects like sources, detectors, PML boundaries and devices. It maintains object lists\n    and provides filtered access to specific object types.\n\n    Attributes:\n        object_list: List of all simulation objects in the container.\n        volume_idx: Index of the volume object in the object list.\n    \"\"\"\n\n    object_list: list[SimulationObject]\n    volume_idx: int\n\n    @property\n    def volume(self) -&gt; SimulationObject:\n        return self.object_list[self.volume_idx]\n\n    @property\n    def objects(self) -&gt; list[SimulationObject]:\n        return self.object_list\n\n    @property\n    def static_material_objects(self) -&gt; list[SimulationObject]:\n        return [o for o in self.objects if not isinstance(o, Device)]\n\n    @property\n    def sources(self) -&gt; list[Source]:\n        return [o for o in self.objects if isinstance(o, Source)]\n\n    @property\n    def devices(self) -&gt; list[Device]:\n        return [o for o in self.objects if isinstance(o, Device)]\n\n    @property\n    def detectors(self) -&gt; list[Detector]:\n        return [o for o in self.objects if isinstance(o, Detector)]\n\n    @property\n    def forward_detectors(self) -&gt; list[Detector]:\n        return [o for o in self.detectors if not o.inverse]\n\n    @property\n    def backward_detectors(self) -&gt; list[Detector]:\n        return [o for o in self.detectors if o.inverse]\n\n    @property\n    def pml_objects(self) -&gt; list[PerfectlyMatchedLayer]:\n        return [o for o in self.objects if isinstance(o, PerfectlyMatchedLayer)]\n\n    def __iter__(self):\n        return iter(self.object_list)\n\n    def __getitem__(\n        self,\n        key: str,\n    ) -&gt; SimulationObject:\n        for o in self.objects:\n            if o.name == key:\n                return o\n        raise ValueError(f\"Key {key} does not exist in object list: {[o.name for o in self.objects]}\")\n\n    def replace_sources(\n        self,\n        sources: list[Source],\n    ) -&gt; Self:\n        new_objects = [o for o in self.objects if o not in self.sources] + sources\n        self = self.aset(\"object_list\", new_objects)\n        return self\n</code></pre>"},{"location":"api/objects/containers/#fdtdx.objects.container.ParameterContainer","title":"<code>fdtdx.objects.container.ParameterContainer = dict[str, dict[str, jax.Array]]</code>  <code>module-attribute</code>","text":""},{"location":"api/objects/containers/#array-container","title":"Array Container","text":"<p>Container for simulation field arrays and states.</p> <p>Type alias for time step and array state tuple.</p>"},{"location":"api/objects/containers/#fdtdx.objects.container.ArrayContainer","title":"<code>fdtdx.objects.container.ArrayContainer</code>","text":"<p>               Bases: <code>ExtendedTreeClass</code></p> <p>Container for simulation field arrays and states.</p> <p>This class holds the electromagnetic field arrays and various state information needed during FDTD simulation. It includes the E and H fields, material properties, and states for boundaries, detectors and recordings.</p> <p>Attributes:</p> Name Type Description <code>E</code> <code>Array</code> <p>Electric field array.</p> <code>H</code> <code>Array</code> <p>Magnetic field array.</p> <code>inv_permittivities</code> <code>Array</code> <p>Inverse permittivity values array.</p> <code>inv_permeabilities</code> <code>Array</code> <p>Inverse permeability values array.</p> <code>boundary_states</code> <code>dict[str, BoundaryState]</code> <p>Dictionary mapping boundary names to their states.</p> <code>detector_states</code> <code>dict[str, DetectorState]</code> <p>Dictionary mapping detector names to their states.</p> <code>recording_state</code> <code>RecordingState | None</code> <p>Optional state for recording simulation data.</p> Source code in <code>src/fdtdx/objects/container.py</code> <pre><code>@tc.autoinit\nclass ArrayContainer(ExtendedTreeClass):\n    \"\"\"Container for simulation field arrays and states.\n\n    This class holds the electromagnetic field arrays and various state information\n    needed during FDTD simulation. It includes the E and H fields, material properties,\n    and states for boundaries, detectors and recordings.\n\n    Attributes:\n        E: Electric field array.\n        H: Magnetic field array.\n        inv_permittivities: Inverse permittivity values array.\n        inv_permeabilities: Inverse permeability values array.\n        boundary_states: Dictionary mapping boundary names to their states.\n        detector_states: Dictionary mapping detector names to their states.\n        recording_state: Optional state for recording simulation data.\n    \"\"\"\n\n    E: jax.Array\n    H: jax.Array\n    inv_permittivities: jax.Array\n    inv_permeabilities: jax.Array\n    boundary_states: dict[str, BoundaryState]\n    detector_states: dict[str, DetectorState]\n    recording_state: RecordingState | None\n</code></pre>"},{"location":"api/objects/containers/#fdtdx.objects.container.SimulationState","title":"<code>fdtdx.objects.container.SimulationState = tuple[jax.Array, ArrayContainer]</code>  <code>module-attribute</code>","text":""},{"location":"api/objects/containers/#array-management","title":"Array Management","text":"<p>Reset array container fields and states.</p>"},{"location":"api/objects/containers/#fdtdx.objects.container.reset_array_container","title":"<code>fdtdx.objects.container.reset_array_container(arrays, objects, reset_detector_states=False, reset_recording_state=False)</code>","text":"<p>Reset an ArrayContainer's fields and optionally its states.</p> <p>This function creates a new ArrayContainer with zeroed E and H fields while preserving material properties. It can optionally reset detector and recording states.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>ArrayContainer</code> <p>The ArrayContainer to reset.</p> required <code>objects</code> <code>ObjectContainer</code> <p>ObjectContainer with simulation objects.</p> required <code>reset_detector_states</code> <code>bool</code> <p>Whether to zero detector states.</p> <code>False</code> <code>reset_recording_state</code> <code>bool</code> <p>Whether to zero recording state.</p> <code>False</code> <p>Returns:</p> Type Description <code>ArrayContainer</code> <p>A new ArrayContainer with reset fields and optionally reset states.</p> Source code in <code>src/fdtdx/objects/container.py</code> <pre><code>def reset_array_container(\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    reset_detector_states: bool = False,\n    reset_recording_state: bool = False,\n) -&gt; ArrayContainer:\n    \"\"\"Reset an ArrayContainer's fields and optionally its states.\n\n    This function creates a new ArrayContainer with zeroed E and H fields while preserving\n    material properties. It can optionally reset detector and recording states.\n\n    Args:\n        arrays: The ArrayContainer to reset.\n        objects: ObjectContainer with simulation objects.\n        reset_detector_states: Whether to zero detector states.\n        reset_recording_state: Whether to zero recording state.\n\n    Returns:\n        A new ArrayContainer with reset fields and optionally reset states.\n    \"\"\"\n    E = arrays.E * 0\n    H = arrays.H * 0\n\n    boundary_states = {}\n    for pml in objects.pml_objects:\n        boundary_states[pml.name] = pml.reset_state(state=arrays.boundary_states[pml.name])\n\n    detector_states = arrays.detector_states\n    if reset_detector_states:\n        detector_states = {k: {k2: v2 * 0 for k2, v2 in v.items()} for k, v in detector_states.items()}\n\n    recording_state = arrays.recording_state\n    if reset_recording_state and arrays.recording_state is not None:\n        recording_state = RecordingState(\n            data={k: v * 0 for k, v in arrays.recording_state.data.items()},\n            state={k: v * 0 for k, v in arrays.recording_state.state.items()},\n        )\n\n    return ArrayContainer(\n        E=E,\n        H=H,\n        inv_permittivities=arrays.inv_permittivities,\n        inv_permeabilities=arrays.inv_permeabilities,\n        boundary_states=boundary_states,\n        detector_states=detector_states,\n        recording_state=recording_state,\n    )\n</code></pre>"},{"location":"api/objects/initialization/","title":"Object Initialization","text":""},{"location":"api/objects/initialization/#main-functions","title":"Main Functions","text":"<p>Main entry point for placing and initializing simulation objects.</p> <p>Applies parameters to devices and updates source states.</p>"},{"location":"api/objects/initialization/#fdtdx.objects.initialization.place_objects","title":"<code>fdtdx.objects.initialization.place_objects(volume, config, constraints, key)</code>","text":"<p>Places simulation objects according to specified constraints and initializes containers.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>SimulationObject</code> <p>The volume object defining the simulation boundaries</p> required <code>config</code> <code>SimulationConfig</code> <p>The simulation configuration</p> required <code>constraints</code> <code>Sequence[PositionConstraint | SizeConstraint | SizeExtensionConstraint | GridCoordinateConstraint | RealCoordinateConstraint]</code> <p>Sequence of positioning and sizing constraints for objects</p> required <code>key</code> <code>Array</code> <p>JAX random key for initialization</p> required <p>Returns:</p> Type Description <code>tuple[ObjectContainer, ArrayContainer, ParameterContainer, SimulationConfig, dict[str, Any]]</code> <p>A tuple containing: - ObjectContainer with placed simulation objects - ArrayContainer with initialized field arrays - ParameterContainer with device parameters - Updated SimulationConfig - Dictionary with additional initialization info</p> Source code in <code>src/fdtdx/objects/initialization.py</code> <pre><code>def place_objects(\n    volume: SimulationObject,\n    config: SimulationConfig,\n    constraints: Sequence[\n        (\n            PositionConstraint\n            | SizeConstraint\n            | SizeExtensionConstraint\n            | GridCoordinateConstraint\n            | RealCoordinateConstraint\n        )\n    ],\n    key: jax.Array,\n) -&gt; tuple[\n    ObjectContainer,\n    ArrayContainer,\n    ParameterContainer,\n    SimulationConfig,\n    dict[str, Any],\n]:\n    \"\"\"Places simulation objects according to specified constraints and initializes containers.\n\n    Args:\n        volume: The volume object defining the simulation boundaries\n        config: The simulation configuration\n        constraints: Sequence of positioning and sizing constraints for objects\n        key: JAX random key for initialization\n\n    Returns:\n        A tuple containing:\n            - ObjectContainer with placed simulation objects\n            - ArrayContainer with initialized field arrays\n            - ParameterContainer with device parameters\n            - Updated SimulationConfig\n            - Dictionary with additional initialization info\n    \"\"\"\n    slice_tuple_dict = _resolve_object_constraints(\n        volume=volume,\n        constraints=constraints,\n        config=config,\n    )\n    obj_list = list(slice_tuple_dict.keys())\n\n    # place objects on computed grid positions\n    placed_objects = []\n    for o in obj_list:\n        if o == volume:\n            continue\n        key, subkey = jax.random.split(key)\n        placed_objects.append(\n            o.place_on_grid(\n                grid_slice_tuple=slice_tuple_dict[o],\n                config=config,\n                key=subkey,\n            )\n        )\n    key, subkey = jax.random.split(key)\n    placed_objects.insert(\n        0,\n        volume.place_on_grid(\n            grid_slice_tuple=slice_tuple_dict[volume],\n            config=config,\n            key=subkey,\n        ),\n    )\n\n    # create container\n    objects = ObjectContainer(\n        object_list=placed_objects,\n        volume_idx=0,\n    )\n    params = _init_params(\n        objects=objects,\n        key=key,\n    )\n    arrays, config, info = _init_arrays(\n        objects=objects,\n        config=config,\n    )\n\n    # replace config in objects with compiled config\n    new_object_list = []\n    for o in objects.objects:\n        o = o.aset(\"_config\", config)\n        new_object_list.append(o)\n    objects = ObjectContainer(\n        object_list=new_object_list,\n        volume_idx=0,\n    )\n\n    return objects, arrays, params, config, info\n</code></pre>"},{"location":"api/objects/initialization/#fdtdx.objects.initialization.apply_params","title":"<code>fdtdx.objects.initialization.apply_params(arrays, objects, params, key)</code>","text":"<p>Applies parameters to devices and updates source states.</p> <p>Parameters:</p> Name Type Description Default <code>arrays</code> <code>ArrayContainer</code> <p>Container with field arrays</p> required <code>objects</code> <code>ObjectContainer</code> <p>Container with simulation objects</p> required <code>params</code> <code>ParameterContainer</code> <p>Container with device parameters</p> required <code>key</code> <code>Array</code> <p>JAX random key for source updates</p> required <p>Returns:</p> Type Description <code>tuple[ArrayContainer, ObjectContainer, dict[str, Any]]</code> <p>A tuple containing: - Updated ArrayContainer with applied device parameters - Updated ObjectContainer with new source states - Dictionary with parameter application info</p> Source code in <code>src/fdtdx/objects/initialization.py</code> <pre><code>def apply_params(\n    arrays: ArrayContainer,\n    objects: ObjectContainer,\n    params: ParameterContainer,\n    key: jax.Array,\n) -&gt; tuple[ArrayContainer, ObjectContainer, dict[str, Any]]:\n    \"\"\"Applies parameters to devices and updates source states.\n\n    Args:\n        arrays: Container with field arrays\n        objects: Container with simulation objects\n        params: Container with device parameters\n        key: JAX random key for source updates\n\n    Returns:\n        A tuple containing:\n            - Updated ArrayContainer with applied device parameters\n            - Updated ObjectContainer with new source states\n            - Dictionary with parameter application info\n    \"\"\"\n    info = {}\n    # apply parameter to devices\n    for device in objects.devices:\n        prev_slice = arrays.inv_permittivities[*device.grid_slice]\n        inv_perm_at_slice, cur_info = device.get_inv_permittivity(\n            prev_inv_permittivity=prev_slice,\n            params=params[device.name],\n        )\n        info.update(cur_info)\n        new_perm = arrays.inv_permittivities.at[*device.grid_slice].set(inv_perm_at_slice)\n        arrays = arrays.at[\"inv_permittivities\"].set(new_perm)\n\n    # apply random key to sources\n    new_sources = []\n    for source in objects.sources:\n        key, subkey = jax.random.split(key)\n        new_source = source.apply(\n            key=subkey,\n            inv_permittivities=jax.lax.stop_gradient(arrays.inv_permittivities),\n            inv_permeabilities=jax.lax.stop_gradient(arrays.inv_permeabilities),\n        )\n        new_sources.append(new_source)\n    objects = objects.replace_sources(new_sources)\n\n    return arrays, objects, info\n</code></pre>"},{"location":"api/objects/initialization/#internal-functions","title":"Internal Functions","text":"<p>Initializes field arrays and material properties.</p> <p>Initializes parameters for simulation devices.</p> <p>Resolves positioning and sizing constraints between objects.</p>"},{"location":"api/objects/initialization/#fdtdx.objects.initialization._init_arrays","title":"<code>fdtdx.objects.initialization._init_arrays(objects, config)</code>","text":"<p>Initializes field arrays and material properties for the simulation.</p> <p>Creates and initializes the E/H fields, permittivity/permeability arrays, detector states, boundary states and recording states based on the simulation objects and configuration.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>ObjectContainer</code> <p>Container with simulation objects</p> required <code>config</code> <code>SimulationConfig</code> <p>The simulation configuration</p> required <p>Returns:</p> Type Description <code>tuple[ArrayContainer, SimulationConfig, dict[str, Any]]</code> <p>A tuple containing: - ArrayContainer with initialized arrays and states - Updated SimulationConfig - Dictionary with initialization info</p> Source code in <code>src/fdtdx/objects/initialization.py</code> <pre><code>def _init_arrays(\n    objects: ObjectContainer,\n    config: SimulationConfig,\n) -&gt; tuple[ArrayContainer, SimulationConfig, dict[str, Any]]:\n    \"\"\"Initializes field arrays and material properties for the simulation.\n\n    Creates and initializes the E/H fields, permittivity/permeability arrays,\n    detector states, boundary states and recording states based on the\n    simulation objects and configuration.\n\n    Args:\n        objects: Container with simulation objects\n        config: The simulation configuration\n\n    Returns:\n        A tuple containing:\n            - ArrayContainer with initialized arrays and states\n            - Updated SimulationConfig\n            - Dictionary with initialization info\n    \"\"\"\n    # create E/H fields\n    volume_shape = objects.volume.grid_shape\n    ext_shape = (3, *volume_shape)\n    E = create_named_sharded_matrix(\n        ext_shape,\n        sharding_axis=1,\n        value=0.0,\n        dtype=config.dtype,\n        backend=config.backend,\n    )\n    H = create_named_sharded_matrix(\n        ext_shape,\n        value=0.0,\n        dtype=config.dtype,\n        sharding_axis=1,\n        backend=config.backend,\n    )\n\n    # permittivity / permeability\n    shape_params = volume_shape\n    inv_permittivities = create_named_sharded_matrix(\n        shape_params,\n        value=0.0,\n        dtype=config.dtype,\n        sharding_axis=1,\n        backend=config.backend,\n    )\n    inv_permeabilities = create_named_sharded_matrix(\n        shape_params,\n        value=0.0,\n        dtype=config.dtype,\n        sharding_axis=1,\n        backend=config.backend,\n    )\n\n    # set permittivity/permeability of static objects\n    sorted_obj = sorted(\n        objects.static_material_objects,\n        key=lambda o: o.placement_order,\n    )\n    info = {}\n    for o in sorted_obj:\n        prev_slice = inv_permittivities[*o.grid_slice]\n        update, cur_info = o.get_inv_permittivity(\n            prev_inv_permittivity=prev_slice,\n            params=None,\n        )\n        inv_permittivities = inv_permittivities.at[*o.grid_slice].set(update)\n        info.update(cur_info)\n\n        prev_slice = inv_permeabilities[*o.grid_slice]\n        update, cur_info = o.get_inv_permeability(\n            prev_inv_permeability=prev_slice,\n            params=None,\n        )\n        inv_permeabilities = inv_permeabilities.at[*o.grid_slice].set(update)\n        info.update(cur_info)\n\n    # detector states\n    detector_states = {}\n    for d in objects.detectors:\n        detector_states[d.name] = d.init_state()\n\n    # boundary states\n    boundary_states = {}\n    for pml in objects.pml_objects:\n        boundary_states[pml.name] = pml.init_state()\n\n    # interfaces\n    recording_state = None\n    if config.gradient_config is not None and config.gradient_config.recorder is not None:\n        input_shape_dtypes = {}\n        for pml in objects.pml_objects:\n            cur_shape = pml.boundary_interface_grid_shape()\n            extended_shape = (3, *cur_shape)\n            input_shape_dtypes[f\"{pml.name}_E\"] = jax.ShapeDtypeStruct(shape=extended_shape, dtype=config.dtype)\n            input_shape_dtypes[f\"{pml.name}_H\"] = jax.ShapeDtypeStruct(shape=extended_shape, dtype=config.dtype)\n        recorder = config.gradient_config.recorder\n        recorder, recording_state = recorder.init_state(\n            input_shape_dtypes=input_shape_dtypes,\n            max_time_steps=config.time_steps_total,\n            backend=config.backend,\n        )\n        grad_cfg = config.gradient_config.aset(\n            \"recorder\",\n            recorder,\n        )\n        config = config.aset(\"gradient_config\", grad_cfg)\n\n    arrays = ArrayContainer(\n        E=E,\n        H=H,\n        inv_permittivities=inv_permittivities,\n        inv_permeabilities=inv_permeabilities,\n        boundary_states=boundary_states,\n        detector_states=detector_states,\n        recording_state=recording_state,\n    )\n    return arrays, config, info\n</code></pre>"},{"location":"api/objects/initialization/#fdtdx.objects.initialization._init_params","title":"<code>fdtdx.objects.initialization._init_params(objects, key)</code>","text":"<p>Initializes parameters for simulation devices.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>ObjectContainer</code> <p>Container with simulation objects</p> required <code>key</code> <code>Array</code> <p>JAX random key for parameter initialization</p> required <p>Returns:</p> Type Description <code>ParameterContainer</code> <p>ParameterContainer with initialized device parameters</p> Source code in <code>src/fdtdx/objects/initialization.py</code> <pre><code>def _init_params(\n    objects: ObjectContainer,\n    key: jax.Array,\n) -&gt; ParameterContainer:\n    \"\"\"Initializes parameters for simulation devices.\n\n    Args:\n        objects: Container with simulation objects\n        key: JAX random key for parameter initialization\n\n    Returns:\n        ParameterContainer with initialized device parameters\n    \"\"\"\n    params = {}\n    for d in objects.devices:\n        # device and aparameters\n        key, subkey = jax.random.split(key)\n        cur_dict = d.init_params(\n            key=subkey,\n        )\n        params[d.name] = cur_dict\n    return params\n</code></pre>"},{"location":"api/objects/initialization/#fdtdx.objects.initialization._resolve_object_constraints","title":"<code>fdtdx.objects.initialization._resolve_object_constraints(volume, constraints, config)</code>","text":"<p>Resolves positioning and sizing constraints between simulation objects.</p> <p>Iteratively resolves the constraints between objects to determine their final positions and sizes in the simulation grid. Handles absolute and relative positioning, size relationships, and grid alignments.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>SimulationObject</code> <p>The volume object defining simulation boundaries</p> required <code>constraints</code> <code>Sequence[PositionConstraint | SizeConstraint | SizeExtensionConstraint | GridCoordinateConstraint | RealCoordinateConstraint]</code> <p>Sequence of positioning and sizing constraints</p> required <code>config</code> <code>SimulationConfig</code> <p>The simulation configuration</p> required <p>Returns:</p> Type Description <code>dict[SimulationObject, SliceTuple3D]</code> <p>Dictionary mapping objects to their resolved grid slice tuples</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If constraints cannot be resolved or are inconsistent</p> Source code in <code>src/fdtdx/objects/initialization.py</code> <pre><code>def _resolve_object_constraints(\n    volume: SimulationObject,\n    constraints: Sequence[\n        (\n            PositionConstraint\n            | SizeConstraint\n            | SizeExtensionConstraint\n            | GridCoordinateConstraint\n            | RealCoordinateConstraint\n        )\n    ],\n    config: SimulationConfig,\n) -&gt; dict[SimulationObject, SliceTuple3D]:\n    \"\"\"Resolves positioning and sizing constraints between simulation objects.\n\n    Iteratively resolves the constraints between objects to determine their\n    final positions and sizes in the simulation grid. Handles absolute and\n    relative positioning, size relationships, and grid alignments.\n\n    Args:\n        volume: The volume object defining simulation boundaries\n        constraints: Sequence of positioning and sizing constraints\n        config: The simulation configuration\n\n    Returns:\n        Dictionary mapping objects to their resolved grid slice tuples\n\n    Raises:\n        Exception: If constraints cannot be resolved or are inconsistent\n    \"\"\"\n    resolution = config.resolution\n    # split constraints into seperate lists\n    obj_list: list[SimulationObject] = [volume]\n\n    # collect objects\n    for c in constraints:\n        if isinstance(\n            c,\n            (\n                PositionConstraint,\n                SizeConstraint,\n                SizeExtensionConstraint,\n            ),\n        ):\n            if c.other_object is not None and c.other_object not in obj_list:\n                obj_list.append(c.other_object)\n            if c.object not in obj_list:\n                obj_list.append(c.object)\n        elif isinstance(\n            c,\n            (\n                GridCoordinateConstraint,\n                RealCoordinateConstraint,\n            ),\n        ):\n            if c.object not in obj_list:\n                obj_list.append(c.object)\n\n    # init shape and position dict\n    shape_dict: dict[SimulationObject, list[int | None]] = {o: [None, None, None] for o in obj_list}\n    slice_dict: dict[SimulationObject, list[list[int | None]]] = {\n        o: [[None, None], [None, None], [None, None]] for o in obj_list\n    }\n\n    # calculate static shapes\n    for o in obj_list:\n        for axis in range(3):\n            if o.partial_grid_shape[axis] is not None:\n                shape_dict[o][axis] = o.partial_grid_shape[axis]\n            if o.partial_real_shape[axis] is not None:\n                cur_grid_shape = round(\n                    o.partial_real_shape[axis] / resolution  # type: ignore\n                )\n                shape_dict[o][axis] = cur_grid_shape\n\n    for axis in range(3):\n        slice_dict[volume][axis][0] = 0\n\n    # resolve constraints, break condition below\n    while True:\n        if all(\n            [\n                all([shape_dict[o][i] is not None for i in range(3)])\n                and all([all([slice_dict[o][i][s] is not None for s in range(2)]) for i in range(3)])\n                for o in obj_list\n            ]\n        ):\n            # everything is resolved\n            break\n        # prevent infinite loop when constraints are underspecified\n        resolved_something = False\n        # update grid-slices based on grid shapes\n        for o, s in shape_dict.items():\n            for axis in range(3):\n                s_axis = s[axis]\n                if s_axis is None:\n                    continue\n                b0, b1 = slice_dict[o][axis]\n                if b0 is None and b1 is None:\n                    continue\n                elif b0 is not None and b1 is not None:\n                    if s_axis != b1 - b0:\n                        raise Exception(\n                            f\"Inconsistent grid shape for object: {s_axis} != {b1 - b0}, {o.name} ({o.__class__}).\"\n                        )\n                elif b0 is not None:\n                    slice_dict[o][axis][1] = b0 + s_axis\n                    resolved_something = True\n                elif b1 is not None:\n                    slice_dict[o][axis][0] = b1 - s_axis\n                    resolved_something = True\n        # update grid-shapes based on grid-slices\n        for o, b in slice_dict.items():\n            s = shape_dict[o]\n            for axis in range(3):\n                b0, b1 = b[axis]\n                s_axis = s[axis]\n                if b0 is not None and b1 is not None:\n                    if s_axis is None:\n                        shape_dict[o][axis] = b1 - b0\n                        resolved_something = True\n                    elif s_axis is not None and b1 - b0 != s_axis:\n                        raise Exception(\n                            f\"Inconsistent grid shape for object: {s_axis} != {b1 - b0}, {o.name} ({o.__class__}).\"\n                        )\n        # iterate over all constraints\n        for c in constraints:\n            # absolute grid coordinate constraints\n            if isinstance(c, GridCoordinateConstraint):\n                for axis_idx, axis in enumerate(c.axes):\n                    cur_size = c.coordinates[axis_idx]\n                    o = c.object\n                    b_idx = 0 if c.sides[axis_idx] == \"-\" else 1\n                    if slice_dict[o][axis][b_idx] is None:\n                        slice_dict[o][axis][b_idx] = cur_size\n                        resolved_something = True\n                    elif slice_dict[o][axis][b_idx] != cur_size:\n                        raise Exception(\n                            f\"Inconsisten grid coordinates for object: \"\n                            f\"{slice_dict[o][axis][b_idx]} != {cur_size} for {axis=} {o.name} ({o.__class__}). \"\n                        )\n            # absolute real coordinate constraints\n            if isinstance(c, RealCoordinateConstraint):\n                for axis_idx, axis in enumerate(c.axes):\n                    cur_size = round(c.coordinates[axis_idx] / resolution)\n                    o = c.object\n                    b_idx = 0 if c.sides[axis_idx] == \"-\" else 1\n                    if slice_dict[o][axis][b_idx] is None:\n                        slice_dict[o][axis][b_idx] = cur_size\n                        resolved_something = True\n                    elif slice_dict[o][axis][b_idx] != cur_size:\n                        raise Exception(\n                            f\"Inconsisten grid coordinates for object: \"\n                            f\"{slice_dict[o][axis][b_idx]} != {cur_size} for {axis=} {o.name} ({o.__class__}). \"\n                        )\n            # size constraints\n            if isinstance(c, SizeConstraint):\n                for axis_idx, axis in enumerate(c.axes):\n                    other_axes = c.other_axes[axis_idx]\n                    o, other = c.object, c.other_object\n                    # check if other object knows their shape\n                    other_shape = shape_dict[other][other_axes]\n                    if other_shape is None:\n                        continue\n                    # calculate objects shape\n                    proportion = c.proportions[axis_idx]\n                    grid_offset = 0\n                    if c.grid_offsets[axis_idx] is not None:\n                        grid_offset += c.grid_offsets[axis_idx]\n                    if c.offsets[axis_idx] is not None:\n                        grid_offset += c.offsets[axis_idx] / resolution\n                    object_shape = round(other_shape * proportion + grid_offset)\n                    # update or check consistency\n                    if shape_dict[o][axis] is None:\n                        shape_dict[o][axis] = object_shape\n                        resolved_something = True\n                    elif shape_dict[o][axis] != object_shape:\n                        raise Exception(\n                            \"Inconsisten grid shape for object: \",\n                            f\"{shape_dict[o][axis]} != {object_shape} for {axis=}, {o.name} ({o.__class__}). \",\n                            \"Please check if there are multiple constraints or sizes specified for the object.\",\n                        )\n            # positional constraints\n            if isinstance(c, PositionConstraint):\n                for axis_idx, axis in enumerate(c.axes):\n                    o, other = c.object, c.other_object\n                    grid_margin = c.grid_margins[axis_idx]\n                    real_margin = c.margins[axis_idx]\n                    # check if other knows their position\n                    other_b0, other_b1 = slice_dict[other][axis]\n                    if other_b0 is None or other_b1 is None:\n                        continue\n                    # check if object knows their size\n                    object_size = shape_dict[o][axis]\n                    if object_size is None:\n                        continue\n                    # calculate anchor of other\n                    other_pos = c.other_object_positions[axis_idx]\n                    other_midpoint = (other_b1 + other_b0) / 2\n                    factor = (other_b1 - other_b0) / 2\n                    other_offset = 0\n                    if grid_margin is not None:\n                        other_offset += grid_margin\n                    if real_margin is not None:\n                        other_offset += real_margin / resolution\n                    other_anchor = other_midpoint + factor * other_pos + other_offset\n                    # calculate position of object\n                    obj_pos = c.object_positions[axis_idx]\n                    obj_factor = object_size / 2\n                    object_midpoint = other_anchor - obj_pos * obj_factor\n                    b0 = round(object_midpoint - obj_factor)\n                    # Important: do not round twice to exactly preserve object size\n                    b1 = b0 + object_size\n                    # update position or check consistency\n                    old_b0, old_b1 = slice_dict[o][axis]\n                    if old_b0 is None:\n                        slice_dict[o][axis][0] = b0\n                        resolved_something = True\n                    elif old_b0 != b0:\n                        raise Exception(\n                            f\"Inconsisten grid shape (may be due to extension to infinity) at lower bound: \"\n                            f\"{old_b0} != {b0} for {axis=}, {o.name} ({o.__class__}). \"\n                            f\"Object has a position constraint that puts the lower boundary at {b0}, \"\n                            f\"but the lower bound was alreay computed to be at {old_b0}. \"\n                            f\"This could be due to a missing size constraint/specification, \"\n                            f\"which resulted in an expansion of the object to the simulation boundary (default size) \"\n                            f\"or another constraint on this object.\"\n                        )\n                    if old_b1 is None:\n                        slice_dict[o][axis][1] = b1\n                        resolved_something = True\n                    elif old_b1 != b1:\n                        raise Exception(\n                            f\"Inconsisten grid shape (may be due to extension to infinity) at lower bound: \"\n                            f\"{old_b1} != {b1} for {axis=}, {o.name} ({o.__class__}). \"\n                            f\"Object has a position constraint that puts the upper boundary at {b1}, \"\n                            f\"but the lower bound was alreay computed to be at {old_b1}. \"\n                            f\"This could be either due to a missing size constraint/specification, \"\n                            f\"which resulted in an expansion of the object to the simulation boundary (default size) \"\n                            f\"or another constraint on this object.\"\n                        )\n            # size extension constraints\n            if isinstance(c, SizeExtensionConstraint):\n                o, other = c.object, c.other_object\n                dir_idx = 0 if c.direction == \"-\" else 1\n                # calculate anchor point\n                if other is not None:\n                    # check if other knows their position\n                    other_b0, other_b1 = slice_dict[other][c.axis]\n                    if other_b0 is None or other_b1 is None:\n                        continue\n                    # calculate anchor of other position\n                    other_midpoint = (other_b1 + other_b0) / 2\n                    factor = (other_b1 - other_b0) / 2\n                    other_offset = 0\n                    if c.grid_offset is not None:\n                        other_offset += c.grid_offset\n                    if c.offset is not None:\n                        other_offset += c.offset / resolution\n                    other_anchor = round(other_midpoint + factor * c.other_position + other_offset)\n                else:\n                    # if other is not specified, extend to boundary of simulation volume\n                    other_anchor = slice_dict[volume][c.axis][dir_idx]\n                    if other_anchor is None:\n                        raise Exception(f\"This should never happen: Simulation volume not specified: {volume}\")\n                # update position or check consistency\n                old_val = slice_dict[o][c.axis][dir_idx]\n                if old_val is None:\n                    slice_dict[o][c.axis][dir_idx] = other_anchor\n                    resolved_something = True\n                elif old_val != other_anchor:\n                    raise Exception(\n                        f\"Inconsisten grid shape at bound {c.direction}: \"\n                        f\"{old_val} != {other_anchor} for {axis=}, \"\n                        f\"{o.name} ({o.__class__}).\"\n                    )\n        # Extend objects to infinity, which fulfull the properties:\n        # - do not already have a specified shape\n        # - are not object in a size constraint/extend_to\n        if not resolved_something:\n            for axis in range(3):\n                extension_obj = [(o, 0) for o in obj_list] + [(o, 1) for o in obj_list]\n                for c in constraints:\n                    if isinstance(c, SizeConstraint) and axis in c.axes:\n                        if (c.object, 0) in extension_obj:\n                            extension_obj.remove((c.object, 0))\n                        if (c.object, 1) in extension_obj:\n                            extension_obj.remove((c.object, 1))\n                    if isinstance(c, SizeExtensionConstraint) and axis == c.axis:\n                        direction = 0 if c.direction == \"-\" else 1\n                        if (c.object, direction) in extension_obj:\n                            extension_obj.remove((c.object, direction))\n                for o in obj_list:\n                    if shape_dict[o][axis] is not None:\n                        if (o, 0) in extension_obj:\n                            extension_obj.remove((o, 0))\n                        if (o, 1) in extension_obj:\n                            extension_obj.remove((o, 1))\n                a = 1\n                for o, direction in extension_obj:\n                    if slice_dict[o][axis][direction] is not None:\n                        continue\n                    resolved_something = True\n                    if direction == 0:\n                        slice_dict[o][axis][0] = 0\n                    else:\n                        slice_dict[o][axis][1] = shape_dict[volume][axis]\n        # if we still have not resolved something, the object is not specified properly\n        if not resolved_something:\n            to_resolve_str = [\n                f\"{o.__class__} ({o.name}): {slice_dict[o]}\"\n                for o in obj_list\n                if any([slice_dict[o][a][0] is None or slice_dict[o][a][1] is None for a in range(3)])\n            ]\n            # error message\n            raise Exception(f\"Could not resolve position/size of objects: \\n {to_resolve_str}\")\n    # create slice dictionary\n    result = {}\n    for o, s in slice_dict.items():\n        slices = []\n        for a in range(3):\n            s0, s1 = s[a]\n            if s0 is None or s1 is None:\n                raise Exception(f\"This should never happen: object not specified: {o=}, {s0=}, {s1=}\")\n            slices.append((s0, s1))\n        result[o] = tuple(slices)\n    return result\n</code></pre>"},{"location":"api/objects/materials/","title":"Materials","text":""},{"location":"api/objects/materials/#base-materials","title":"Base Materials","text":"<p>Base class for materials with uniform electromagnetic properties.</p> <p>Non-interacting material that preserves existing properties.</p> <p>Background material defining simulation environment properties.</p> <p>Material for modeling substrate layers.</p> <p>Material for optical waveguide structures.</p>"},{"location":"api/objects/materials/#fdtdx.objects.material.UniformMaterial","title":"<code>fdtdx.objects.material.UniformMaterial</code>","text":"<p>               Bases: <code>SimulationObject</code></p> <p>Object with uniform permittivity and permeability throughout its volume.</p> <p>A material object that applies constant permittivity and permeability values to its entire volume in the simulation grid. Used as base class for specific material implementations.</p> <p>Attributes:</p> Name Type Description <code>permittivity</code> <code>float</code> <p>Relative permittivity (\u03b5\u1d63) of the material</p> <code>permeability</code> <code>float</code> <p>Relative permeability (\u03bc\u1d63) of the material, defaults to 1.0</p> <code>color</code> <code>tuple[float, float, float]</code> <p>RGB tuple for visualization, defaults to light grey</p> Source code in <code>src/fdtdx/objects/material.py</code> <pre><code>@extended_autoinit\nclass UniformMaterial(SimulationObject):\n    \"\"\"Object with uniform permittivity and permeability throughout its volume.\n\n    A material object that applies constant permittivity and permeability values\n    to its entire volume in the simulation grid. Used as base class for specific\n    material implementations.\n\n    Attributes:\n        permittivity: Relative permittivity (\u03b5\u1d63) of the material\n        permeability: Relative permeability (\u03bc\u1d63) of the material, defaults to 1.0\n        color: RGB tuple for visualization, defaults to light grey\n    \"\"\"\n\n    permittivity: float = frozen_field(init=True, kind=\"KW_ONLY\")  # type: ignore\n    permeability: float = tc.field(default=1.0, init=True, kind=\"KW_ONLY\")  # type: ignore\n    color: tuple[float, float, float] = LIGHT_GREY\n\n    def get_inv_permittivity(\n        self,\n        prev_inv_permittivity: jax.Array,\n        params: dict[str, jax.Array] | None,\n    ) -&gt; tuple[jax.Array, dict]:  # permittivity and info dict\n        \"\"\"Calculate inverse permittivity for this material's volume.\n\n        Args:\n            prev_inv_permittivity: Previous inverse permittivity values\n            params: Optional parameters for permittivity calculation\n\n        Returns:\n            tuple containing:\n                - Array of inverse permittivity values (1/\u03b5\u1d63)\n                - Dictionary with additional information\n        \"\"\"\n        del params\n        res = jnp.ones_like(prev_inv_permittivity) / self.permittivity\n        return res, {}\n\n    def get_inv_permeability(\n        self,\n        prev_inv_permeability: jax.Array,\n        params: dict[str, jax.Array] | None,\n    ) -&gt; tuple[jax.Array, dict]:  # permeability and info dict\n        \"\"\"Calculate inverse permeability for this material's volume.\n\n        Args:\n            prev_inv_permeability: Previous inverse permeability values\n            params: Optional parameters for permeability calculation\n\n        Returns:\n            tuple containing:\n                - Array of inverse permeability values (1/\u03bc\u1d63)\n                - Dictionary with additional information\n        \"\"\"\n        del params\n        res = jnp.ones_like(prev_inv_permeability) / self.permeability\n        return res, {}\n</code></pre>"},{"location":"api/objects/materials/#fdtdx.objects.material.UniformMaterial.get_inv_permeability","title":"<code>get_inv_permeability(prev_inv_permeability, params)</code>","text":"<p>Calculate inverse permeability for this material's volume.</p> <p>Parameters:</p> Name Type Description Default <code>prev_inv_permeability</code> <code>Array</code> <p>Previous inverse permeability values</p> required <code>params</code> <code>dict[str, Array] | None</code> <p>Optional parameters for permeability calculation</p> required <p>Returns:</p> Type Description <code>tuple[Array, dict]</code> <p>tuple containing: - Array of inverse permeability values (1/\u03bc\u1d63) - Dictionary with additional information</p> Source code in <code>src/fdtdx/objects/material.py</code> <pre><code>def get_inv_permeability(\n    self,\n    prev_inv_permeability: jax.Array,\n    params: dict[str, jax.Array] | None,\n) -&gt; tuple[jax.Array, dict]:  # permeability and info dict\n    \"\"\"Calculate inverse permeability for this material's volume.\n\n    Args:\n        prev_inv_permeability: Previous inverse permeability values\n        params: Optional parameters for permeability calculation\n\n    Returns:\n        tuple containing:\n            - Array of inverse permeability values (1/\u03bc\u1d63)\n            - Dictionary with additional information\n    \"\"\"\n    del params\n    res = jnp.ones_like(prev_inv_permeability) / self.permeability\n    return res, {}\n</code></pre>"},{"location":"api/objects/materials/#fdtdx.objects.material.UniformMaterial.get_inv_permittivity","title":"<code>get_inv_permittivity(prev_inv_permittivity, params)</code>","text":"<p>Calculate inverse permittivity for this material's volume.</p> <p>Parameters:</p> Name Type Description Default <code>prev_inv_permittivity</code> <code>Array</code> <p>Previous inverse permittivity values</p> required <code>params</code> <code>dict[str, Array] | None</code> <p>Optional parameters for permittivity calculation</p> required <p>Returns:</p> Type Description <code>tuple[Array, dict]</code> <p>tuple containing: - Array of inverse permittivity values (1/\u03b5\u1d63) - Dictionary with additional information</p> Source code in <code>src/fdtdx/objects/material.py</code> <pre><code>def get_inv_permittivity(\n    self,\n    prev_inv_permittivity: jax.Array,\n    params: dict[str, jax.Array] | None,\n) -&gt; tuple[jax.Array, dict]:  # permittivity and info dict\n    \"\"\"Calculate inverse permittivity for this material's volume.\n\n    Args:\n        prev_inv_permittivity: Previous inverse permittivity values\n        params: Optional parameters for permittivity calculation\n\n    Returns:\n        tuple containing:\n            - Array of inverse permittivity values (1/\u03b5\u1d63)\n            - Dictionary with additional information\n    \"\"\"\n    del params\n    res = jnp.ones_like(prev_inv_permittivity) / self.permittivity\n    return res, {}\n</code></pre>"},{"location":"api/objects/materials/#fdtdx.objects.material.NoMaterial","title":"<code>fdtdx.objects.material.NoMaterial</code>","text":"<p>               Bases: <code>SimulationObject</code></p> <p>Object that does not modify the permittivity nor permeability</p> Source code in <code>src/fdtdx/objects/material.py</code> <pre><code>@tc.autoinit\nclass NoMaterial(SimulationObject):\n    \"\"\"\n    Object that does not modify the permittivity nor permeability\n    \"\"\"\n\n    placement_order: int = -1000\n\n    def get_inv_permittivity(\n        self,\n        prev_inv_permittivity: jax.Array,\n        params: dict[str, jax.Array] | None,\n    ) -&gt; tuple[jax.Array, dict]:  # permittivity and info dict\n        del params\n        return prev_inv_permittivity, {}\n\n    def get_inv_permeability(\n        self,\n        prev_inv_permeability: jax.Array,\n        params: dict[str, jax.Array] | None,\n    ) -&gt; tuple[jax.Array, dict]:  # permeability and info dict\n        del params\n        return prev_inv_permeability, {}\n</code></pre>"},{"location":"api/objects/materials/#fdtdx.objects.material.SimulationVolume","title":"<code>fdtdx.objects.material.SimulationVolume</code>","text":"<p>               Bases: <code>UniformMaterial</code></p> <p>Background material for the entire simulation volume.</p> <p>Defines the default material properties for the simulation background. Usually represents air/vacuum with \u03b5\u1d63=1.0 and \u03bc\u1d63=1.0.</p> Source code in <code>src/fdtdx/objects/material.py</code> <pre><code>@tc.autoinit\nclass SimulationVolume(UniformMaterial):\n    \"\"\"Background material for the entire simulation volume.\n\n    Defines the default material properties for the simulation background.\n    Usually represents air/vacuum with \u03b5\u1d63=1.0 and \u03bc\u1d63=1.0.\n    \"\"\"\n\n    permittivity: float = tc.field(default=1.0, init=True, kind=\"KW_ONLY\")  # type: ignore\n    permeability: float = tc.field(default=1.0, init=True, kind=\"KW_ONLY\")  # type: ignore\n</code></pre>"},{"location":"api/objects/materials/#fdtdx.objects.material.Substrate","title":"<code>fdtdx.objects.material.Substrate</code>","text":"<p>               Bases: <code>UniformMaterial</code></p> <p>Material representing a substrate layer.</p> <p>Used to model substrate materials like silicon dioxide. Visualized in light brown color by default.</p> Source code in <code>src/fdtdx/objects/material.py</code> <pre><code>@extended_autoinit\nclass Substrate(UniformMaterial):\n    \"\"\"Material representing a substrate layer.\n\n    Used to model substrate materials like silicon dioxide.\n    Visualized in light brown color by default.\n    \"\"\"\n\n    color: tuple[float, float, float] = LIGHT_BROWN\n</code></pre>"},{"location":"api/objects/materials/#fdtdx.objects.material.WaveGuide","title":"<code>fdtdx.objects.material.WaveGuide</code>","text":"<p>               Bases: <code>UniformMaterial</code></p> <p>Material for optical waveguides.</p> <p>Used to model waveguide structures that can guide electromagnetic waves. Visualized in light blue color by default.</p> <p>Attributes:</p> Name Type Description <code>permittivity</code> <code>float</code> <p>Required relative permittivity of the waveguide material</p> <code>color</code> <code>tuple[float, float, float]</code> <p>RGB tuple for visualization, defaults to light blue</p> Source code in <code>src/fdtdx/objects/material.py</code> <pre><code>@tc.autoinit\nclass WaveGuide(UniformMaterial):\n    \"\"\"Material for optical waveguides.\n\n    Used to model waveguide structures that can guide electromagnetic waves.\n    Visualized in light blue color by default.\n\n    Attributes:\n        permittivity: Required relative permittivity of the waveguide material\n        color: RGB tuple for visualization, defaults to light blue\n    \"\"\"\n\n    permittivity: float = tc.field(init=True, kind=\"KW_ONLY\")  # type: ignore\n    color: tuple[float, float, float] = LIGHT_BLUE\n</code></pre>"},{"location":"api/physics/","title":"Physics","text":"<p>This section covers the physical aspects of electromagnetic simulations in FDTDX, including:</p> <ul> <li>Constants and Material Properties - Physical constants and material property definitions</li> <li>Field and Efficiency Metrics - Functions for computing field metrics and efficiencies</li> <li>Electromagnetic Modes - Mode types and solvers</li> </ul>"},{"location":"api/physics/constants/","title":"Constants and Material Properties","text":""},{"location":"api/physics/constants/#physical-constants","title":"Physical Constants","text":""},{"location":"api/physics/constants/#fdtdx.core.physics.constants.c","title":"<code>fdtdx.core.physics.constants.c: float = 299792458.0</code>  <code>module-attribute</code>","text":"<p>Speed of light in vacuum (m/s).</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.mu0","title":"<code>fdtdx.core.physics.constants.mu0: float = 4e-07 * math.pi</code>  <code>module-attribute</code>","text":"<p>Vacuum permeability (H/m).</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.eps0","title":"<code>fdtdx.core.physics.constants.eps0: float = 1.0 / mu0 * c ** 2</code>  <code>module-attribute</code>","text":"<p>Vacuum permittivity (F/m).</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.eta0","title":"<code>fdtdx.core.physics.constants.eta0: float = mu0 * c</code>  <code>module-attribute</code>","text":"<p>Free space impedance (\u03a9).</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.wavelength_to_period","title":"<code>fdtdx.core.physics.constants.wavelength_to_period(wavelength)</code>","text":"<p>Convert wavelength to time period using speed of light.</p> <p>Uses the speed of light constant to calculate the corresponding time period for a given wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float</code> <p>The wavelength in meters.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The corresponding time period in seconds.</p> Source code in <code>src/fdtdx/core/physics/constants.py</code> <pre><code>def wavelength_to_period(wavelength: float) -&gt; float:\n    \"\"\"Convert wavelength to time period using speed of light.\n\n    Uses the speed of light constant to calculate the corresponding time period\n    for a given wavelength.\n\n    Args:\n        wavelength: The wavelength in meters.\n\n    Returns:\n        float: The corresponding time period in seconds.\n    \"\"\"\n    return wavelength / c\n</code></pre>"},{"location":"api/physics/constants/#material-properties","title":"Material Properties","text":""},{"location":"api/physics/constants/#fdtdx.core.physics.constants.relative_permittivity_air","title":"<code>fdtdx.core.physics.constants.relative_permittivity_air: float = 1.0</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of air.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.relative_permittivity_substrate","title":"<code>fdtdx.core.physics.constants.relative_permittivity_substrate: float = 2.1025</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of standard substrate material.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.relative_permittivity_polymer","title":"<code>fdtdx.core.physics.constants.relative_permittivity_polymer: float = 2.368521</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of standard polymer material.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.relative_permittivity_silicon","title":"<code>fdtdx.core.physics.constants.relative_permittivity_silicon: float = 12.25</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of silicon.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.relative_permittivity_silica","title":"<code>fdtdx.core.physics.constants.relative_permittivity_silica: float = 2.25</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of silica.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.relative_permittivity_SZ_2080","title":"<code>fdtdx.core.physics.constants.relative_permittivity_SZ_2080: float = 2.1786</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of SZ2080 photoresist.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.relative_permittivity_ma_N_1400_series","title":"<code>fdtdx.core.physics.constants.relative_permittivity_ma_N_1400_series: float = 2.6326</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of ma-N 1400 series photoresist.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.relative_permittivity_bacteria","title":"<code>fdtdx.core.physics.constants.relative_permittivity_bacteria: float = 1.96</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of bacteria.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.relative_permittivity_water","title":"<code>fdtdx.core.physics.constants.relative_permittivity_water: float = 1.737</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of water.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.relative_permittivity_fused_silica","title":"<code>fdtdx.core.physics.constants.relative_permittivity_fused_silica: float = 2.13685924</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of fused silica.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.relative_permittivity_coated_silica","title":"<code>fdtdx.core.physics.constants.relative_permittivity_coated_silica: float = 1.69</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of coated silica.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.relative_permittivity_resin","title":"<code>fdtdx.core.physics.constants.relative_permittivity_resin: float = 2.202256</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of standard resin.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.relative_permittivity_ormo_prime","title":"<code>fdtdx.core.physics.constants.relative_permittivity_ormo_prime: float = 1.817104</code>  <code>module-attribute</code>","text":"<p>Relative permittivity of Ormocer primer.</p>"},{"location":"api/physics/constants/#material-configurations","title":"Material Configurations","text":""},{"location":"api/physics/constants/#fdtdx.core.physics.constants.silicon_permittivity_config","title":"<code>fdtdx.core.physics.constants.silicon_permittivity_config: tuple[tuple[str, float], ...] = (('Si', relative_permittivity_silicon), ('Air', relative_permittivity_air))</code>  <code>module-attribute</code>","text":"<p>Standard configuration for silicon-air simulations.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.standard_permittivity_config","title":"<code>fdtdx.core.physics.constants.standard_permittivity_config: tuple[tuple[str, float], ...] = (('SZ2080', relative_permittivity_SZ_2080), ('Air', relative_permittivity_air))</code>  <code>module-attribute</code>","text":"<p>Standard configuration using SZ2080 photoresist.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.higher_permittivity_config","title":"<code>fdtdx.core.physics.constants.higher_permittivity_config: tuple[tuple[str, float], ...] = (('ma-N 1400', relative_permittivity_ma_N_1400_series), ('Air', relative_permittivity_air))</code>  <code>module-attribute</code>","text":"<p>Configuration using higher permittivity ma-N 1400 photoresist.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.silica_permittivity_config","title":"<code>fdtdx.core.physics.constants.silica_permittivity_config: tuple[tuple[str, float], ...] = (('Polymer', relative_permittivity_silica), ('Air', relative_permittivity_air))</code>  <code>module-attribute</code>","text":"<p>Standard configuration for silica-based simulations.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.multi_material_permittivity_config","title":"<code>fdtdx.core.physics.constants.multi_material_permittivity_config: tuple[tuple[str, float], ...] = (('ma-N 1400', relative_permittivity_ma_N_1400_series), ('SZ2080', relative_permittivity_SZ_2080), ('Air', relative_permittivity_air))</code>  <code>module-attribute</code>","text":"<p>Configuration for multi-material simulations using both photoresists.</p>"},{"location":"api/physics/constants/#fdtdx.core.physics.constants.multi_material_qd_permittivity_config","title":"<code>fdtdx.core.physics.constants.multi_material_qd_permittivity_config: tuple[tuple[str, float], ...] = (('SZ2080', relative_permittivity_resin), ('SZ2080+q', relative_permittivity_resin + 0.01), ('Air', relative_permittivity_air))</code>  <code>module-attribute</code>","text":"<p>Configuration for quantum dot enhanced resin simulations.</p>"},{"location":"api/physics/metrics/","title":"Field and Efficiency Metrics","text":""},{"location":"api/physics/metrics/#field-metrics","title":"Field Metrics","text":""},{"location":"api/physics/metrics/#fdtdx.core.physics.metrics.compute_energy","title":"<code>fdtdx.core.physics.metrics.compute_energy(E, H, inv_permittivity, inv_permeability)</code>","text":"<p>Computes the total electromagnetic energy density of the field.</p> <p>Parameters:</p> Name Type Description Default <code>E</code> <code>Array</code> <p>Electric field array with shape (3, nx, ny, nz)</p> required <code>H</code> <code>Array</code> <p>Magnetic field array with shape (3, nx, ny, nz)</p> required <code>inv_permittivity</code> <code>Array</code> <p>Inverse of the electric permittivity array</p> required <code>inv_permeability</code> <code>Array</code> <p>Inverse of the magnetic permeability array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Total energy density array with shape (nx, ny, nz)</p> Source code in <code>src/fdtdx/core/physics/metrics.py</code> <pre><code>def compute_energy(\n    E: jax.Array,\n    H: jax.Array,\n    inv_permittivity: jax.Array,\n    inv_permeability: jax.Array,\n) -&gt; jax.Array:\n    \"\"\"Computes the total electromagnetic energy density of the field.\n\n    Args:\n        E: Electric field array with shape (3, nx, ny, nz)\n        H: Magnetic field array with shape (3, nx, ny, nz)\n        inv_permittivity: Inverse of the electric permittivity array\n        inv_permeability: Inverse of the magnetic permeability array\n\n    Returns:\n        Total energy density array with shape (nx, ny, nz)\n    \"\"\"\n    abs_E = jnp.sum(jnp.square(E), axis=0)\n    energy_E = 0.5 * (1 / inv_permittivity) * abs_E\n\n    abs_H = jnp.sum(jnp.square(H), axis=0)\n    energy_H = 0.5 * (1 / inv_permeability) * abs_H\n\n    total_energy = energy_E + energy_H\n    return total_energy\n</code></pre>"},{"location":"api/physics/metrics/#fdtdx.core.physics.metrics.normalize_by_energy","title":"<code>fdtdx.core.physics.metrics.normalize_by_energy(E, H, inv_permittivity, inv_permeability)</code>","text":"<p>Normalizes electromagnetic fields by their total energy.</p> <p>Parameters:</p> Name Type Description Default <code>E</code> <code>Array</code> <p>Electric field array with shape (3, nx, ny, nz)</p> required <code>H</code> <code>Array</code> <p>Magnetic field array with shape (3, nx, ny, nz)</p> required <code>inv_permittivity</code> <code>Array</code> <p>Inverse of the electric permittivity array</p> required <code>inv_permeability</code> <code>Array</code> <p>Inverse of the magnetic permeability array</p> required <p>Returns:</p> Type Description <code>tuple[Array, Array]</code> <p>Tuple of (normalized E field, normalized H field)</p> Source code in <code>src/fdtdx/core/physics/metrics.py</code> <pre><code>def normalize_by_energy(\n    E: jax.Array,\n    H: jax.Array,\n    inv_permittivity: jax.Array,\n    inv_permeability: jax.Array,\n) -&gt; tuple[jax.Array, jax.Array]:\n    \"\"\"Normalizes electromagnetic fields by their total energy.\n\n    Args:\n        E: Electric field array with shape (3, nx, ny, nz)\n        H: Magnetic field array with shape (3, nx, ny, nz)\n        inv_permittivity: Inverse of the electric permittivity array\n        inv_permeability: Inverse of the magnetic permeability array\n\n    Returns:\n        Tuple of (normalized E field, normalized H field)\n    \"\"\"\n    total_energy = compute_energy(\n        E=E,\n        H=H,\n        inv_permittivity=inv_permittivity,\n        inv_permeability=inv_permeability,\n    )\n    energy_root = jnp.sqrt(jnp.sum(total_energy))\n    norm_E = E / energy_root\n    norm_H = H / energy_root\n    return norm_E, norm_H\n</code></pre>"},{"location":"api/physics/metrics/#fdtdx.core.physics.metrics.poynting_flux","title":"<code>fdtdx.core.physics.metrics.poynting_flux(E, H)</code>","text":"<p>Calculates the Poynting vector (energy flux) from E and H fields.</p> <p>Parameters:</p> Name Type Description Default <code>E</code> <code>Array</code> <p>Electric field array with shape (3, nx, ny, nz)</p> required <code>H</code> <code>Array</code> <p>Magnetic field array with shape (3, nx, ny, nz)</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Poynting vector array with shape (3, nx, ny, nz) representing</p> <code>Array</code> <p>energy flux in each direction</p> Source code in <code>src/fdtdx/core/physics/metrics.py</code> <pre><code>def poynting_flux(E: jax.Array, H: jax.Array) -&gt; jax.Array:\n    \"\"\"Calculates the Poynting vector (energy flux) from E and H fields.\n\n    Args:\n        E: Electric field array with shape (3, nx, ny, nz)\n        H: Magnetic field array with shape (3, nx, ny, nz)\n\n    Returns:\n        Poynting vector array with shape (3, nx, ny, nz) representing\n        energy flux in each direction\n    \"\"\"\n    return jnp.cross(\n        jnp.conj(E),\n        H,\n        axisa=0,\n        axisb=0,\n        axisc=0,\n    )\n</code></pre>"},{"location":"api/physics/metrics/#efficiency-metrics","title":"Efficiency Metrics","text":""},{"location":"api/physics/metrics/#fdtdx.core.physics.losses.metric_efficiency","title":"<code>fdtdx.core.physics.losses.metric_efficiency(detector_states, in_names, out_names, metric_name)</code>","text":"<p>Calculate efficiency metrics between input and output detectors.</p> <p>Computes efficiency ratios between input and output detectors by comparing their metric values (e.g. energy, power). For each input-output detector pair, calculates the ratio of output/input metric values.</p> <p>Parameters:</p> Name Type Description Default <code>detector_states</code> <code>dict[str, dict[str, Array]]</code> <p>Dictionary mapping detector names to their state dictionaries, which contain metric values as JAX arrays</p> required <code>in_names</code> <code>Sequence[str]</code> <p>Names of input detectors to use as reference</p> required <code>out_names</code> <code>Sequence[str]</code> <p>Names of output detectors to compare against inputs</p> required <code>metric_name</code> <code>str</code> <p>Name of the metric to compare between detectors (e.g. \"energy\")</p> required <p>Returns:</p> Type Description <code>tuple[Array, dict[str, Any]]</code> <p>tuple containing: - jax.Array: Mean efficiency across all input-output pairs - dict: Additional info including individual metric values and efficiencies   with keys like:     \"{detector}{metric}\" for raw metric values     \"{out}{by}_{in}_efficiency\" for individual efficiency ratios</p> Source code in <code>src/fdtdx/core/physics/losses.py</code> <pre><code>def metric_efficiency(\n    detector_states: dict[str, dict[str, jax.Array]],\n    in_names: Sequence[str],\n    out_names: Sequence[str],\n    metric_name: str,\n) -&gt; tuple[jax.Array, dict[str, Any]]:\n    \"\"\"Calculate efficiency metrics between input and output detectors.\n\n    Computes efficiency ratios between input and output detectors by comparing their\n    metric values (e.g. energy, power). For each input-output detector pair, calculates\n    the ratio of output/input metric values.\n\n    Args:\n        detector_states: Dictionary mapping detector names to their state dictionaries,\n            which contain metric values as JAX arrays\n        in_names: Names of input detectors to use as reference\n        out_names: Names of output detectors to compare against inputs\n        metric_name: Name of the metric to compare between detectors (e.g. \"energy\")\n\n    Returns:\n        tuple containing:\n            - jax.Array: Mean efficiency across all input-output pairs\n            - dict: Additional info including individual metric values and efficiencies\n              with keys like:\n                \"{detector}_{metric}\" for raw metric values\n                \"{out}_{by}_{in}_efficiency\" for individual efficiency ratios\n    \"\"\"\n    efficiencies, info = [], {}\n    for in_name in in_names:\n        in_value = jax.lax.stop_gradient(detector_states[in_name][metric_name].mean())\n        info[f\"{in_name}_{metric_name}\"] = in_value\n        for out_name in out_names:\n            out_value = detector_states[out_name][metric_name].mean()\n            eff = jnp.where(in_value == 0, 0, out_value / in_value)\n            efficiencies.append(eff)\n            info[f\"{out_name}_{metric_name}\"] = out_value\n            info[f\"{out_name}_by_{in_name}_efficiency\"] = eff\n    objective = jnp.mean(jnp.asarray(efficiencies))\n    return objective, info\n</code></pre>"},{"location":"api/physics/modes/","title":"Electromagnetic Modes","text":""},{"location":"api/physics/modes/#mode-types","title":"Mode Types","text":""},{"location":"api/physics/modes/#fdtdx.core.modes.ModeTupleType","title":"<code>fdtdx.core.modes.ModeTupleType = namedtuple('Mode', ['neff', 'Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz'])</code>  <code>module-attribute</code>","text":"<p>A named tuple representing an electromagnetic mode.</p> <p>Attributes:</p> Name Type Description <code>neff</code> <p>Complex effective refractive index of the mode</p> <code>Ex</code> <p>X component of the electric field</p> <code>Ey</code> <p>Y component of the electric field</p> <code>Ez</code> <p>Z component of the electric field</p> <code>Hx</code> <p>X component of the magnetic field</p> <code>Hy</code> <p>Y component of the magnetic field</p> <code>Hz</code> <p>Z component of the magnetic field</p>"},{"location":"api/physics/modes/#mode-solvers","title":"Mode Solvers","text":""},{"location":"api/physics/modes/#fdtdx.core.physics.modes.compute_modes","title":"<code>fdtdx.core.physics.modes.compute_modes(frequency, permittivity_cross_section, coords, direction, target_neff=None, angle_theta=0.0, angle_phi=0.0, num_modes=10, precision='double', filter_pol=None)</code>","text":"<p>Compute optical modes of a waveguide cross-section.</p> <p>This function uses the Tidy3D mode solver to compute the optical modes of a given waveguide cross-section defined by its permittivity distribution.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>Operating frequency in Hz</p> required <code>permittivity_cross_section</code> <code>ndarray</code> <p>2D array of relative permittivity values</p> required <code>coords</code> <code>List[ndarray]</code> <p>List of coordinate arrays [x, y] defining the grid</p> required <code>direction</code> <code>Literal['+', '-']</code> <p>Propagation direction, either \"+\" or \"-\"</p> required <code>target_neff</code> <code>float | None</code> <p>Target effective index to search around. Defaults to None.</p> <code>None</code> <code>angle_theta</code> <code>float</code> <p>Polar angle in radians. Defaults to 0.0.</p> <code>0.0</code> <code>angle_phi</code> <code>float</code> <p>Azimuthal angle in radians. Defaults to 0.0.</p> <code>0.0</code> <code>num_modes</code> <code>int</code> <p>Number of modes to compute. Defaults to 10.</p> <code>10</code> <code>precision</code> <code>Literal['single', 'double']</code> <p>Numerical precision. Defaults to \"double\".</p> <code>'double'</code> <code>filter_pol</code> <code>Literal['te', 'tm'] | None</code> <p>Mode polarization filter. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[ModeTupleType]</code> <p>List[ModeTupleType]: List of computed modes sorted by decreasing real part of effective index. Each mode contains the field components and effective index.</p> Source code in <code>src/fdtdx/core/physics/modes.py</code> <pre><code>def compute_modes(\n    frequency: float,\n    permittivity_cross_section: np.ndarray,\n    coords: List[np.ndarray],\n    direction: Literal[\"+\", \"-\"],\n    target_neff: float | None = None,\n    angle_theta: float = 0.0,\n    angle_phi: float = 0.0,\n    num_modes: int = 10,\n    precision: Literal[\"single\", \"double\"] = \"double\",\n    filter_pol: Literal[\"te\", \"tm\"] | None = None,\n) -&gt; List[ModeTupleType]:\n    \"\"\"Compute optical modes of a waveguide cross-section.\n\n    This function uses the Tidy3D mode solver to compute the optical modes of a given\n    waveguide cross-section defined by its permittivity distribution.\n\n    Args:\n        frequency (float): Operating frequency in Hz\n        permittivity_cross_section (np.ndarray): 2D array of relative permittivity values\n        coords (List[np.ndarray]): List of coordinate arrays [x, y] defining the grid\n        direction (Literal[\"+\", \"-\"]): Propagation direction, either \"+\" or \"-\"\n        target_neff (float | None, optional): Target effective index to search around. Defaults to None.\n        angle_theta (float, optional): Polar angle in radians. Defaults to 0.0.\n        angle_phi (float, optional): Azimuthal angle in radians. Defaults to 0.0.\n        num_modes (int, optional): Number of modes to compute. Defaults to 10.\n        precision (Literal[\"single\", \"double\"], optional): Numerical precision. Defaults to \"double\".\n        filter_pol (Literal[\"te\", \"tm\"] | None, optional): Mode polarization filter. Defaults to None.\n\n    Returns:\n        List[ModeTupleType]: List of computed modes sorted by decreasing real part of\n            effective index. Each mode contains the field components and effective index.\n    \"\"\"\n    # see https://docs.flexcompute.com/projects/tidy3d/en/latest/_autosummary/tidy3d.ModeSpec.html#tidy3d.ModeSpec\n    mode_spec = SimpleNamespace(\n        num_modes=num_modes,\n        target_neff=target_neff,\n        num_pml=(0, 0),\n        filter_pol=filter_pol,\n        angle_theta=angle_theta,\n        angle_phi=angle_phi,\n        bend_radius=None,\n        bend_axis=None,\n        precision=precision,\n        track_freq=\"central\",\n        group_index_step=False,\n    )\n    od = np.zeros_like(permittivity_cross_section)\n    eps_cross = [\n        permittivity_cross_section,\n        od,\n        od,\n        od,\n        permittivity_cross_section,\n        od,\n        od,\n        od,\n        permittivity_cross_section,\n    ]\n\n    EH, neffs, _ = _compute_modes(\n        eps_cross=eps_cross,\n        coords=coords,\n        freq=frequency,\n        # freq=tidy3d.C_0 / (wavelength / 1e-6),\n        mode_spec=mode_spec,\n        direction=direction,\n    )\n    ((Ex, Ey, Ez), (Hx, Hy, Hz)) = EH.squeeze()\n\n    if num_modes == 1:\n        modes = [\n            ModeTupleType(\n                Ex=Ex,\n                Ey=Ey,\n                Ez=Ez,\n                Hx=Hx,\n                Hy=Hy,\n                Hz=Hz,\n                neff=float(neffs.real) + 1j * float(neffs.imag),\n            )\n            for _ in range(num_modes)\n        ]\n    else:\n        modes = [\n            ModeTupleType(\n                Ex=Ex[..., i],\n                Ey=Ey[..., i],\n                Ez=Ez[..., i],\n                Hx=Hx[..., i],\n                Hy=Hy[..., i],\n                Hz=Hz[..., i],\n                neff=neffs[i],\n            )\n            for i in range(num_modes)\n        ]\n    modes = sorted(modes, key=lambda m: float(np.real(m.neff)), reverse=True)\n    return modes\n</code></pre>"},{"location":"api/utils/","title":"Utilities","text":"<p>This section covers various utility functions in FDTDX, including:</p> <ul> <li>Image Processing - Image processing and filtering functions</li> <li>Visualization - Plotting and visualization tools</li> <li>File Conversion - File format conversion utilities</li> </ul>"},{"location":"api/utils/conversion/","title":"File Conversion","text":""},{"location":"api/utils/conversion/#fdtdx.core.conversion.load_stl.load_stl","title":"<code>fdtdx.core.conversion.load_stl.load_stl(stl, permittivity, target_shape, voxel_size, ambient_permittivity=1.0)</code>","text":"<p>Loads an STL file and converts it to a voxelized permittivity array.</p> <p>This function takes either an STL file path or a trimesh.Trimesh object, voxelizes it at the specified resolution, and converts it to a permittivity array where voxels inside the mesh have the specified permittivity value and voxels outside have the ambient permittivity value.</p> <p>Parameters:</p> Name Type Description Default <code>stl</code> <code>str | Trimesh</code> <p>Path to an STL file or a trimesh.Trimesh object containing the mesh</p> required <code>permittivity</code> <code>float</code> <p>Relative permittivity value for the object</p> required <code>target_shape</code> <code>tuple[int, int, int]</code> <p>Desired output shape as (nx, ny, nz)</p> required <code>voxel_size</code> <code>float</code> <p>Size of each voxel in the initial voxelization</p> required <code>ambient_permittivity</code> <code>float</code> <p>Relative permittivity value for the surrounding medium (default: 1.0)</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: 4D array of shape (nx, ny, nz, 3) containing the permittivity values, where the last dimension represents the permittivity for each spatial direction</p> Source code in <code>src/fdtdx/core/conversion/load_stl.py</code> <pre><code>def load_stl(\n    stl: str | trimesh.Trimesh,\n    permittivity: float,\n    target_shape: tuple[int, int, int],\n    voxel_size: float,\n    ambient_permittivity: float = 1.0,\n) -&gt; jax.Array:\n    \"\"\"Loads an STL file and converts it to a voxelized permittivity array.\n\n    This function takes either an STL file path or a trimesh.Trimesh object,\n    voxelizes it at the specified resolution, and converts it to a permittivity\n    array where voxels inside the mesh have the specified permittivity value\n    and voxels outside have the ambient permittivity value.\n\n    Args:\n        stl: Path to an STL file or a trimesh.Trimesh object containing the mesh\n        permittivity: Relative permittivity value for the object\n        target_shape: Desired output shape as (nx, ny, nz)\n        voxel_size: Size of each voxel in the initial voxelization\n        ambient_permittivity: Relative permittivity value for the surrounding medium (default: 1.0)\n\n    Returns:\n        jax.Array: 4D array of shape (nx, ny, nz, 3) containing the permittivity values,\n            where the last dimension represents the permittivity for each spatial direction\n    \"\"\"\n    if isinstance(stl, str):\n        your_mesh: trimesh.Trimesh = trimesh.load_mesh(stl)  # type: ignore\n    else:\n        your_mesh = stl\n\n    mesh_voxel = your_mesh.voxelized(voxel_size).fill()\n\n    occupancy_array = mesh_voxel.encoding.dense\n\n    resized_occupancy_array = jax.image.resize(occupancy_array, target_shape, method=\"nearest\")\n\n    object_permittivity = jnp.where(resized_occupancy_array &gt; 0, permittivity, ambient_permittivity)\n\n    return jnp.tile(object_permittivity[..., jnp.newaxis], (1, 1, 1, 3))\n</code></pre>"},{"location":"api/utils/conversion/#fdtdx.core.conversion.export.export_stl","title":"<code>fdtdx.core.conversion.export.export_stl(matrix, stl_filename, voxel_grid_size=(1, 1, 1))</code>","text":"<p>Export a 3D boolean matrix to an STL file.</p> <p>Converts a 3D boolean matrix into a mesh representation and saves it as an STL file. True values in the matrix are converted to solid voxels in the output mesh.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>3D boolean numpy array representing the voxel grid.</p> required <code>stl_filename</code> <code>Path | str</code> <p>Output STL file path.</p> required <code>voxel_grid_size</code> <code>tuple[int, int, int]</code> <p>Physical size of each voxel as (x, y, z) integers. Defaults to (1, 1, 1).</p> <code>(1, 1, 1)</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If input matrix is not 3-dimensional.</p> Source code in <code>src/fdtdx/core/conversion/export.py</code> <pre><code>def export_stl(\n    matrix: np.ndarray,\n    stl_filename: Path | str,\n    voxel_grid_size: tuple[int, int, int] = (1, 1, 1),\n):\n    \"\"\"Export a 3D boolean matrix to an STL file.\n\n    Converts a 3D boolean matrix into a mesh representation and saves it as an STL file.\n    True values in the matrix are converted to solid voxels in the output mesh.\n\n    Args:\n        matrix: 3D boolean numpy array representing the voxel grid.\n        stl_filename: Output STL file path.\n        voxel_grid_size: Physical size of each voxel as (x, y, z) integers. Defaults to (1, 1, 1).\n\n    Raises:\n        Exception: If input matrix is not 3-dimensional.\n    \"\"\"\n    if matrix.ndim != 3:\n        raise Exception(f\"Invalid matrix shape: {matrix.shape}\")\n    scaling_factor = np.asarray(voxel_grid_size, dtype=int)\n\n    d0, d1, d2 = (\n        matrix.shape[0] + 1,\n        matrix.shape[1] + 1,\n        matrix.shape[2] + 1,\n    )\n    vertex_shape = (d0, d1, d2)\n    num_vertices = d0 * d1 * d2\n    num_voxels = math.prod(matrix.shape)\n\n    matrix_shape = (matrix.shape[0], matrix.shape[1], matrix.shape[2])\n    x, y, z = idx_to_xyz(np.arange(num_voxels), matrix_shape)\n    matrix_flat = matrix.reshape(-1)\n    stacked_idx = np.stack([x, y, z], axis=-1)\n\n    use_sides_arr = np.zeros((num_voxels, 6), dtype=bool)\n    use_sides_arr[matrix_flat &amp; (stacked_idx[..., 0] == 0), 0] = True  # left\n    use_sides_arr[matrix_flat &amp; (stacked_idx[..., 1] == 0), 1] = True  # front\n    use_sides_arr[matrix_flat &amp; (stacked_idx[..., 2] == 0), 2] = True  # bottom\n    use_sides_arr[matrix_flat &amp; (stacked_idx[..., 0] == matrix.shape[0] - 1), 3] = True  # right\n    use_sides_arr[matrix_flat &amp; (stacked_idx[..., 1] == matrix.shape[1] - 1), 4] = True  # back\n    use_sides_arr[matrix_flat &amp; (stacked_idx[..., 2] == matrix.shape[2] - 1), 5] = True  # top\n\n    inv_matrix = ~matrix\n    x_p1, y_p1, z_p1 = x + 1, y + 1, z + 1\n    x_p1[x_p1 == matrix.shape[0]] = matrix.shape[0] - 1\n    y_p1[y_p1 == matrix.shape[1]] = matrix.shape[1] - 1\n    z_p1[z_p1 == matrix.shape[2]] = matrix.shape[2] - 1\n\n    use_sides_arr[matrix_flat &amp; inv_matrix[x - 1, y, z], 0] = True  # left\n    use_sides_arr[matrix_flat &amp; inv_matrix[x, y - 1, z], 1] = True  # front\n    use_sides_arr[matrix_flat &amp; inv_matrix[x, y, z - 1], 2] = True  # bottom\n    use_sides_arr[matrix_flat &amp; inv_matrix[x_p1, y, z], 3] = True  # right\n    use_sides_arr[matrix_flat &amp; inv_matrix[x, y_p1, z], 4] = True  # back\n    use_sides_arr[matrix_flat &amp; inv_matrix[x, y, z_p1], 5] = True  # top\n\n    v_idx = np.asarray(\n        [\n            xyz_to_idx(x, y, z, shape=vertex_shape),\n            xyz_to_idx(x, y, z + 1, shape=vertex_shape),\n            xyz_to_idx(x, y + 1, z, shape=vertex_shape),\n            xyz_to_idx(x, y + 1, z + 1, shape=vertex_shape),\n            xyz_to_idx(x + 1, y, z, shape=vertex_shape),\n            xyz_to_idx(x + 1, y, z + 1, shape=vertex_shape),\n            xyz_to_idx(x + 1, y + 1, z, shape=vertex_shape),\n            xyz_to_idx(x + 1, y + 1, z + 1, shape=vertex_shape),\n        ]\n    )\n\n    faces_raw = np.asarray(\n        [\n            np.stack([[v_idx[0], v_idx[1], v_idx[2]], [v_idx[1], v_idx[3], v_idx[2]]], axis=-1),  # left\n            np.stack([[v_idx[0], v_idx[4], v_idx[5]], [v_idx[5], v_idx[1], v_idx[0]]], axis=-1),  # front\n            np.stack([[v_idx[0], v_idx[2], v_idx[6]], [v_idx[6], v_idx[4], v_idx[0]]], axis=-1),  # bottom\n            np.stack([[v_idx[4], v_idx[6], v_idx[7]], [v_idx[7], v_idx[5], v_idx[4]]], axis=-1),  # right\n            np.stack([[v_idx[2], v_idx[3], v_idx[7]], [v_idx[7], v_idx[6], v_idx[2]]], axis=-1),  # back\n            np.stack([[v_idx[1], v_idx[5], v_idx[3]], [v_idx[3], v_idx[5], v_idx[7]]], axis=-1),  # top\n        ]\n    )\n    faces_raw = faces_raw.transpose((2, 0, 3, 1))\n\n    # select used faces only\n    faces = faces_raw[use_sides_arr].reshape(-1, 3)\n    vertex_arr = np.stack(\n        idx_to_xyz(\n            np.arange(num_vertices),\n            shape=vertex_shape,\n        ),\n        axis=-1,\n    )\n    vertex_arr = vertex_arr * scaling_factor\n\n    # export to trimesh\n    mesh = trimesh.Trimesh(\n        vertices=vertex_arr,\n        faces=faces,\n        validate=False,\n    )\n    mesh.export(stl_filename)\n</code></pre>"},{"location":"api/utils/conversion/#fdtdx.core.conversion.export.idx_to_xyz","title":"<code>fdtdx.core.conversion.export.idx_to_xyz(idx, shape)</code>","text":"<p>Convert flattened array indices to 3D coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>ndarray</code> <p>Array of flattened indices.</p> required <code>shape</code> <code>tuple[int, int, int]</code> <p>3D shape tuple (d0, d1, d2) of the original array.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[ndarray, ndarray, ndarray]</code> <p>(x, y, z) coordinate arrays corresponding to the input indices.</p> Source code in <code>src/fdtdx/core/conversion/export.py</code> <pre><code>def idx_to_xyz(idx: np.ndarray, shape: tuple[int, int, int]) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Convert flattened array indices to 3D coordinates.\n\n    Args:\n        idx: Array of flattened indices.\n        shape: 3D shape tuple (d0, d1, d2) of the original array.\n\n    Returns:\n        tuple: (x, y, z) coordinate arrays corresponding to the input indices.\n    \"\"\"\n    _, d1, d2 = shape\n    x = idx // (d1 * d2)\n    y = (idx // d2) % d1\n    z = idx % d2\n    return x, y, z\n</code></pre>"},{"location":"api/utils/conversion/#fdtdx.core.conversion.export.xyz_to_idx","title":"<code>fdtdx.core.conversion.export.xyz_to_idx(x, y, z, shape)</code>","text":"<p>Convert 3D coordinates to flattened array indices.</p> <p>This is the inverse operation of idx_to_xyz(). Used for converting physical coordinates back to array indices.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Array of x coordinates.</p> required <code>y</code> <code>ndarray</code> <p>Array of y coordinates.</p> required <code>z</code> <code>ndarray</code> <p>Array of z coordinates.</p> required <code>shape</code> <code>tuple[int, int, int]</code> <p>3D shape tuple (d0, d1, d2) of the target array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Flattened indices corresponding to the input coordinates.</p> Source code in <code>src/fdtdx/core/conversion/export.py</code> <pre><code>def xyz_to_idx(\n    x: np.ndarray,\n    y: np.ndarray,\n    z: np.ndarray,\n    shape: tuple[int, int, int],\n) -&gt; np.ndarray:\n    \"\"\"Convert 3D coordinates to flattened array indices.\n\n    This is the inverse operation of idx_to_xyz(). Used for converting physical coordinates\n    back to array indices.\n\n    Args:\n        x: Array of x coordinates.\n        y: Array of y coordinates.\n        z: Array of z coordinates.\n        shape: 3D shape tuple (d0, d1, d2) of the target array.\n\n    Returns:\n        np.ndarray: Flattened indices corresponding to the input coordinates.\n    \"\"\"\n    \"\"\"Convert 3D coordinates to flattened array indices.\n\n    Args:\n        x: Array of x coordinates.\n        y: Array of y coordinates.\n        z: Array of z coordinates.\n        shape: 3D shape tuple (d0, d1, d2) of the target array.\n\n    Returns:\n        np.ndarray: Flattened indices corresponding to the input coordinates.\n    \"\"\"\n    _, d1, d2 = shape\n    return x * (d1 * d2) + y * (d2) + z\n</code></pre>"},{"location":"api/utils/conversion/#fdtdx.core.conversion.import_utils.gds_to_numpy","title":"<code>fdtdx.core.conversion.import_utils.gds_to_numpy(file_path, resolution, layer, datatype=None)</code>","text":"<p>Converts GDSII geometry on a specific layer to a grid-based mask.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str | Path</code> <p>Path to the GDSII file</p> required <code>resolution</code> <code>float</code> <p>The size of each grid cell in the same units as the GDSII coordinates</p> required <code>layer</code> <code>int</code> <p>The GDSII layer number to extract</p> required <code>datatype</code> <code>int | None</code> <p>The GDSII datatype number to extract. Defaults to layer value.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray[bool_]</code> <p>np.ndarray[np.bool_]: A 2D NumPy array mask where True indicates geometry presence</p> Source code in <code>src/fdtdx/core/conversion/import_utils.py</code> <pre><code>def gds_to_numpy(\n    file_path: str | Path,\n    resolution: float,\n    layer: int,\n    datatype: int | None = None,\n) -&gt; np.ndarray[np.bool_]:\n    \"\"\"\n    Converts GDSII geometry on a specific layer to a grid-based mask.\n\n    Args:\n        file_path: Path to the GDSII file\n        resolution: The size of each grid cell in the same units as the GDSII coordinates\n        layer: The GDSII layer number to extract\n        datatype: The GDSII datatype number to extract. Defaults to layer value.\n\n    Returns:\n        np.ndarray[np.bool_]: A 2D NumPy array mask where True indicates geometry presence\n    \"\"\"\n    if datatype is None:\n        datatype = layer\n    gdsii_lib = gdspy.GdsLibrary()\n    gdsii_lib.read_gds(file_path)\n\n    cell = gdsii_lib.top_level()[0]  # Assuming one top-level cell\n\n    # Determine bounding box for grid dimensions\n    bbox = cell.get_bounding_box()\n    x_min, y_min, x_max, y_max = bbox[0][0], bbox[0][1], bbox[1][0], bbox[1][1]\n\n    # Create grid coordinates\n    x_coords = np.arange(x_min, x_max + resolution, resolution)\n    y_coords = np.arange(y_min, y_max + resolution, resolution)\n    grid_x, grid_y = np.meshgrid(x_coords, y_coords)\n\n    # Check each grid point for geometry presence\n    polygons = cell.get_polygons(by_spec=(layer, datatype))\n    points = np.stack([grid_x, grid_y], axis=-1).reshape(-1, 2)\n    result_bool_list = gdspy.inside(\n        points=points,\n        polygons=polygons,\n    )\n    mask = np.asarray(result_bool_list).reshape(grid_x.shape).T\n    return mask\n</code></pre>"},{"location":"api/utils/image/","title":"Image Processing","text":""},{"location":"api/utils/image/#fdtdx.core.gaussian_blur.gaussian_blur_3d","title":"<code>fdtdx.core.gaussian_blur.gaussian_blur_3d(image, sigma, kernel_size, *, padding='SAME', channel_axis=-1)</code>","text":"<p>Applies 3D Gaussian blur by convolving the image with separable Gaussian kernels.</p> <p>This function implements an efficient 3D Gaussian blur by decomposing the 3D Gaussian kernel into three 1D kernels and applying them sequentially along each axis. This is mathematically equivalent to a full 3D convolution but much more computationally efficient.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Array</code> <p>The input image as a float tensor with values in [0,1]. Should have 4 or 5 dimensions: [batch?, depth, height, width, channels] or [batch?, channels, depth, height, width]. The batch dimension is optional.</p> required <code>sigma</code> <code>float</code> <p>Standard deviation (in pixels) of the Gaussian kernel. Controls the amount of blurring - larger values produce more blurring.</p> required <code>kernel_size</code> <code>float</code> <p>Size (in pixels) of the cubic Gaussian kernel. Will be rounded up to the nearest odd integer to ensure the kernel is symmetric. Should be at least 2 * ceil(3 * sigma) + 1 to avoid truncating the Gaussian significantly.</p> required <code>padding</code> <code>str</code> <p>Either \"SAME\" or \"VALID\". With \"SAME\" padding the output has the same spatial dimensions as the input. With \"VALID\" padding the output is smaller due to no padding being added.</p> <code>'SAME'</code> <code>channel_axis</code> <code>int</code> <p>The axis containing the channels in the input tensor. Use -1 for channels-last format (default) or 1 for channels-first format.</p> <code>-1</code> <p>Returns:</p> Type Description <code>Array</code> <p>jax.Array: The blurred image tensor with the same shape and data format as the input. With \"SAME\" padding the spatial dimensions match the input. With \"VALID\" padding they are reduced by (kernel_size - 1) in each dimension.</p> Source code in <code>src/fdtdx/core/gaussian_blur.py</code> <pre><code>def gaussian_blur_3d(\n    image: jax.Array,\n    sigma: float,\n    kernel_size: float,\n    *,\n    padding: str = \"SAME\",\n    channel_axis: int = -1,\n) -&gt; jax.Array:\n    \"\"\"Applies 3D Gaussian blur by convolving the image with separable Gaussian kernels.\n\n    This function implements an efficient 3D Gaussian blur by decomposing the 3D Gaussian\n    kernel into three 1D kernels and applying them sequentially along each axis. This is\n    mathematically equivalent to a full 3D convolution but much more computationally efficient.\n\n    Args:\n        image: The input image as a float tensor with values in [0,1]. Should have 4 or 5\n            dimensions: [batch?, depth, height, width, channels] or [batch?, channels, depth,\n            height, width]. The batch dimension is optional.\n        sigma: Standard deviation (in pixels) of the Gaussian kernel. Controls the amount\n            of blurring - larger values produce more blurring.\n        kernel_size: Size (in pixels) of the cubic Gaussian kernel. Will be rounded up to\n            the nearest odd integer to ensure the kernel is symmetric. Should be at least\n            2 * ceil(3 * sigma) + 1 to avoid truncating the Gaussian significantly.\n        padding: Either \"SAME\" or \"VALID\". With \"SAME\" padding the output has the same\n            spatial dimensions as the input. With \"VALID\" padding the output is smaller\n            due to no padding being added.\n        channel_axis: The axis containing the channels in the input tensor. Use -1 for\n            channels-last format (default) or 1 for channels-first format.\n\n    Returns:\n        jax.Array: The blurred image tensor with the same shape and data format as the input.\n            With \"SAME\" padding the spatial dimensions match the input. With \"VALID\" padding\n            they are reduced by (kernel_size - 1) in each dimension.\n    \"\"\"\n    chex.assert_rank(image, {4, 5})\n    data_format = \"NDHWC\" if _channels_last(image, channel_axis) else \"NCDHW\"\n    dimension_numbers = (data_format, \"DHWIO\", data_format)\n    num_channels = image.shape[channel_axis]\n    radius = int(kernel_size / 2)\n    kernel_size_ = 2 * radius + 1\n    x = jnp.arange(-radius, radius + 1).astype(image.dtype)\n    blur_filter = jnp.exp(-(x**2) / (2.0 * sigma**2))\n    blur_filter = blur_filter / jnp.sum(blur_filter)\n    blur_d = jnp.reshape(blur_filter, [kernel_size_, 1, 1, 1, 1])\n    blur_h = jnp.reshape(blur_filter, [1, kernel_size_, 1, 1, 1])\n    blur_w = jnp.reshape(blur_filter, [1, 1, kernel_size_, 1, 1])\n    blur_h = jnp.tile(blur_h, [1, 1, 1, 1, num_channels])\n    blur_w = jnp.tile(blur_w, [1, 1, 1, 1, num_channels])\n    blur_d = jnp.tile(blur_d, [1, 1, 1, 1, num_channels])\n\n    expand_batch_dim = image.ndim == 4\n    if expand_batch_dim:\n        image = image[jnp.newaxis, ...]\n    blurred = _depthwise_conv3d(\n        image,\n        kernel=blur_h,\n        strides=(1, 1, 1),\n        padding=padding,\n        channel_axis=channel_axis,\n        dimension_numbers=dimension_numbers,\n    )\n    blurred = _depthwise_conv3d(\n        blurred,\n        kernel=blur_w,\n        strides=(1, 1, 1),\n        padding=padding,\n        channel_axis=channel_axis,\n        dimension_numbers=dimension_numbers,\n    )\n    blurred = _depthwise_conv3d(\n        blurred,\n        kernel=blur_d,\n        strides=(1, 1, 1),\n        padding=padding,\n        channel_axis=channel_axis,\n        dimension_numbers=dimension_numbers,\n    )\n    if expand_batch_dim:\n        blurred = jnp.squeeze(blurred, axis=0)\n    return blurred\n</code></pre>"},{"location":"api/utils/visualization/","title":"Visualization","text":""},{"location":"api/utils/visualization/#fdtdx.core.plotting.device_permittivity_index_utils.index_matrix_to_str","title":"<code>fdtdx.core.plotting.device_permittivity_index_utils.index_matrix_to_str(indices)</code>","text":"<p>Converts a 2D matrix of indices to a formatted string representation.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>Array</code> <p>A 2D JAX array containing numerical indices.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the matrix where each row is space-separated</p> <code>str</code> <p>and rows are separated by newlines.</p> Source code in <code>src/fdtdx/core/plotting/device_permittivity_index_utils.py</code> <pre><code>def index_matrix_to_str(indices: jax.Array) -&gt; str:\n    \"\"\"Converts a 2D matrix of indices to a formatted string representation.\n\n    Args:\n        indices: A 2D JAX array containing numerical indices.\n\n    Returns:\n        A string representation of the matrix where each row is space-separated\n        and rows are separated by newlines.\n    \"\"\"\n    indices_str = \"\"\n    for i in range(indices.shape[0]):\n        for j in range(indices.shape[1]):\n            indices_str += str(indices[i, j].squeeze()) + \" \"\n        indices_str += \"\\n\"\n    return indices_str\n</code></pre>"},{"location":"api/utils/visualization/#fdtdx.core.plotting.device_permittivity_index_utils.device_matrix_index_figure","title":"<code>fdtdx.core.plotting.device_permittivity_index_utils.device_matrix_index_figure(device_matrix_indices, permittivity_configs)</code>","text":"<p>Creates a visualization figure of device matrix indices with permittivity configurations.</p> <p>Parameters:</p> Name Type Description Default <code>device_matrix_indices</code> <code>Array</code> <p>A 3D JAX array containing the device matrix indices. Shape should be (height, width, channels) where channels is typically 1.</p> required <code>permittivity_configs</code> <code>tuple[tuple[str, float], ...]</code> <p>A tuple of (name, value) pairs defining the permittivity configurations, where name is a string identifier (e.g., \"Air\") and value is the corresponding permittivity value.</p> required <p>Returns:</p> Type Description <code>Figure</code> <p>A matplotlib Figure object containing the visualization with:</p> <code>Figure</code> <ul> <li>A heatmap of the device matrix indices</li> </ul> <code>Figure</code> <ul> <li>Color-coded regions based on permittivity configurations</li> </ul> <code>Figure</code> <ul> <li>Optional text labels showing index values (for smaller matrices)</li> </ul> <code>Figure</code> <ul> <li>A legend mapping colors to permittivity configurations</li> </ul> <code>Figure</code> <ul> <li>Proper axis labels and grid settings</li> </ul> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If device_matrix_indices is not 3-dimensional.</p> Source code in <code>src/fdtdx/core/plotting/device_permittivity_index_utils.py</code> <pre><code>def device_matrix_index_figure(\n    device_matrix_indices: jax.Array,\n    permittivity_configs: tuple[tuple[str, float], ...],\n) -&gt; Figure:\n    \"\"\"Creates a visualization figure of device matrix indices with permittivity configurations.\n\n    Args:\n        device_matrix_indices: A 3D JAX array containing the device matrix indices.\n            Shape should be (height, width, channels) where channels is typically 1.\n        permittivity_configs: A tuple of (name, value) pairs defining the permittivity\n            configurations, where name is a string identifier (e.g., \"Air\") and value\n            is the corresponding permittivity value.\n\n    Returns:\n        A matplotlib Figure object containing the visualization with:\n        - A heatmap of the device matrix indices\n        - Color-coded regions based on permittivity configurations\n        - Optional text labels showing index values (for smaller matrices)\n        - A legend mapping colors to permittivity configurations\n        - Proper axis labels and grid settings\n\n    Raises:\n        AssertionError: If device_matrix_indices is not 3-dimensional.\n    \"\"\"\n    assert device_matrix_indices.ndim == 3\n    device_matrix_indices = device_matrix_indices.astype(np.int32)\n    fig, ax = cast(tuple[Figure, Axes], plt.subplots(figsize=(12, 12)))\n    image_palette = sns.color_palette(\"YlOrBr\", as_cmap=True)\n    if device_matrix_indices.shape[-1] == 1:\n        device_matrix_indices = device_matrix_indices[..., 0]\n        matrix_inverse_permittivity_indices_sorted = device_matrix_indices\n        indices = np.unique(device_matrix_indices)\n    else:\n        air_index = None\n        for i, cfg in enumerate(permittivity_configs):\n            if cfg[0] == \"Air\":\n                air_index = i\n                break\n        device_matrix_indices_flat = np.reshape(device_matrix_indices, (-1, device_matrix_indices.shape[-1]))\n        indices = np.unique(\n            device_matrix_indices_flat,\n            axis=0,\n        )\n        air_count = np.count_nonzero(indices == air_index, axis=-1)\n        air_count_argsort = np.argsort(air_count)\n        indices_sorted = indices[air_count_argsort]\n        matrix_inverse_permittivity_indices_sorted = np.array(\n            [\n                np.where((indices_sorted == device_matrix_indices_flat[i]).all(axis=1))[0][0]\n                for i in range(device_matrix_indices_flat.shape[0])\n            ]\n        ).reshape(device_matrix_indices.shape[:-1])\n\n    cax = ax.imshow(\n        matrix_inverse_permittivity_indices_sorted.T,\n        cmap=image_palette,\n        aspect=\"auto\",\n        origin=\"lower\",\n    )\n    ax.set_xlabel(\"X Axis\")\n    ax.set_ylabel(\"Y Axis\")\n    height, width = (\n        device_matrix_indices.shape[0],\n        device_matrix_indices.shape[1],\n    )\n    if height * width &lt; 1500:\n        for y in range(height):\n            for x in range(width):\n                value = matrix_inverse_permittivity_indices_sorted[x, y]\n                text_color = \"w\" if cax.norm(value) &gt; 0.5 else \"k\"  # type: ignore\n                ax.text(x, y, str(int(value)), ha=\"center\", va=\"center\", color=text_color)\n    assert cax.cmap is not None\n    if indices.ndim == 1:\n        legend_elements = [\n            Patch(\n                facecolor=cax.cmap(cax.norm(int(i))),\n                label=f\"({i}) {permittivity_configs[int(i)][0]}\",\n            )\n            for i in indices\n        ]\n    else:\n        legend_elements = [\n            Patch(\n                facecolor=cax.cmap(cax.norm(int(i))),\n                label=f\"({i}) \" + \"|\".join([permittivity_configs[int(e)][0] for e in indices[i]]),\n            )\n            for i in np.unique(matrix_inverse_permittivity_indices_sorted)\n        ]\n\n    legend_cols = max(1, int(len(legend_elements) / height))\n    if len(legend_elements) &lt; 100:\n        ax.legend(\n            handles=legend_elements,\n            loc=\"center left\",\n            frameon=False,\n            bbox_to_anchor=(1, 0.5),\n            ncols=legend_cols,\n        )\n    ax.set_aspect(\"equal\")\n    for line in ax.get_xgridlines() + ax.get_ygridlines():\n        line.set_alpha(0.0)\n    return fig\n</code></pre>"},{"location":"api/utils/visualization/#fdtdx.core.plotting.utils.plot_filled_std_curves","title":"<code>fdtdx.core.plotting.utils.plot_filled_std_curves(x, mean, color, lighter_color, std=None, upper=None, lower=None, linestyle='-', marker=None, label=None, alpha=0.2, min_val=None, max_val=None)</code>","text":"<p>Plots a curve with filled standard deviation or confidence intervals.</p> <p>Creates a plot showing a mean curve with a filled region representing either standard deviation bounds or custom upper/lower bounds. The filled region uses a lighter color with transparency.</p> <p>The function supports two modes: 1. Standard deviation mode: Provide std parameter to create bounds at mean \u00b1 std 2. Custom bounds mode: Provide explicit upper and lower bound arrays</p> <p>The plotted curves can be optionally clipped to minimum/maximum values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Array of x-axis values.</p> required <code>mean</code> <code>ndarray</code> <p>Array of y-axis values for the mean curve.</p> required <code>color</code> <code>Any</code> <p>Color for the mean curve line.</p> required <code>lighter_color</code> <code>Any</code> <p>Color for the filled standard deviation region.</p> required <code>std</code> <code>Optional[ndarray]</code> <p>Optional standard deviation array. If provided, used to compute upper/lower bounds.</p> <code>None</code> <code>upper</code> <code>Optional[ndarray]</code> <p>Optional array of upper bound values. Must be provided with lower.</p> <code>None</code> <code>lower</code> <code>Optional[ndarray]</code> <p>Optional array of lower bound values. Must be provided with upper.</p> <code>None</code> <code>linestyle</code> <code>str</code> <p>Style of the mean curve line. Defaults to solid line \"-\".</p> <code>'-'</code> <code>marker</code> <code>Optional[str]</code> <p>Optional marker style for data points on the mean curve.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional label for the plot legend.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Transparency value for the filled region. Defaults to 0.2.</p> <code>0.2</code> <code>min_val</code> <code>Optional[float]</code> <p>Optional minimum value to clip the curves.</p> <code>None</code> <code>max_val</code> <code>Optional[float]</code> <p>Optional maximum value to clip the curves.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither std nor both upper/lower bounds are provided, or if only one of upper/lower is provided.</p> Example <p>x = np.linspace(0, 10, 100) mean = np.sin(x) std = 0.1 * np.ones_like(x) plot_filled_std_curves(x, mean, 'blue', 'lightblue', std=std)</p> Source code in <code>src/fdtdx/core/plotting/utils.py</code> <pre><code>def plot_filled_std_curves(\n    x: np.ndarray,\n    mean: np.ndarray,\n    color: Any,\n    lighter_color: Any,\n    std: Optional[np.ndarray] = None,\n    upper: Optional[np.ndarray] = None,\n    lower: Optional[np.ndarray] = None,\n    linestyle: str = \"-\",\n    marker: Optional[str] = None,\n    label: Optional[str] = None,\n    alpha: float = 0.2,\n    min_val: Optional[float] = None,\n    max_val: Optional[float] = None,\n):\n    \"\"\"Plots a curve with filled standard deviation or confidence intervals.\n\n    Creates a plot showing a mean curve with a filled region representing either\n    standard deviation bounds or custom upper/lower bounds. The filled region uses\n    a lighter color with transparency.\n\n    The function supports two modes:\n    1. Standard deviation mode: Provide std parameter to create bounds at mean \u00b1 std\n    2. Custom bounds mode: Provide explicit upper and lower bound arrays\n\n    The plotted curves can be optionally clipped to minimum/maximum values.\n\n    Args:\n        x: Array of x-axis values.\n        mean: Array of y-axis values for the mean curve.\n        color: Color for the mean curve line.\n        lighter_color: Color for the filled standard deviation region.\n        std: Optional standard deviation array. If provided, used to compute upper/lower bounds.\n        upper: Optional array of upper bound values. Must be provided with lower.\n        lower: Optional array of lower bound values. Must be provided with upper.\n        linestyle: Style of the mean curve line. Defaults to solid line \"-\".\n        marker: Optional marker style for data points on the mean curve.\n        label: Optional label for the plot legend.\n        alpha: Transparency value for the filled region. Defaults to 0.2.\n        min_val: Optional minimum value to clip the curves.\n        max_val: Optional maximum value to clip the curves.\n\n    Raises:\n        ValueError: If neither std nor both upper/lower bounds are provided, or if only\n            one of upper/lower is provided.\n\n    Example:\n        &gt;&gt;&gt; x = np.linspace(0, 10, 100)\n        &gt;&gt;&gt; mean = np.sin(x)\n        &gt;&gt;&gt; std = 0.1 * np.ones_like(x)\n        &gt;&gt;&gt; plot_filled_std_curves(x, mean, 'blue', 'lightblue', std=std)\n    \"\"\"\n    if (upper is None) != (lower is None):\n        raise ValueError(\"Need to specify both upper and lower\")\n    if (std is None) == (upper is None):\n        raise ValueError(\"Need to specify either std or upper/lower\")\n    if std is not None:\n        upper = mean + std\n        lower = mean - std\n    if min_val is not None and lower is not None and upper is not None:\n        mean = np.maximum(mean, min_val)\n        lower = np.maximum(lower, min_val)\n        upper = np.maximum(upper, min_val)\n    if max_val is not None and lower is not None and upper is not None:\n        mean = np.minimum(mean, max_val)\n        upper = np.minimum(upper, max_val)\n        lower = np.minimum(lower, max_val)\n    if upper is None or lower is None:\n        raise Exception(\"This should never happen\")\n    plt.plot(x, upper, color=lighter_color, alpha=alpha)\n    plt.plot(x, lower, color=lighter_color, alpha=alpha)\n    plt.fill_between(x, lower, upper, color=lighter_color, alpha=alpha)\n    plt.plot(x, mean, color=color, label=label, linestyle=linestyle, marker=marker, markersize=4)\n</code></pre>"},{"location":"api/utils/visualization/#fdtdx.core.plotting.debug.generate_unique_filename","title":"<code>fdtdx.core.plotting.debug.generate_unique_filename(prefix='file', extension=None)</code>","text":"<p>Generate a unique filename using timestamp and UUID.</p>"},{"location":"api/utils/visualization/#fdtdx.core.plotting.debug.generate_unique_filename--parameters","title":"Parameters:","text":"<p>prefix : str, optional     Prefix for the filename extension : str, optional     File extension (without dot)</p>"},{"location":"api/utils/visualization/#fdtdx.core.plotting.debug.generate_unique_filename--returns","title":"Returns:","text":"<p>str : Unique filename</p> Source code in <code>src/fdtdx/core/plotting/debug.py</code> <pre><code>def generate_unique_filename(prefix=\"file\", extension=None):\n    \"\"\"\n    Generate a unique filename using timestamp and UUID.\n\n    Parameters:\n    -----------\n    prefix : str, optional\n        Prefix for the filename\n    extension : str, optional\n        File extension (without dot)\n\n    Returns:\n    --------\n    str : Unique filename\n    \"\"\"\n    # Get current timestamp\n    timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n\n    # Add a short UUID segment for extra uniqueness\n    unique_id = str(uuid.uuid4())[:8]\n\n    # Combine components\n    if extension:\n        return f\"{prefix}_{timestamp}_{unique_id}.{extension}\"\n    return f\"{prefix}_{timestamp}_{unique_id}\"\n</code></pre>"},{"location":"api/utils/visualization/#fdtdx.core.plotting.debug.debug_plot_2d","title":"<code>fdtdx.core.plotting.debug.debug_plot_2d(array, cmap='viridis', show_values=False, tmp_dir='outputs/tmp/debug', filename=None)</code>","text":"<p>Creates a debug visualization of a 2D array and saves it to disk.</p> <p>This function is useful for debugging array values during development and testing. It creates a heatmap visualization with optional value annotations and automatically saves it to a specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray | Array</code> <p>The 2D array to visualize. Can be either a numpy array or JAX array.</p> required <code>cmap</code> <code>str</code> <p>The matplotlib colormap to use for the visualization. Defaults to \"viridis\".</p> <code>'viridis'</code> <code>show_values</code> <code>bool</code> <p>If True, overlays the numerical values on each cell. Defaults to False.</p> <code>False</code> <code>tmp_dir</code> <code>str | Path</code> <p>Directory where the plot will be saved. Will be created if it doesn't exist. Defaults to \"outputs/tmp/debug\".</p> <code>'outputs/tmp/debug'</code> <code>filename</code> <code>str | None</code> <p>Name for the output file. If None, generates a unique name using timestamp. The .png extension will be added automatically.</p> <code>None</code> The resulting plot includes <ul> <li>A heatmap visualization of the array values</li> <li>A colorbar showing the value scale</li> <li>Grid lines for better readability</li> <li>Axis labels indicating array dimensions</li> <li>Optional numerical value annotations in each cell</li> </ul> Source code in <code>src/fdtdx/core/plotting/debug.py</code> <pre><code>def debug_plot_2d(\n    array: np.ndarray | jax.Array,\n    cmap: str = \"viridis\",\n    show_values: bool = False,\n    tmp_dir: str | Path = \"outputs/tmp/debug\",\n    filename: str | None = None,\n) -&gt; None:\n    \"\"\"Creates a debug visualization of a 2D array and saves it to disk.\n\n    This function is useful for debugging array values during development and testing.\n    It creates a heatmap visualization with optional value annotations and automatically\n    saves it to a specified directory.\n\n    Args:\n        array: The 2D array to visualize. Can be either a numpy array or JAX array.\n        cmap: The matplotlib colormap to use for the visualization. Defaults to \"viridis\".\n        show_values: If True, overlays the numerical values on each cell. Defaults to False.\n        tmp_dir: Directory where the plot will be saved. Will be created if it doesn't exist.\n            Defaults to \"outputs/tmp/debug\".\n        filename: Name for the output file. If None, generates a unique name using timestamp.\n            The .png extension will be added automatically.\n\n    The resulting plot includes:\n        - A heatmap visualization of the array values\n        - A colorbar showing the value scale\n        - Grid lines for better readability\n        - Axis labels indicating array dimensions\n        - Optional numerical value annotations in each cell\n    \"\"\"\n    if not isinstance(array, np.ndarray):\n        array = np.asarray(array)\n\n    if filename is None:\n        filename = generate_unique_filename(\"debug\", \"png\")\n\n    plt.figure(figsize=(10, 8))\n\n    # Create heatmap\n    im = plt.imshow(\n        array.T,\n        cmap=cmap,\n        origin=\"lower\",\n        aspect=\"equal\",\n    )\n\n    plt.colorbar(im)\n    plt.xlabel(\"First Array axis (x)\")\n    plt.ylabel(\"Second Array axis (y)\")\n\n    # Show values in cells if requested\n    if show_values:\n        for i in range(array.shape[0]):\n            for j in range(array.shape[1]):\n                text_color = \"white\" if im.norm(array[i, j]) &gt; 0.5 else \"black\"  # type: ignore\n                plt.text(j, i, f\"{array[i, j]:.2f}\", ha=\"center\", va=\"center\", color=text_color)\n\n    if isinstance(tmp_dir, str):\n        tmp_dir = Path(tmp_dir)\n\n    plt.grid(True)\n\n    plt.savefig(tmp_dir / filename, dpi=400, bbox_inches=\"tight\")\n</code></pre>"},{"location":"api/utils/visualization/#fdtdx.core.plotting.colors","title":"<code>fdtdx.core.plotting.colors</code>","text":"<p>Color constants for visualization and plotting.</p> <p>This module provides a collection of predefined RGB color tuples normalized to the range [0,1]. Colors are organized into categories: primary/bright colors, grayscale, and earth tones. These colors are designed to provide a consistent and visually appealing palette for plotting and visualization tasks throughout the FDTDX framework.</p> <p>Each color is defined as a tuple of (red, green, blue) values normalized to [0,1]. The normalization is done by dividing 8-bit RGB values (0-255) by 255.</p> Categories <ul> <li>Bright and primary colors: Vibrant colors for emphasis and contrast</li> <li>Grayscale colors: Various shades of gray for backgrounds and subtle elements</li> <li>Earth tones: Natural, warm colors for material representations</li> </ul> Example <p>import matplotlib.pyplot as plt plt.plot([0, 1], [0, 1], color=GREEN)  # Plot a line in vibrant green plt.fill_between([0, 1], [0, 1], color=LIGHT_BLUE, alpha=0.3)  # Fill with pale blue</p>"},{"location":"tutorials/constraint_mapping/","title":"Incorporation of Fabrication Constraints","text":"<p>When using inverse design with FDTDX, fabrication constraints have to be specified. The basic building block for an object optimizable by inverse design is a Device:</p> <pre><code>from fdtdx.objects.multi_material.device import Device\nfrom fdtdx.core.physics import constants\n\npermittivity_config = {\n    \"Air\": constants.relative_permittivity_air,\n    \"Polymer\": constants.relative_permittivity_ma_N_1400_series,\n}\ndevice_scatter = Device(\n    name=\"Device\",\n    partial_real_shape=(1e-6, 1e-6, 1e-6),\n    permittivity_config=permittivity_config,\n    constraint_mapping=...,  # &lt;- This needs to be filled\n    partial_voxel_real_shape=(0.2e-6, 0.2e-6, 0.2e-6),\n)\n</code></pre> <p>The constraint mapping, which is left empty above, specifies the mapping from continuous latent parameters to inverse permittivities used in the simulation. Note that currently only optimization of permittivitiy is implemented, but we plan to extend the inverse design capabilities to metallic materials in the very near future.</p>"},{"location":"tutorials/constraint_mapping/#simple-example","title":"Simple example","text":"<p>At the beginning of optimization, the latent parameters of a device are always initialized randomly in the interval [0, 1]. Depending on the constraint mapping, these parameteters are mapped to inverse permittivities. Let's look at an example of a simple constraint mapping:</p> <p><pre><code>from fdtdx.constraints.mapping import ConstraintMapping\nfrom fdtdx.constraints.module import (\n    ClosestIndex, \n    IndicesToInversePermittivities, \n    StandardToInversePermittivityRange,\n)\n\nmapping = ConstraintMapping(\n    modules=[\n        StandardToInversePermittivityRange(),\n        ClosestIndex(),\n        IndicesToInversePermittivities(),\n    ],\n)\n</code></pre> The constraint mapping consists of a chain of modules, or in other words a chain of transformations. Let's look at the modules in detail: - StandardToInversePermittivityRange(): This Module maps the default [0, 1] range to the range [\\(1 / \\varepsilon_{max}\\), \\(1 / \\varepsilon_{min}\\)], where \\(\\varepsilon_{max}\\) and \\(\\varepsilon_{min}\\) are the maximum and minimum permittivity specified in the permittivity config above. In other words, a latent variable of 0 would be mapped to the smallest inverse permittivity. Similarly, a value of 1 would be mapped to the largest possible inverse permittivity. - ClosestIndex(): This module finds the closest material to the mapped value output from the last module. In math-terms, this is $\\arg\\min_{\\varepsilon} |\\varepsilon - v| $, where \\(\\varepsilon\\) are the allowed permittivity values and \\(v\\) is the output of the last module. Importantly, this module does not return the \\(\\varepsilon\\) itself, but rather the index of \\(\\varepsilon\\) in the valid permittivities. - IndicesToInversePermittivities(): This module finally converts the indices generated by the last module to the inverse permittivities used in the simulation.</p> <p>This mapping constraints each voxel independently of the other voxels to the inverse permittivity of either air or polymer. However, often more elaborate fabrication constraints are needed in practice, which we introduce in the following sections.</p>"},{"location":"tutorials/constraint_mapping/#silicon-device-with-minimum-feature-constraint","title":"Silicon Device with minimum feature constraint","text":"<p>Now let's develop a constraint mapping for silicon photonics, which restricts the minimum feature size of a device. In the example above, </p> <pre><code>from fdtdx.constraints.mapping import ConstraintMapping\nfrom fdtdx.constraints.discrete import BrushConstraint2D, circular_brush\nfrom fdtdx.constraints.module import (\n    ClosestIndex, \n    IndicesToInversePermittivities, \n    StandardToPlusOneMinusOneRange,\n)\n\nbrush_diameter_in_voxels = round(100e-9 / config.resolution)\nmapping = ConstraintMapping(\n    modules=[\n        StandardToPlusOneMinusOneRange(),\n        BrushConstraint2D(\n            brush=circular_brush(diameter=brush_diameter_in_voxels),\n            axis=2,\n        ),\n        IndicesToInversePermittivities(),\n    ]\n)\n</code></pre> <p>This mapping does not just quantize the inverse permittivities, but also makes sure that the device adheres to a minimum feature size with regard to a specific brush. In this example, we used a circular brush of 100nm. In other words, one could \"paint\" the design with a brush of this size. In more detail: - StandardToPlusOneMinusOneRange(): maps the standard [0, 1] range to [-1, 1]. This is necessary, because the BrushConstraint2D expects the input to be in this range. - BrushConstraint2D(): maps the output of the previous module to permittivity indices similar to ClosestIndex() described above. However, it also makes sure that the design adheres to a minimum feature size regarding a specific brush shape. The axis argument defines the axis perpendicular to the 2D-design plane used. In our example, the perpendicular axis is 2 (in other words z/upwards). Therefore, the minimum feature constraint is enforced in the XY-plane. - IndicesToInversePermittivities(): See above.</p>"},{"location":"tutorials/constraint_mapping/#3d-fabrication-constraints-for-two-photon-polymerization","title":"3D Fabrication Constraints for Two-Photon-Polymerization","text":"<p>Lastly, let's look at a more involved constraint mapping used to Two-Photon Polymerization (2PP). In 2PP, a laser is focused on liquid monomer to harden the material. This allows the creation of fully three-dimensional designs. </p> <p>Resulting from this fabrication technique multiple constraints arise. Firstly, basic physical knowledge tells us that no material can float in the air without a connection to the ground. In 3D-design, we have to explicitly incorporate this constraint, which was not necessary in 2D (in 2D, all voxels are always connected to the ground). Secondly, there cannot be enclosed air cavities in a design for 2PP. An enclosed cavity would trap unpolmerized monomer and destroy the structural integrity of the design. However, in practice it is often not necessary to explicitly encode this constraint in the simulation. Enclosed cavities seldomly increase a figure of merit and therefore only rarely appear in an optimized design. But, it is important to check after the simulation is finished if any enclosed cavitities exist in the design.</p> <p><pre><code>from fdtdx.constraints.mapping import ConstraintMapping\nfrom fdtdx.constraints.discrete import (\n    BOTTOM_Z_PADDING_CONFIG_REPEAT, \n    BinaryMedianFilterModule, \n    RemoveFloatingMaterial\n)\nfrom fdtdx.constraints.module import (\n    ClosestIndex, \n    IndicesToInversePermittivities, \n)\n\nbrush_diameter_in_voxels = round(100e-9 / config.resolution)\nmapping = ConstraintMapping(\n    modules=[\n        StandardToInversePermittivityRange(),\n        ClosestIndex(),\n        BinaryMedianFilterModule(\n            kernel_sizes=(5, 5, 5),\n            padding_cfg=BOTTOM_Z_PADDING_CONFIG_REPEAT,\n            num_repeats=2,\n        ),\n        RemoveFloatingMaterial(),\n        IndicesToInversePermittivities(),\n    ],\n)\n</code></pre> This constraint mapping is one possibility to implement constraints for 2PP. The two new modules are: - BinaryMedianFilterModule: This module does a soft enforcement of a minimum feature size by smoothing the incoming indices (produced by the previous module) with a median filter. The kernel size describes the size of the smoothing kernel in Yee grid cells. The padding config describes how the boundaries of the design are padded for smoothing. The BOTTOM_Z_PADDING_CONFIG_REPEAT uses a repeat of the boundary values except at the bottom of the design, where the design is padded with non-air-material. Heuristically, this gives the design better ground contact. The num_repeats argument specifies how often the smoothing filter is applied. - RemoveFloatingMaterial: As the name suggests, this module goes through the indices generated by the previous module (BinaryMedianFilter) and removes any floating material without ground connection. Ground connection is computed using a simple flood fill algorithm and all voxels with floating material are converted to air.</p>"},{"location":"tutorials/interface_compression/","title":"Gradient computation by time reversibility","text":"<p>FDTDX implements automatic differentiation by exploiting the time-reversibility of Maxwell's equations. You can find more details about the time-reversible gradient computation in our paper. </p> <p>For this tutorial, the important point to note is that during the forward simulation, the interface region between PML and actual simulation volume needs to be saved at every time step. Even though this is better than the standard implementation of AutoDiff (which would save the whole 3D volume at every time step), this can still lead to large memory requirements if the simulation is large or the simulation time long. </p> <p>As a remedy, we implement a compression mechanism for these saved fields. The compression settings can be adjusted in the simulation config: <pre><code>from fdtdx.core.config import GradientConfig, SimulationConfig\nfrom fdtdx.interfaces.modules import DtypeConversion\nfrom fdtdx.interfaces.recorder import Recorder\nfrom fdtdx.interfaces.time_filter import LinearReconstructEveryK\nimport jax.numpy as jnp\n\ngradient_config = GradientConfig(\n    recorder=Recorder(\n        modules=[\n            LinearReconstructEveryK(2),\n            DtypeConversion(dtype=jnp.float16),\n        ]\n    )\n)\nconfig = SimulationConfig(\n    time=300e-15,\n    resolution=100e-9,\n    dtype=jnp.float32,\n    courant_factor=0.99,\n    gradient_config=gradient_config,  # &lt;- This needs to be set for gradient computation\n)\n</code></pre> Similarly to the constraint mappings, the recorder of the gradient config is defined by a list of modules, which are applied consecutively. In this example, the following two modules are used: - LinearReconstructEveryK: Firstly, this module only saves the boundary fields at every second time step. During reconstruction, the missing values are recomputed by linearly interpolating between the saved time steps. The attribute k=2 defines the step size. - DtypeConversion: The output of the previous module is converted to a different data type. In our example, the simulation runs with 32 bit floating point precision and the module converts these values to 16 bit precision, again saving 50% of the required memory.</p> <p>At the moment, these are the only two important compression modules implemented. Experience has shown that in almost all cases 8bit precision is also sufficient, namely the data type \"jnp.float8_e4m3fnuz\". </p> <p>Regarding the number of time steps, a rule of thumb is that 10 time steps per period should be saved for accurate results. Often lower saving intervals also suffice, but one needs to make sure that this is actually the case. So for example, if the simulation performs 30 time steps per period (this depends on the Courant-Friedrichs-Levy Condition), then a compression of LinearReconstructEveryK(3) should be used to save 10 time steps. The number of time steps per period can be computed by: <pre><code>from fdtdx.core.physics import constants\nwavelength = 1.55e-6\nperiod = constants.wavelength_to_period(wavelength)\nsteps_per_period = period / config.time_step_duration\n</code></pre></p>"},{"location":"tutorials/interface_compression/#gradient-computation","title":"Gradient Computation","text":"<p>The actual gradient computation can be invoked using the standard jax.grad method on the fdtd_reversible function call. In pseudocode this might look something like this: <pre><code>def loss_function(params, ...)\n    arrays, new_objects, info = apply_params(arrays, objects, params, key)\n\n    _, arrays = reversible_fdtd(\n        arrays=arrays,\n        objects=new_objects,\n        config=config,\n        key=key,\n    )\n    loss = - figure_of_merit(arrays.detector_states)\n    return loss\n\ngrad_function = jax.grad(loss_fn)\ngrad_loss_wrt_params = grad_function(params)\n</code></pre> Of course figure_of_merit can be any objective function that should be optimized. The apply_params function internally calls the constraint mapping of the device and sets the proper inverse permittivities for the simulation.</p>"},{"location":"tutorials/materials/","title":"Materials Guide","text":"<p>In FDTDX, objects can have different permittivities and permeabilities. Currently, the conductivity of all materials is assumed to be zero, but we are planning to implement conductive materials in the very near future.</p> <p>Also, currently neither dispersion nor non-linear materials are implemented. The implementation of dispersion is scheduled in the near-mid future and afterwards an implementation of non-linear materials will follow.</p> <p>This guide is currently very short and will be expanded with them implementations mentioned above.</p>"},{"location":"tutorials/materials/#uniformmaterial","title":"UniformMaterial","text":"<p>The most basic and also probably most useful object is the UniformMaterial. As the name suggests, it has a single permittivity and permittivity. <pre><code>from fdtdx.core.physics import constants\nfrom fdtdx.objects.material import UniformMaterial\nfrom fdtdx.core.plotting import colors\n\nuniform_obj = UniformMaterial(\n    partial_real_shape=(0.6e-6, 0.6e-6, 0.6e-6),\n    permittivity=constants.relative_permittivity_silica,\n    # permeability is one by default\n    permeability=1.0,\n    color=colors.CYAN,\n    name=\"uniform_obj\",\n)\n</code></pre> The name and color attribute are only used for plotting and do not have any effect on the simulation.</p>"},{"location":"tutorials/materials/#device","title":"Device","text":"<p>For inverse design, it is necessary to model objects that can either be one or the other materials. In some applications, it might even be necessary to model objects consisting of more than two materials.</p> <p>In this example, we create a device consisting of voxels that are either air or polymer. <pre><code>permittivity_config = {\n    \"Air\": constants.relative_permittivity_air,\n    \"Polymer\": constants.relative_permittivity_ma_N_1400_series,\n}\ndevice_scatter = Device(\n    name=\"Device\",\n    partial_real_shape=(1e-6, 1e-6, 1e-6),\n    permittivity_config=permittivity_config,\n    constraint_mapping=...,\n    partial_voxel_real_shape=(0.2e-6, 0.2e-6, 0.2e-6),\n)\n</code></pre> The device has a permittivity config, which defines the different permittivity options. This is currently only implemented for permittivity, but we will expand it in the future to metallic materials as well. </p> <p>The partial_voxel_real_shape argument specifies the size of the uniform material voxels within the device. In this case, voxels, of 200nm^3 have a single permittivity. Since the device has a shape of 1\u00b5m^3, there are 5x5x5=125 of these voxels within the device. </p> <p>Importantly, the size of the device needs to be divisible by the voxel size. Additionally, the voxel size needs to be suffiently larger than the resolution of the Yee-grid in the simulation. For example, if the resolution of the Yee-grid is also 200nm, then this simulation will not produce accurate results. As a rule of thumb, the resolution of the Yee-grid should be at least three times smaller than the size of the voxels.</p> <p>The device has one latent parameter for every voxel. Initially, these latent parameters are uniformly random in the interval [0, 1]. The constraint mapping defines how these latent parameters are mapped to actual inverse permittivity choices. A detailed guide on this topic can be found here.</p>"},{"location":"tutorials/object_placement/","title":"Object Placement Guide","text":"<p>This guide explains how to position objects in a simulation scene in FDTDX. The basic workflow looks like this: 1. Define a Simulation volume 2. Define objects and sizing/placement constraints between objects 3. Compute the actual position of objects in the simulation scene by using the place_objects function 4. Optional, but recommend: Plot the simulation scene using plot_setup() 5. Run a simulation</p>"},{"location":"tutorials/object_placement/#basic-positioning","title":"Basic Positioning","text":"<p>In FDTDX, objects are positioned either directly or relation to other objects through constraints. </p> <p>The first step should always be to define the size of the simulation volume.  FDTDX always uses metrical units, i.e. meters or grid positions referring to the Yee-grid,  which depends on the resolution used. <pre><code># create a simulation config\nconfig = SimulationConfig(\n    time=200e-15,\n    resolution=100e-9\n)\n# Create a simulation volume\nvolume = SimulationVolume(\n    partial_real_shape=(4e-6, 4e-6, 1.5e-6),\n)\n</code></pre></p> <p>We can already use the place_objects and plot_setup function to see the simulation volume. <pre><code>key = jax.random.PRNGKey(seed=42)  # random key\n# place objects and resolve constraints\nobjects, arrays, params, config, info = place_objects(\n    volume=volume,\n    config=config,\n    constraints=[],\n    key=key,\n)\n# plot the simulation scene\nfig = plot_setup(\n    config=config,\n    objects=objects,\n)\nfig.savefig(\"empty_scene.png\")\n</code></pre></p> <p></p> <p>Now, we can start to position some objects in the simulation scene.  We start with a substrate at the bottom of simulation.  To this end, we specify a constraint that aligns the objects in the z-axis (axis 2). The user should specify these constraints and collect them in a list.</p> <p>Positional constraints define an anchor point for both objects, which are constrainted to be at the same position.  The position of the anchor point can be specified in a relative coordinate system of each object.  A relative coordinate system means that a position of -1 would place the anchor at the left boundary of the object,  a position of 0 at the middle and a position of 1 at the right boundary.</p> <p>In case of the substrate, we want the lower boundary of the substrate to be aligned with the lower boundary of the simulation volume.  This ensures that the substrate is placed exactly at the bottom of the simulation.</p> <pre><code># create list of constraints\nplacement_constraints = []\n# create substrate\nsubstrate = UniformMaterial(\n    partial_real_shape=(None, None, 0.6e-6),\n    permittivity=constants.relative_permittivity_silica,\n)\n# place at the bottom of simulation volume\nconstraint = substrate.place_relative_to(\n    volume,\n    axes=2,\n    own_positions=-1,\n    other_positions=-1,\n    margins=0,\n    grid_margins=0,\n)\nplacement_constraints.append(constraint)\n</code></pre> <p>The margins and grid_margins arguments are optional and would allow to speficy a fixed distance between  the anchor points. The margins argument is in units of meters, the grid margins in units of yee-grid cells. Plotting this again results in</p> <p></p> <p>There exist a number of useful shorthands for rapid placements. Some of them are listed below that place  a cube in the scene. The name and colors argument are only used for plotting.</p> <p><pre><code># place an object on top (z-axis / 2) of another object\ncube1 = UniformMaterial(\n    name=\"cube\",\n    color=colors.GREEN,\n    partial_real_shape=(0.5e-6, 0.5e-6, 0.5e-6),\n    permittivity=constants.relative_permittivity_silicon,\n)\nplacement_constraints.append(\n    cube1.place_above(substrate)\n)\n\n# place an object at the center of another object\nplacement_constraints.append(\n    cube1.place_at_center(\n        substrate,\n        axes=(0, 1),\n    )\n)\n</code></pre> </p>"},{"location":"tutorials/object_placement/#size-configuration","title":"Size Configuration","text":"<p>Object sizes can be specified in a number of ways.  Firstly, one can directly set the size of an object in the init method. This can either be a specified in Yee-grid cells or metrical units (meter).</p> <p><pre><code># size in meters\ncube = UniformMaterial(\n    partial_real_shape=(0.3e-6, 1.0e-6, 0.7e-6),\n    ...\n)\n</code></pre> </p>"},{"location":"tutorials/object_placement/#size-in-grid-units","title":"Size in grid units","text":"<p><pre><code># size in grid units (each 100nm as defined in config above)\ncube = UniformMaterial(\n    partial_grid_shape=(4, 10, 2),\n    ...\n)\n</code></pre> </p>"},{"location":"tutorials/object_placement/#combination-of-grid-and-metrical-units","title":"Combination of grid and metrical units","text":"<p><pre><code># partial combination\ncube = UniformMaterial(\n    partial_real_shape=(None, 0.5e-6, None),\n    partial_grid_shape=(3, None, 1),\n    ...\n)\n</code></pre> </p>"},{"location":"tutorials/object_placement/#undefined-sizes-can-be-useful","title":"Undefined Sizes can be useful","text":"<p>If the size of an object is only partially defined and does not have any constraints, the size is set to the size of the simulation volume in the respective axis. We actually already used this behavior to define the substrate above.</p> <p><pre><code># z-axis is undefined, size is extended to simulation size\ncube = UniformMaterial(\n    partial_real_shape=(None, 0.5e-6, None),\n    partial_grid_shape=(3, None, None),\n    ...\n)\n# This now results in an error:\nplacement_constraints.append(\n    cube1.place_above(substrate)\n)\n</code></pre> Using this specification for the cube, we get the following error: <pre><code>Exception: Inconsisten grid shape (may be due to extension to infinity) at lower bound: 0 != 6 for axis=2, cube (&lt;class 'fdtdx.objects.material.UniformMaterial'&gt;). Object has a position constraint that puts the lower boundary at 6, but the lower bound was alreay computed to be at 0. This could be due to a missing size constraint/specification, which resulted in an expansion of the object to the simulation boundary (default size) or another constraint on this object.\n</code></pre> The error occurs, because we tried to place the cube above the substrate, which is no longer possible if the z-size of the cube is the whole simulation size. When we remove the problematic placement constraint, we get the correct simulation scene. </p>"},{"location":"tutorials/object_placement/#relative-sizing-constraint","title":"Relative Sizing constraint","text":"<p>The size of an object can also be set in relation to another object. To demonstrate this, we define a second cube, which should be placed above the substrate and have a 200nm distance to the other cube in the x-axis. <pre><code>cube2 = UniformMaterial(\n    name=\"cube2\",\n    color=colors.GREEN,\n    partial_real_shape=(0.5e-6, 0.5e-6, 0.5e-6),\n    permittivity=constants.relative_permittivity_silicon,\n)\nplacement_constraints.extend([\n    cube2.place_above(substrate),\n    cube2.place_relative_to(\n        cube1,\n        axes=(0, 1),\n        own_positions=(1, 0),\n        other_positions=(-1, 0),\n        margins=(-200e-9, 0)\n    )\n])\n</code></pre> </p> <p>Now let's change the size definition of the second cube to a relative size constraint, which defines the y-size of the second cube as the size of the first cube in the z-axis. <pre><code>cube2 = UniformMaterial(\n    name=\"cube2\",\n    color=colors.GREEN,\n    partial_real_shape=(0.5e-6, None, 0.5e-6),\n    permittivity=constants.relative_permittivity_silicon,\n)\nplacement_constraints.append(\n    cube2.size_relative_to(\n        cube1,\n        axes=1,\n        other_axes=2,\n        proportions=1.0,\n    )\n)\n</code></pre> </p> <p>Another useful convenience wrapper is the following: <pre><code>object1.same_size(object2, axes=(0,1))\n</code></pre></p>"},{"location":"tutorials/object_placement/#extending-objects-to-other-objects-or-simulation-boundaries","title":"Extending objects to other objects or Simulation boundaries","text":"<p>The last method to set the size of an object is to constrain the size, such that it extends up to another object in the simulation scene.</p> <p><pre><code># definition of first cube\ncube1 = UniformMaterial(\n    partial_real_shape=(0.5e-6, 0.5e-6, 0.5e-6),\n    name=\"cube\",\n    color=colors.GREEN,\n    permittivity=constants.relative_permittivity_silicon,\n)\nplacement_constraints.append(\n    cube1.place_above(substrate)\n)\nplacement_constraints.append(\n    cube1.place_at_center(\n        substrate,\n        axes=(0, 1),\n    )\n)\ncube2 = UniformMaterial(\n    name=\"cube2\",\n    color=colors.MAGENTA,\n    partial_real_shape=(None, 0.5e-6, 0.5e-6),\n    permittivity=constants.relative_permittivity_silicon,\n)\nplacement_constraints.extend([\n    cube2.place_above(substrate),\n    # place at center of y-axis\n    cube2.place_at_center(\n        cube1,\n        axes=1,\n    ),\n    # extend object up to first cube\n    cube2.extend_to(\n        cube1,\n        axis=0,\n        direction=\"+\",\n    )\n])\n</code></pre>  This constrains the size of cube2 such that its upper boundary (\"+\") extends directly up to cube1 in the x-axis.</p> <p>See the Objects API Reference for complete details on all positioning and sizing options.</p>"}]}